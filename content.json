{"meta":{"title":"布执刀","subtitle":"布执刀","description":"欢迎大家与我一起交流学习","author":"Jia_KHC","url":"https://jia_k3.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-06","excerpt":""},{"title":"我的信息","text":"啊~暂时没有。","path":"about/index.html","date":"01-06","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"01-06","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-06","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"01-06","excerpt":""}],"posts":[{"title":"《费曼学习法》读书笔记","text":"书籍详细信息书名：费曼学习法（用输出倒逼输入）作者：尹红心、李伟书号：ISBN 9787559454911 感悟与总结 任何总结都比不过原文，这篇博客只是将看书时的个人感悟记录了下来。但是这本书里面充斥大量有必要、没必要的举例，如果已经理解了作者要表达的意思，就完全没必要看举的例子。 费曼学习法的核心，是把复杂的知识简单化，以教代学，让输出倒逼输入。它对输出思维极其推崇，认为输出就是最强大的学习力，能不卡壳复述学习内容，才是学全；它对简化思维格外重视，强调找出问题的要害，把复杂的知识简单化，认为把高深的知识用平实的话说出来，才是学透。 费曼学习法四个关键词：Concept（概念）；Teach（以教代学）；Review（评价）；Simplify（简化）。理解学习的本质 P5原文：传统学习的优缺点。 虽然不推崇传统学习，但是传统学习确实有它的优点，那么~费曼学习法的缺点是什么呢，想想看传统学习跟谁对比来的优点吧。 这里也不是推崇传统学习，而是事物的存在必定有其合理的部分。为什么这么多年教育界还是选择传统学习，现世的诸多限制罢了。 所以也不能完全死板套这个框架，如果是费曼老爷子重生一世还想为人类做贡献，他可能还是选择这种方法，诺贝尔奖也只是认可他的这种做法。 如果想要做一件不做可能会后悔一辈子的事情，又由于诸多限制无法采用费曼学习法，不用怀疑自己，费曼学习法不适合那时候的自己，放手做就是，没有所谓的绝对正确，抓紧机会留住自己最宝贵的东西。 P6原文：学习的最终本质应该是输出而不是输入。 作者拿传统学习方式做对比，说明学习的最终本质。 P8原文：潜台词则是：学习改变不了今天。 作者拿学生时代老师、家长常用论调分析潜台词，然后指出这种思维是错误的。后面用一句话总结“实践是检验真理的唯一标准”。 P9原文：只有将学习从功利性的导向中收回来，专注于如何吃透一门知识，怎样让这些知识在今天就可以让自己变得更好，你才能真正地提高学习能力 其实全书基本都在讲“把学习当作一种提升自己的活动”，这确实是最佳“解决”方案。 不禁让我想到“别人家的孩子”可以把学习当作娱乐、一种兴趣，这样的观念确实可贵，但是只凭我自己对自己的了解，我大概率一辈子不会把学习当作一种娱乐，个人的局限性？或是思想被毒害已久，难以疗愈？ P9-P11原文：费曼认为，好的学习方法能够为一个人创造宏大的视野和对世界犀利的理解力。……学习，究其根本是思维方式的比拼，不是知识存储的较量，也不是学位的竞争。……只有获取更强大的学习能力，我们才能更好地开发自我，在社会的金字塔结构中争取一个有利的位置，否则就会滑向社会的底层。 远见，非常人所能及，细数历史，越是重大的事件，牵扯的因素越多，越是难以预料。我认为远见能力只需要尽力即可，不必要求自己一定具备。 穿透力，开始读这样的书的人自然不会缺乏这样的意识。 后面就是在强调思维方式的重要性，说明了学习中学的主要内容。 P14原文：费曼学习法四个关键词：Concept（概念）；Teach（以教代学）；Review（评价）；Simplify（简化）。 细数求学的三年，（高中时期）仅凭高二悟出的“概念”宝典便可以做到应对高考（虽然没做到极致），高二代上数学竞赛课程等输出无意识做到“以教代学”，“评价”自不会缺少，只有“简化”这一步压根没有主动涉及。 其实“概念”也可以延伸到“方法”等，但终究不如“定义”来的简洁。 P16原文：重点是你不要独自钻研和学习，要多和外界互动。 了解成语闭门造车（双面词），事非黑白，都有两面性，这里可以直接理解为不要太盲目、不管不顾。 人生导师卡密尔：世界既不黑也不白，而是一道精致的灰。 P17原文：费曼学习法的作用就是一种马太效应。 打过游戏的我初读到这里非常兴奋，马太效应不就类似游戏里的滚经济嘛，到最后直接经济碾压赢得比赛，简单粗暴。作者再说费曼学习法就符合马太效应，直接“彻底疯狂”。 其实看完全书之后回过头再看这里，哈哈，先看一看P63“强意识”的描述冷静一下吧。 P20原文：专注是一切成功学习的基础。 经典正确的废话。确定目标 P29原文：学好一门知识的前提是必须充分地理解这门知识，包括它尚未开发的价值。 知己知彼，远见。 P31原文：目标其实是一个动态变化的信标。 首先，为什么不收录下面加粗的“最务实的做法”？因为动态变化。 其实直接套用马斯洛需求层次理论，满足阶段目标自然开始追求更高的目标。 关键是“舍得”，有的时候要懂得放手，一个领域投入了很多的沉没成本，以自己能力难以有成果就该舍弃了。 然后又引出了一个关键问题：如何判断到了放手的时候，如何判断这个目标已经不合适了？这就是这本书写的一般的原因，很难用小篇幅写完延伸出的很多问题。特别是这些问题没有十分正确的答案，限于能力，只能言尽于此。后面有本书对于错误目标的判断准则：“SMART原则”。 P32-33原文：事情有轻重缓急，最重要的事情就是我们已经制定的这个明确的目标，其他一切都不重要。……任何事成功的关键都不在于你想要做好几件事，而在于你能否做好几件事。 列目标清单的方法有很多，可以选一个合适的方法替换这里模糊的“列目标”阶段。 有点类似“行动胜于雄辩”，突出一个“行动”。 P34原文：这个世界所有的答案都源于问题，任何一个答案的质量都取决于问题的质量。 看起来是在说问题之于答案，实则是在说目标之于行动。 问题平凡，答案自然一般。目标错误，行动……当然也有人说“比起担心会后悔而什么都不做，还不如做完了再去后悔”，或者“有所为则成，无所为则败”，还是要辩证看待，如果我们是第一批研究核武的人，就算没有目标也得上嘛。 P42-43原文：聪明的学习者善于反问和反省，愚蠢的学习者则喜欢自我感动，将一个错误的目标偏执地坚持到底。……“SMART原则”提供了一个简单明了的判断标准：S:（Specific）明确和具体的。M:（Measurable）可以衡量/量化的。A:（Achievable）自身能力可以达到的。R:（Rewarding）能产生满足感/成就感的。T:（Time-bound）有时间限制的。 判断准则写起来非常“简单明了”，应用起来可就因人而异了，比如我自己的测量意识很差，我也不知道多久能做完一个模块；比如我的眼界不够，我以为自己努力就可以做到，实际愚公移山。辩证看待，使用经验丰富自己的准则。 其实很多时候都是靠直觉去评判的，这个玄学的东西很难说，至少本人是被直觉骗过好多次。 P46原文：在计划和行动的过程中根据反馈随时修正目标，改善或改变学习的计划，保证自己始终在一条正确的轨道上。 正确的废话，关键是结合自己情况去判断改善或改变的时机，不单单只靠反馈。系统性理解 P55原文：在《发现的乐趣》一书中，费曼接受采访谈到学习时认为，如果一个人不能有意愿和彻底地、深入地理解自己的学习对象，不知道自己究竟在学习什么，对于知识的印象十分模糊空洞，在学习上付出再多的努力也不可能会有好的收获。 知道自己在做什么，才能更好的做。有的人造原子弹的时候没有多想，造出来才开始后悔。 有的时候受限于自己眼界，确实无法完全理解自己要做什么，但是既然决定做，就不需要后悔，毕竟是再三考虑之后的决定。 P56原文：逻辑就是你理解知识的出发点、角度、立场和思维方式；系统化则是你是否可以将这些知识纳入一个宏观的知识体系，互相印证和科学对比，对既有的知识体系形成补充。 拼图，答案越写越知道该写什么。 P58原文：人要尽量保持童真，因为童真的心态能扩大你的视野，让你愿意并且能够在这个世界中看到更多的“可能性”。 辩证看待，这里童真表示一种心态，自己具备的专业知识还是不能丢，不能完全回到“童年”。 P59-60原文：学习最重要的并不是找到那些价值千金的知识，而是通过对知识的筛选与吸收建立起自己的思维框架。……我要找出那些与我的实际需求相匹配的只是。 全文最核心的来了，为什么“因材施教”，就是因为每个人有每个人的思维特色，这里给的大一统思维模型终究只是参考，辩证内化为自己的东西才是正解。 坚持理论结合实际，做到理论与实际相结合。 P64-65原文：对于专业和权威的来源，我们也要学会独立思考和谨慎地采纳。……把这些来源得到的知识互相印证对比，找出对你重要的、不同领域的知识，再进行深度的学习。在学习中，请你忘掉过去累积的所有的技能。 谨慎没问题，相互印证对比没问题，忘掉过去？还是谨慎吧 P67原文：为知识画一张思维导图的最主要目的，就是扩大眼睛的作用，让知识变得立体化，使它的整体结构通过眼睛传输到大脑，可以节省很多不必要的精力。 结合P68费曼老爷子的话，经典错误，视觉确实承担了大脑80%的信息输入任务，但是这并不能说明思维导图的重要性。 我并不是否认思维导图的意义，正如我之前提到的“存在即合理”，思维导图存在和发扬光大说明它肯定是有道理在里面的。 但是要辩证看待它，不要盲目去画思维导图，就比如这本书，目录已经足够了，没有必要再为了它画一张思维导图。 那么思维导图什么时候最有用，我认为在梳理整团知识的时候最有用，其底层逻辑还是目录。不过是把一维拓展到了二维。 P87原文：系统思考从本质上讲，就是从事物/知识的互动关系入手，而非从事物/知识本身入手。 一般来说，个人了解的各个知识可以组成一个连通图，独立的节点很难存在，学习的时候如果不考虑互动关系确实会加大理解的难度。输出 P119原文：为知识注入你的灵魂没有灵魂的知识就像路边枯萎的树叶，看似脉络分明，却早已失去生命力。……第一，体现独具特色的语言技巧——使用你自己的语言表述知识，而不是原封不动地背诵；第二，结合现实阐述你对知识的解释——不仅把知识复述出来，还要让它在现实中落地；第三，表达出你个人的分析和见解——复述不是当复读机，学习也不是当打印机，要为知识注入你个人的理解，并且通俗易懂地对别人讲出来。 借助各种现实媒介，用自己的语言说明。 P122原文：五个输出原则：场景和思维模拟语言通俗易懂简洁的同时具有深度强化对重点知识的理解利用分组讨论获得反馈 我认为重点在于“简洁的同时具有深度”，如何把握“简洁”与“深度”间的度是关键问题。回顾和反思 P163-165原文：知识的原理比知识本身对我们更有价值。……怀疑和探索……寻找反证……加大“内容留存率” 这个阶段和输出相辅相成，循环往复，不断寻找理解不足的模块加深理解。简化和吸收 P203-204原文：简化原则一：对所学的知识系统性深挖。针对需要的知识针对重要的知识针对核心的知识……简化原则二：形成自己的知识体系。成为某个领域的专家专注和针对性建立自己的知识体系","path":"2024/11/24/fei-man-xue-xi-fa-du-shu-bi-ji/","date":"11-24","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://jia_k3.gitee.io/blog/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"Ollama简单配置","text":"Ollama介绍Ollama是一个创建、运行和管理大语言模型(LLM)的工具。 Ollama安装 官网：ollama 下载安装资源包并运行安装程序 输入ollama验证安装Ollama启动 一般启动Ollama：ollama serve Linux设置Ollama为自启服务：StartupService 2.1. 创建Ollama用户与用户组 sudo useradd -r -s /bin/false -U -m -d /usr/share/ollama ollama sudo usermod -a -G ollama $(whoami) 2.2. 创建服务配置文件于/etc/systemd/system/ollama.service [Unit] Description=Ollama Service After=network-online.target [Service] ExecStart=/usr/bin/ollama serve User=ollama Group=ollama Restart=always RestartSec=3 Environment=\"PATH=$PATH\" [Install] WantedBy=default.target 2.3. 启动服务 sudo systemctl daemon-reload sudo systemctl enable ollama sudo systemctl start ollama sudo systemctl status ollama 下载训练好的大模型 在资源网站找到对应大模型：Models 运行介绍页面命令下载大模型ollama run ***设置局域网访问(Linux) 设置Ollama为自启服务启动 在/etc/systemd/system/ollama.service文件中Service条目添加如下代码Environment=\"OLLAMA_HOST=0.0.0.0:11434\" Environment=\"OLLAMA_ORIGINS=*\" 重启服务systemctl daemon-reload systemctl restart ollama 其他平台参考：Setting environment variables卸载(Linux) 如果设置了Ollama服务sudo systemctl stop ollama sudo systemctl disable ollama sudo rm /etc/systemd/system/ollama.service sudo userdel ollama sudo groupdel ollama 删除Ollama二进制文件sudo rm $(which ollama) 删除下载的大模型sudo rm -r /usr/share/ollama","path":"2024/09/15/ollama-jian-dan-pei-zhi/","date":"09-15","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://jia_k3.gitee.io/blog/tags/Linux/"},{"name":"LLM","slug":"LLM","permalink":"https://jia_k3.gitee.io/blog/tags/LLM/"}]},{"title":"《这本书能让你戒烟》读书笔记","text":"书籍详细信息书名：这本书能让你戒烟Name: THE EASY WAY TO STOP SMOKING作者：[英] 亚伦.卡尔翻译：严冬冬版次：2009年1月第一版书号：ISBN 9787807027577 感悟与总结 任何总结都比不过原文，这篇博客只是将看书时的个人感悟记录了下来。实际上我并不吸烟，看这本书纯粹是为了打发时间，但三个半小时读下来获益匪浅。 催眠的定义 P19原文：催眠是一种强大的交流和说服工具，可以达到良好的正面效果，也可以产生毁灭性的负面效应。 作者提到催眠疗法时给出了催眠的定义，的确，催眠也只是一种工具，类似人工智能算法，都是为了达到某些目的而采用的手段，不需要去”神圣化”这种工具。轻松戒烟法中自问的3个问题 P27原文： 吸烟究竟有什么用？ 我真的在享受吗？ 我真的必须为了把烟卷叼在嘴里、让自己窒息而付钱吗？ 实际上全文都是在通过让读者想清楚这些问题的答案，来让读者自然而然的不想吸烟。 对于“思考”、“想”，后面作者会与读者有更深层次的探讨。吸烟的陷阱：洗脑 P50原文：广告商们非常清楚心理暗示对潜意识的影响力。 无论我们是否认同这一观点，这其实是不需要证明的“事实”。 在控制领域，工程师想要控制机械臂抓取一件物品，需要详细了解控制理论，明白机械臂各个参数以及控制影响，通过深度理解与实践，最终操控机械臂完成抓取任务。 在人工智能领域，算法设计师通常只要设定抓取成功的判断条件，在不同分支设定不同其他参数，就可以让算法驱动机械臂去“尝试”抓取。最后如果训练出来的模型效果非常好，就可以驱动算法完成操控机械臂抓取任务。 对比上述两个例子：会发现算法设计师根本不需要理解控制领域的相关知识，只需要让算法不停试错，最终找到正确的操控方案。 我认为广告商们虽然都是拼杀出来的“天下英雄”，但是他们不会去深度了解成功的原理，他们只需要不断寻找能够达到更好效果的广告方案，然后坚定不移地采用。只有心理学家需要去分析效果好的广告的深层原理。 P52原文：我们的主观意识或许会直接忽略这样的场面，但是潜意识却难免受其影响。 这里“这样的场面”指的是影视中吸烟的“优雅”桥段。 可能有人会开始担心这种情况，并思考如何做可以减少这种情况。我认为没有太大的必要，因为潜意识就是潜意识，是人不可直接控制的，我们只需要做好每一件事就好了。 百善孝为先，论心不论迹，论迹寒门无孝子；万恶淫为首，论迹不论心，论心世上无完人。 控制好主观意识，做好自己的事，潜意识就丢给专家分析就好了。吸烟者的“理性思考” P27原文：绝大多数吸烟者在吸烟时都会进行理性思考，但他们所谓的理性其实是错觉与幻想的结合。 通读全文可以发现作者通过这本书想要达成的目标基本就是教会吸烟者如何”理性思考”。 P52原文：讽刺的是，最强大的洗脑力量来源于吸烟者自己。吸烟者绝不是意志薄弱或身体虚弱的人，相反，只有身体强健才能抵抗香烟中的毒素。 这一点可能就是成瘾者最能感受到的，作者点出来，后面我会越来越认同这个观点。 吸烟不会使注意力集中 P65原文：需要集中注意力时，你会自动忽略掉其他的感觉，如周围温度的高低等。当一个吸烟者需要集中注意力时，因为“吸烟有助于集中注意力”的说法，他会点起一支烟，然后立即忽略自己正在吸烟的事实吸烟并不能帮你集中注意力，只会适得其反，因为香烟一熄灭，尼古丁戒断症状就会迅速浮现，逼你不得不分心，再点上一支烟。 音乐呢，最开始我必须边听音乐边学习，这一点毫无疑问也是“错觉与幻想的结合”。 细思极恐的例子—皮肤药 P73-P74原文总结：假设得皮肤病，医生有特效药，但越用药效消耗得越快，后证明不用药就会好，你还会继续用药吗？ 本书的阳谋实际上全文都是基于这个约定来的：看这本书的时候吸着烟 在P81原文：现在还不行——记住之前的指示 到这里会发现作者设计的精妙的开局设定，完全是基于完美把握的思考过程而设定的阳谋。 享受？ P87原文：想象一下，海洛因上瘾者如果得不到海洛因，该有多么痛苦，而当他们终于得到海洛因注射时，痛苦就会缓解。你能把这种暂时的缓解称为享受吗？非海洛因上瘾者绝不会有这样的“享受”，因为他们原本就没有痛苦。 这里的解释可以换一种方式：人正常时感受的舒适度为2，吸烟后会强行降低到1，突然停止吸烟会使舒适度降低到0，再次吸烟会使舒适度从0上升为1。“享受”就是从0上升到1的过程，实际上也是痛苦。 “一支烟”比喻 P93原文：不妨换个角度思考：每一支烟都会导致你继续抽下一支烟，你一辈子吸的烟可以连接成一条导火索。问题在于，你不知道导火索到底有多长。每当你点起一支烟，导火索就烧掉了一点，你离最终的大爆炸又近了一步。你怎么能知道爆炸会在什么时候发生？ 这也是本书破除吸烟者以前“理性思考”的重要一种手段：吸一支烟就是吸一辈子烟。 吸烟的好处看我干嘛，看书去，书上这一章写的过于美好，我难以用文字去总结。 靠意志力戒除 P108原文：意志力戒烟法通常需要很长的时间，因为戒烟的最大问题在于洗脑，而不是生理上的毒瘾。 延伸到其他领域是否成立呢？助眠上瘾、听音乐集中注意力。 减量法戒烟的问题 P113原文：戒烟的最大障碍在于心理上的洗脑，在于误认为吸烟是一种享受，戒烟意味着放弃这种享受。减量法并不能降低你对吸烟的心理依赖，只能增加你的痛苦和不安全感，让你相信香烟是世界上最好的东西，戒烟会剥夺你生活的快乐。一旦采用减量戒烟法，戒烟者就陷入了十分矛盾的境地。他的想法是，吸得烟越少，他就会越不想吸烟。事实则正好相反，他吸得烟越少，戒断症状就约严重，他对尼古丁的饥渴也就越迫切。相反，他吸的烟越多，对烟味就越难以忍受，但这也不会让他停止吸烟。 存在即合理。减量法依旧存在肯定是有人证明了它确实可以戒烟，但其实可以尝试用作者的思维解释：突然忙了几天，聪明人发现自己不想吸烟，于是看破。也由于这些是“聪明人”，人们也愿意相信减量法可行。 但是这种思路不可能只有我想得到，为什么作者的读者中没有向他反馈呢？戒烟的时机 P135-140原文无可代替 团队的缺点 P147原文： 戒烟动机本身并不成立。戒烟是你自己的事情，跟别人有什么关系？ “烂苹果理论”，也就是戒烟者彼此之间的依赖。 “成就感的分摊”，原理正好与“烂苹果理论”相反。 身处团队中自然而然想不清一些道理，尤其是其他人等你的反馈时，还有气氛等的因素，比较复杂，但是确实可以确定有缺点。 作者的思路起源与总结 P150 起源：深入思考-有意识分析-观察成功的人-与成功的人交流 总结：痛苦并不存在，痛苦是犹豫和怀疑的产物。轻松的秘诀是下定决心。","path":"2024/08/01/zhe-ben-shu-neng-rang-ni-jie-yan-du-shu-bi-ji/","date":"08-01","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://jia_k3.gitee.io/blog/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"Unity+AndroidStudio混合开发：安卓手机桌面宠物","text":"Unity+AndroidStudio混合开发：安卓手机桌面宠物 开发流程：Unity导出透明背景的宠物组件AndroidStudio导入组件后二次开发 Unity宠物组件设置1.将宠物设置好后调整宠物大小占满整个屏幕，效果如图 2.调整Camera配置，Clear Flags-&gt;Solid Color，Background-&gt;RGBA0000，设置如图： 3.Unity设置如导出Android传统项目即可，最后勾选Export Project，如图所示 4.点击Export，等待导出成功即可 Android导入组件并进行二次开发1.以Module的形式导入，如图 上图中的launcher是Unity自带的微启动器，并不需要导入 2.在ProjectStructure中为app主程序添加unityLibrary依赖(Module Dependence) 3.将unityLibrary的sdk配置设置为与app主程序相同，在Project Structure的Modules中配置即可 4.进入项目文件列表，将unityLibrary-&gt;libs-&gt;unity-classes.jar复制到app主程序的libs文件夹下并添加库依赖（需要使用其中的类进行开发，否则可能提示找不到类） 5.打开unityLibrary的AndroidManifest.xml文件，进行如下修改 android:process=\":raadidcard\" 其中添加部分修改启动模式，注释部分作用是创建安装图标，我们在app主程序使用即可 6.打开app主程序的AndroidManifest.xml文件添加代码，如下图 xmlns:tools=\"http://schemas.android.com/tools\" &lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; &lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt; tools:replace=\"android:icon,android:theme,android:allowBackup\" 7.打开app主程序的build.gradle文件添加代码段如下图 ndk { abiFilters 'armeabi-v7a' } splits { abi { enable true reset() include 'armeabi-v7a' universalApk true } } 8.打开app主程序的values文件夹下的strings.xml文件添加代码 &lt;string name=\"game_view_content_description\"&gt;Game view&lt;/string&gt; 9.新建一个布局文件，主布局要包含一个子布局，代码如下 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;RelativeLayout android:id=\"@+id/rl_pet\" android:layout_width=\"200dp\" android:layout_height=\"300dp\" /&gt; &lt;/LinearLayout&gt; 10.打开unityLibrary中的UnityPlayerActivity.java文件，注释一些代码，如下图 类似注释代码段2，将onStop/onStart/onPause/onResume内的mUnityPlayer操作均注释掉 11.新建MUnityActivity.java，代码如下 package com.jk.yuan; import android.content.Intent; import android.net.Uri; import android.os.Bundle; import android.provider.Settings; import android.widget.Toast; import com.unity3d.player.UnityPlayer; import com.unity3d.player.UnityPlayerActivity; public class MUnityActivity extends UnityPlayerActivity &amp;#123; public static UnityPlayer mup; @Override protected void onCreate(Bundle savedInstanceState) &amp;#123; super.onCreate(savedInstanceState); if(mup == null) &amp;#123; mup = mUnityPlayer; &amp;#125; if (!Settings.canDrawOverlays(this)) &amp;#123; Toast.makeText(this, \"当前无权限，请授权\", Toast.LENGTH_SHORT).show(); startActivityForResult(new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:\" + getPackageName())), 1); &amp;#125; else &amp;#123; Toast.makeText(this, \"启动！！！\", Toast.LENGTH_SHORT).show(); startService(new Intent(MUnityActivity.this, UnityService.class)); moveTaskToBack(true); &amp;#125; &amp;#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &amp;#123; if (requestCode == 1) &amp;#123; if (!Settings.canDrawOverlays(this)) &amp;#123; Toast.makeText(this, \"授权失败\", Toast.LENGTH_SHORT).show(); &amp;#125; else &amp;#123; Toast.makeText(this, \"授权成功\", Toast.LENGTH_SHORT).show(); startService(new Intent(MUnityActivity.this, UnityService.class)); moveTaskToBack(true); &amp;#125; &amp;#125; &amp;#125; &amp;#125; 12.新建UnityService.java文件，代码如下 package com.jk.yuan; import android.app.Service; import android.content.Context; import android.content.Intent; import android.graphics.PixelFormat; import android.graphics.Point; import android.os.Build; import android.os.IBinder; import android.provider.Settings; import android.util.DisplayMetrics; import android.view.Gravity; import android.view.LayoutInflater; import android.view.WindowManager; import android.widget.LinearLayout; import android.widget.RelativeLayout; import androidx.annotation.Nullable; import com.unity3d.player.UnityPlayer; public class UnityService extends Service&amp;#123; //要引用的布局文件. LinearLayout touchLayout; //布局参数 WindowManager.LayoutParams params; //实例化的WindowManager. WindowManager windowManager; protected UnityPlayer mUnityPlayer; @Override public void onCreate() &amp;#123; super.onCreate(); &amp;#125; @Nullable @Override public IBinder onBind(Intent intent) &amp;#123; return null; &amp;#125; private void createToucher(UnityPlayer mup) &amp;#123; //赋值WindowManager&amp;LayoutParam. params = new WindowManager.LayoutParams(); windowManager = (WindowManager) getApplication().getSystemService(Context.WINDOW_SERVICE); //根据版本设置type if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &amp;#123; params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY; &amp;#125; else &amp;#123; params.type = WindowManager.LayoutParams.TYPE_PHONE; &amp;#125; //设置效果为背景透明. params.format = PixelFormat.RGBA_8888; //设置透明度 params.alpha = 1.0f; //设置flags.不可聚焦及不可使用按钮对悬浮窗进行操控. params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; //设置窗口初始停靠位置. params.gravity = Gravity.RIGHT | Gravity.BOTTOM; params.x = 0; params.y = 0; Point point = new Point(); windowManager.getDefaultDisplay().getRealSize(point); DisplayMetrics dm = new DisplayMetrics(); windowManager.getDefaultDisplay().getMetrics(dm); int dpi = (int) (dm.density*160); //设置悬浮窗口长宽数据. params.width = 200*(dpi/160); params.height = 300*(dpi/160); LayoutInflater inflater = LayoutInflater.from(getApplication()); //获取浮动窗口视图所在布局. touchLayout = (LinearLayout) inflater.inflate(R.layout.pet_window, null); if (Settings.canDrawOverlays(this)) &amp;#123; //添加toucherlayout windowManager.addView(touchLayout, params); &amp;#125; mUnityPlayer = mup; ((RelativeLayout) touchLayout.findViewById(R.id.rl_pet)).addView(mUnityPlayer); //mUnityPlayer.start(); mUnityPlayer.resume(); &amp;#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &amp;#123; UnityPlayer upa = MUnityActivity.mup; createToucher(upa); mUnityPlayer.windowFocusChanged(true); return super.onStartCommand(intent, flags, startId); &amp;#125; // Quit Unity @Override public void onDestroy () &amp;#123; mUnityPlayer.pause(); //mUnityPlayer.stop(); mUnityPlayer.quit(); super.onDestroy(); &amp;#125; &amp;#125; 13.在app主程序的AndroidManifest.xml文件中配置MUnityActivity.java为主Acitivity，并添加UnityService的声明，代码如下 &lt;activity android:name=\".MUnityActivity\" android:configChanges=\"orientation|keyboardHidden|screenSize\" android:exported=\"true\" android:launchMode=\"singleInstance\" android:theme=\"@style/UnityThemeSelector.Translucent\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=\".UnityService\"&gt;&lt;/service&gt; 14.在运行设置中设置运行选项为MUnityAcitivty，如图所示 14.连接安卓测试机运行即可 原理分析笔者使用Service启动悬浮窗进行开发，但由于屡次尝试失败，只有将官方导出的代码中的UnityPlayer获取使用，将其部分生命周期在Service中执行 参考博客http://t.csdn.cn/KId5Zhttp://t.csdn.cn/mgxWj","path":"2023/07/11/unity-androidstudio-hun-he-kai-fa-an-zhuo-shou-ji-zhuo-mian-chong-wu/","date":"07-11","excerpt":"","tags":[{"name":"Android","slug":"Android","permalink":"https://jia_k3.gitee.io/blog/tags/Android/"},{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"}]},{"title":"考研总规划","text":"考研时间规划一、时间安排 时间 阶段 ~2月 准备 3月~6月 基础 7月~8月 强化 9月~11月 冲刺 12月 查漏补缺 二、不同时期任务1.准备阶段（~2月）确定目标，参考书，不建议买复习资料 英语：单词，优先真题词汇（大纲5500词）真题高频词-&gt;真题低频词-&gt;真题没出现过的词汇-&gt;超纲词 数学：翻书，了解有什么，提前适应学习感觉 2.基础阶段（3月~6月）买书、课、工具，公共课真题（看题型） 英语：单词+语法+阅读解题技巧+10年前阅读真题练习一两周学语法-&gt;长难句练习-&gt;学阅读解题方法-&gt;10年前真题练习 专业课：看书+做笔记+理解全面无死角，不区分重点非重点 数学：视频+辅助刷题 政治：不要动 3.强化阶段（7月~8月） 英语：单词+长难句+10-18年阅读真题练习单词+长难句 不能停–维持到考前重点是阅读、其他题型不用管刷10-18年真题阅读 专业课：划重点考点找真题，按照真题题型和难点划重点，理解+刷题 政治：每天半小时/1小时 数学：刷题 4.冲刺阶段（9月~11月）报考：9月预报名–10月报名–10月底确认 英语：写作-&gt;新题型-&gt;翻译-&gt;完形近3年阅读测试完形填空性价比较低 专业课：背书+刷题+笔记回顾 数学：刷历年真题+模拟题9月下旬刷真题，至少20年按考场进行模拟考试，提前进入考试状态 政治：9月~11月处于正式复习阶段11月前一刷（搞定知识点和习题），之后背选择题12月前选择题，之后分析题10号左右出《肖八》重心转移 5.最终阶段（12月查漏补缺）流程：25号左右初试，提前一周打印准考证 英语：写作练习，笔记回顾，单词长难句不能停 专业课：笔记回顾，重要考点再背背 数学：继续刷模拟题，考场模拟 政治：肖四，重点背分析题，选择题看笔记 三、各科目详细信息1.数学 2.英语 3.政治开始时间推荐7、8月，不要晚于9月必买书籍：肖秀荣精讲精练+1000题11月购买资料：肖四肖八，腿姐、徐涛、米鹏模拟卷推荐资料：红果研思维导图不用买书籍(参考up小思想家)：风中劲草(浓缩版精讲精练)、命题人讲真题(真题推荐小程序)、形势与政策 政治的真题不重要，买书浪费钱，政治出题根据实时政治 网课推荐徐涛强化班 4.专业课书籍：教材+王道\\天勤辅导书+历年真题+王道模拟题(约十月份出)规划：5678月打基础，91011月刷真题，12月分题型针对性练习数据结构-&gt;计算机组成原理-&gt;操作系统-&gt;计算机网络 四、书籍网课推荐1.英语考研词汇 闪过926恋念有词 2.数学高数：武忠祥线代：李永乐概率论：王式安 3.政治肖秀荣精讲精练+1000题肖四肖八，腿姐、徐涛、米鹏模拟卷徐涛强化班","path":"2023/03/05/kao-yan-zong-gui-hua/","date":"03-05","excerpt":"","tags":[{"name":"考研","slug":"考研","permalink":"https://jia_k3.gitee.io/blog/tags/%E8%80%83%E7%A0%94/"}]},{"title":"To The Moon","text":"Sigmund科技公司主打帮助暮年老人实现遗憾愿望，而这次行动的操作员Neil和Eva得知主人公John的梦想是去月球，故事开篇。Neil与Eva使用设备进入John的记忆，折腾半天看到了John与爱人River的夫妻生活，最后历经辛苦获知了John“去月球”这个愿望的由来，由Eva编写记忆实现雇主John的愿望。John有一个孪生兄弟Joey，两人虽有冲突但相处还算融洽。在一次嘉年华上，John逃开人群在山上遇到了River。两个人在山顶一起看星星，River与John在星空中找到了以星星和月亮拼凑出来的兔子座，River说出自己对星星是灯塔的看法，两人更是约定一年后再次相见。不久Joey出车祸，John的母亲为了让John免受悲伤折磨给John服用了大量的阻滞剂，这让他丢失了大量的记忆。在学校里，River与John再次相遇，River却已经发现John不再是以前的男孩。由于River的亚斯伯格症，她不能正确的表达自己的意思，只能将嘉年华那夜John送她的鸭嘴兽玩偶一直带在身边希望有一天可以唤醒John的记忆。后面John与River相知相爱到结婚，期间River通过各种方式来尝试唤醒John的记忆，在生命的最后时刻放弃治疗，并且让John把钱用于灯塔旁边房子的建设，不断折着那晚他们看到的兔子，时不时问John他眼中的兔子。可惜的是，River一直到死也没能看到回想起那晚、那个兔子、那个约定。John用余生思考还是没能搞清楚兔子的含义，只是内心深处萌生出一个奇怪的愿望“去月球”。If you’re with me,then everything’s alright.儿时一面，星空月下承诺再次相见；少年遇见，记忆丢失古怪女孩为何心系魂牵。儿时惊艳，观星成兔临行送我玩偶，此后寒来暑往不论美丑都带在我身边；病重无言，折纸成兔祈求唤你记忆，眠于灯塔旁边你迷路了我带你回来。River：你明年还会再来这里吗？John：当然，你呢？River：那如果你忘记了……或者走丢了呢？John：那么我们总会在月亮上相遇的，傻瓜！……就在小兔子的肚子那里。……John：我为你写了一首曲子。River：这首曲子叫什么名字？John：叫For River。River：真老土。……路人：这是什么奇怪的曲子？只是两个音符一遍又一遍的重复……River：这首曲子叫什么？路人：To The Moon。River：这个名字……真美。……John：我也不知道我为什么要去月球，我只是……非去不可！","path":"2023/02/23/to-the-moon/","date":"02-23","excerpt":"","tags":[{"name":"生活","slug":"生活","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"《全景探秘游戏设计艺术》的礼物","text":"一百个lenslens #1:核心体验要想使用这个lens，需要停止思考游戏，并开始思考玩家的体验。 询问自己如下问题：1.希望玩家获得什么样的体验？2.这种体验的核心是什么？3.游戏是如何捕获这种核心的？ 如果在你希望创造的体验和实际创造的体验之间存在着巨大的差别，需要调整游戏，需要详尽地说明你所渴望的核心体验，并要找出尽可能多的方式将这种核心体验注入到游戏中去。 lens #2:使游戏产生惊喜惊喜是如此平常的一种感觉，我们非常容易将其忽略。使用这个lens来提醒自己，以游戏充满有趣的惊喜。 询问自己如下问题：1.当玩家在玩游戏的时候，什么东西会给他们带来惊喜？2.游戏中的故事拥有制造惊喜的情节吗？游戏规则拥有制造惊喜的能力吗？那么游戏表现能让人惊喜吗？还有技术实现能让人惊喜吗？3.提供给玩家相互制造惊喜的方式了吗？4.提供给玩家为自己制造惊喜的方式了吗？ 惊喜是所有娱乐行为中至关重要的组成部分，它是幽默、策略和问题解决的根源所在。享受惊喜是我们大脑与生俱来的能力。有一个实验，往参与者的嘴中喷甜水或白水，尽管在甜水中都放入了等量的糖，对比被随机喷进甜水和白水的参与者与被固定喷进甜水或白水的参与者所获得的测试体验，前者则认为获得了更愉快的体验。另一个实验中，当人们经历不愉快的惊讶时，人脑扫描的结果显示脑部的快感中枢仍然是被激发的。 lens #3:使游戏有趣尽管“有趣”一词有时需要经过细致推敲，但几乎在每个游戏中都能找到这个词的身影。 为了让游戏中的乐趣最大化，请询问自己如下问题：1.游戏中的什么部分是有趣的？为什么有趣？2.什么部分需要更加有趣？ lens #4:好奇心使用这个lens来思考玩家的真实动机，它不只是游戏所提出的目标，而是玩家想要完成这些目标的原因。 请询问自己如下问题：1.游戏在玩家的脑海中提出了什么问题？2.为了使玩家关心这些问题我都做了什么？3.为了使玩家能够产生出更多的问题我又做了什么？ 例如：一个迷宫调查类的视频游戏可能在每关设有一个时间限制，玩家正视图去回答这个问题：“我能在30秒内找出走出迷宫的出路吗？”一个让他们更关心结果的方式，就是当他们通过了每个迷宫后都播放一段有趣的动画，这样玩家就可能还会问另一个问题：“我想知道下一个动画会是什么？” lens #5:内在价值使用这个lens来思考玩家对于游戏中的物品、物体和得分的感觉。 请询问自己如下问题：1.在游戏中，什么东西对于玩家来说是有价值的？2.如何能让它们更有价值？3.游戏中的价值与玩家的动机之间存在的关系是什么？ 记住，游戏中物品和得分的价值，会直接反映玩家对于游戏中胜利的关心程度有多少。通过思考玩家真正关心的事物和之所以关心的原因，通常就能够了解如何改进游戏了。 lens #6:玩家解决游戏体验中的问题每个游戏都有问题需要去解决，使用这个lens，来思考玩家在游戏中必须成功解决的问题。 请询问自己如下问题：1.游戏叫玩家去解决什么问题呢？2.存在作为游戏性的一部分而产生的隐藏问题吗？3.游戏如何能够产生新的问题来使玩家不断重玩游戏呢？ lens #7:四大元素使用这个lens来评估游戏真正是由什么组成的。首先分别思考每个元素，然后将它们合并起来统一思考。 请询问自己如下问题：1.游戏设计是否使用了四种类型中的全部的元素？2.我的设计能否在一个或更多类别中，通过增加元素来获得改进呢？3.四个元素是否在和谐和相互强化的情况下，同时作用于一个共同的主题呢？ lens #8:全息设计使用这个lens，你必须观察游戏中的每个事物：四大元素和玩家体验，以及它们是如何进行内部联系的。虽然着眼点从皮肤转移到骨骼，再从骨骼转回皮肤是让人满意的观察方法，但是对于游戏和体验进行系统地观察将是更优秀的一种方法。 请询问自己如下问题：1.游戏中的什么元素使得体验有趣？2.游戏中的什么元素削弱了体验？3.如何能够改变游戏元素来提升体验？ lens #9:游戏元素统一使用这个lens，要思考其背后的原因。 请询问自己如下问题：1.我的主题是什么？2.我尽一切努力来强化主题了吗？ “游戏元素统一”能够与“四大元素”很好地配合使用。使用四大元素来划分游戏中的元素，这样你能更轻松地从统一主题的角度来研究它们。 lens #10:共鸣使用共鸣lens，你必须寻找隐藏的力量。 请询问自己如下问题：1.游戏在什么地方让人感觉强有力和特殊呢？2.当向人们描述我的游戏时，什么想法能让他们兴奋呢？3.如果没有任何类型的约束，那么这个游戏会像什么呢？4.对于这个游戏应该拥有什么样的直觉。那么什么驱动着这些直觉呢？ 共鸣lens是一个安静和微妙的工具。它是倾听自己和倾听他人的工具。平时我们将重要的事物深深地埋藏在心底，而当一些事物引起了共鸣时，我们的心灵就会随之震撼。事实上这些事物由于被埋藏在心底而具有能量，但同时也让我们难以找寻。 lens #11:无限灵感当你知道如何去倾听时，每个人都可以成为大师。——朗姆.达斯使用这个lens就要停止寻找其他游戏，并且停止寻找类似你的游戏的游戏。作为新的选择，你要去观察任何其他的地方。 请询问自己如下问题：1.在我的生活中有什么体验我希望与他人一同分享呢？2.采用什么样的简单方式使我能够将这个体验的核心部分放到游戏中呢？ 使用这个lens要求具备一个开放的思维和一个强大的想象力。你需要去寻找感受并观察身边的每样事物。使用这个lens来找到非游戏的体验，那能启发你的游戏。你在四大元素中不同的选择，它们每个都可以被一个独立的灵感所联系起来；或者每一个都可以建立在不同的灵感之上，然后将它们混合在一起，来建立一些全新的事物。当你拥有基于真实生活的具体的远景时，它将指引你进行决策，你的体验将变得空前强大、有力和独特。这个lens可以和lens #1“核心体验”一起使用。使用无限灵感lens来寻找和发现美好的体验，并使用核心体验lens将它们带进你的游戏。 lens #12:问题陈述使用这个lens，将游戏想成解决问题的方案。 请询问自己如下问题：1.我真正试图去解决的是哪个或是哪些问题？2.是否曾经做过一些假设，而这些假设的真实目的却毫无用处呢？3.一个游戏是最好的解决方案吗？为什么？4.如果问题被解决了，我将如何去解释呢？ 以问题陈述的形式为游戏定义约束和目标，这能帮助你快速地找到明确的游戏设计方向。 lens #13:八大过滤器使用这个lens，一定要考虑设计上必须要满足的众多约束。当你的设计能通过这8个过滤器而不再需要修改，那么就可以说你的设计完成了。 请询问自己如下8个关键问题：1.这个游戏感觉上是正确的吗？艺术冲动2.预期的受众足够喜欢这个游戏吗？群体3.这是一个设计良好的游戏吗？体验设计4.这个游戏足够新奇吗？革新5.这个游戏要出售吗？商业和市场6.要制作这个游戏在技术上是否可行？工程技术7.这个游戏遵从了我们社会和社区的目标了吗？社会/社区8.测试人员足够喜欢这个游戏吗？试玩 在有些情况下，可能还会存在更多的过滤器。例如：一个教育类游戏必须回答这样的问题——“这个游戏传授了它所期望的那些东西了吗？”如果你的设计需要更多的过滤器，那就不要忽视它们。 lens #14:风险减缓使用这个lens，停止过分自信的思考，开始认真考量在游戏中引起可怕问题的事物。 请询问自己如下问题：1.什么能阻碍这个游戏编程杰出的游戏？2.如何去避免它的发生？ 风险管理是艰难的。它意味着必须去面对大多数你都能避免的问题，并迅速地解决它们。但如果你训练自己去做这件事的话，你会循环更多的次数，而且每次循环更为有用，并最终得到一款更棒的游戏。忽略潜在的问题和仅仅工作在游戏中你最有自信的部分，这是相当有诱惑力的。你必须抵御这种诱惑，并注意你游戏中存在危险的部分。 lens #15:玩具使用这个lens，要停止思考你的游戏是否玩起来有趣的问题，而是开始思考你的游戏是否具有吸引力让我们去玩的问题。 请询问自己如下问题：1.如果游戏没有目标，那么它会有趣吗？如果没有趣，那如何能改变它呢？2.当人们看到我设计的游戏时，甚至在他们不了解这个游戏之前，就想要开始玩它吗？如果不会，那如何能改变它呢？ 这里有两种使用玩具的方式。第一种方式是在一个已有的游戏中使用它，来指出如何往游戏中添加更多的玩具特质。也就是说，如何让游戏更加亲切，以及如何让游戏拥有更多的操作乐趣。但是这第二种方式却是一种勇敢的方法，那就是在对于使用这些玩具来制作什么样的游戏还没有任何想法时，就先发明和创建新的玩具。如果你的时间紧张，这样的做法将会有很大的风险。但如果你的时间不是那么紧张，这个方法会是一个优秀的“占卜棒”，它能帮你找到你可能并不会发现的极棒的游戏。 lens #16:玩家使用这个lens，要停止思考游戏，开始思考玩家。 那些人们会玩你的游戏，请询问自己如下问题：1.一般来说，他们喜欢什么？2.他们不喜欢什么？为什么不喜欢？3.他们希望在游戏中看到什么？4.如果我站在他们的位置上，我会希望在游戏中看到什么？5.他们特别喜欢或者特别讨厌我游戏中的什么东西？ 一名优秀的游戏设计师应当经常思考玩家，并且应当成为玩家们的拥护者。有经验的设计师会在手中同时握住“玩家”和“全息设计”，并一同思考他们的玩家、思考游戏的体验、思考游戏的机制。思考你的玩家是一种有用的方法，但更加有效的是观察他们玩你的游戏。越多观察他们进行游戏，就会越容易去预知他们所喜爱的东西。 lens #17:乐趣使用这个lens，思考游戏所提供的和未提供的乐趣。 请询问自己如下问题：1.游戏会给玩家带来什么乐趣？这些乐趣可以被提升吗？2.你的体验中缺失了什么乐趣？为什么会缺失呢？它们能够被加进来吗？ 说到最后，游戏的工作就是给予乐趣。通过检查这些已知的乐趣列表和思考游戏如何来传达每种乐趣，你可能会从中得到灵感，并改进游戏。注意，对于在大多数游戏中未出现过的那些特殊和未被归类的乐趣，它们中的某一个可能就会带给你的游戏所需的与众不同的特质。 lens #18:沉浸使用这个lens，思考什么东西能够使玩家保持专注。 请询问自己如下问题：1.游戏拥有清晰的目标吗？如果没有，如何在这方面改进？2.玩家的目标与我预期的目标一致吗？3.游戏中有没有分散玩家注意力的部分，使其忘记了他们的目标？如果存在，这些部分能否被去掉或修改以使其与游戏的目标保持一致呢？4.游戏是否提供了一种稳定的难度曲线，给予玩家不是太简单，也不是太困难的挑战，并且顾及了玩家技能可能会逐渐提升的现实呢？5.玩家的技能水平是否如我希望的速度在提升？如果没有，又如何改进呢？ lens #19:需求使用这个lens，要先停止思考游戏，思考游戏满足了人们什么根本需求。 请询问自己如下问题：1.游戏工作在马斯洛层次模型中的哪个层次呢？2.如何能让游戏比现在满足更多的根本需求呢？3.在游戏目前所工作的层次之上，它如何能够更好地满足那些需求呢？ 谈论一个满足人们基本需求的游戏这听起来很奇怪，但人们所做的每一件事都是试图以某些方式来满足这些需求。不要忘记，有些游戏能够比其他东西更好地满足需求，你的游戏不能只是承诺需求，它必须传达出需求的满足感。 lens #20:评价 要判断游戏是否给了玩家们很好评价，请询问自己如下问题：1.游戏都评价玩家的什么东西？2.这种评价是如何交流的？3.玩家对于评价是否感觉公平？4.他们在乎这种评价吗？5.这种评价能否使得玩家想要提升呢？ lens #21:功能空间使用这个lens来思考游戏在剥离了所有表面元素之后真正所处的空间。 请询问自己如下问题：1.这个游戏的空间是离散的还是连续的？2.游戏拥有多少个维度？3.空间的边界是什么？4.游戏存在子空间吗？子空间是如何连接的呢？5.对于这个游戏的空间来说，存在着多种有用的抽象建模方式吗？ lens #22:动态状态使用这个lens来思考游戏的过程中所改变的信息，以及谁会看到这些信息。 请询问自己如下问题：1.游戏中的对象都是什么？2.这些对象的属性都是什么？3.每个属性可能的状态都是什么？每个属性状态的改变都是由什么来驱动的？4.什么状态是只有游戏本身才知道的？5.什么状态是所有玩家都知道的？6.什么状态是只有一些或一个玩家知道的？7.改变知道状态的人或所知的状态会在某些方面提升游戏吗？ 玩游戏就是制订决策的过程，决策的制订是基于信息的。你所决定的不同属性和这些属性的状态，以及谁会知道这些属性，就是游戏机制的核心。在信息的知情者和所知的信息上稍加改变就能彻底地改变一个游戏，有时会做得更好，但有时会做得更差。有谁知道什么属性能够改变游戏的进程——在你的游戏中一个创造兴奋点的绝佳方法，就是使私有信息的一个重要部分突然暴露出来，使其变为共有信息。 lens #23:自发性 为确保游戏中拥有有趣的自发性品质，请询问自己如下问题：1.玩家拥有多少个动词？2.每个动词可以与多少对象交互？3.玩家拥有多少种方式来实现目标？4.玩家拥有多少种动机？5.边际效应是如何来改变约束的？ lens #24:行为使用这个lens来思考玩家能够做什么和不能做什么及之所以这样的原因。 请询问自己如下问题：1.游戏中的操作行为是什么？结果行为是什么？2.希望看到什么样的结果行为？如何能改变游戏来使得那些结果行为变得可行？3.对于结果行为与操作行为的比例感到满意吗？4.有什么样的行为是玩家希望在游戏中拥有的但却没有提供的？能在操作行为或结果行为的某种程度上实现这些希望吗？ 一款没有行为的游戏就像一行没有动词的句子，什么也不会发生。作为一名游戏设计师，最基本的决定就是确定游戏中的行为。对于这些行为极其细微的修改都将会带来巨大的连锁效应，这些连锁效应作用在游戏中的结果，要么就是创建出非凡的自发游戏性，要么就是制作一款没有任何期待的乏味游戏。小心选择你的行为，并且学会倾听游戏和玩家，以此来了解你的决定究竟使什么变为了可能。 lens #25:目标 为了确保游戏的目标是恰当和平衡良好的 ，请询问自己如下问题：1.游戏的最终目标是什么？2.这个最终目标清晰地展现给玩家了吗？3.是否存在一系列目标，玩家们理解吗？4.不同的目标是否以有意义的方式相互关联？5.这些目标具体、可达到和有奖励吗？6.对短期和长期目标进行了很好的平衡吗？7.玩家们有机会决定他们自己的目标吗？ lens #26:规则 要想使用这个lens来深入洞悉游戏，直到你能了解其最根本的结构，就请询问自己如下问题：1.游戏最根本的规则是什么？这些规则与操作规则有何异同？2.伴随着游戏的发展，是否形成了一些“法规”或“内部规则”呢？这些规则是否应该被直接整合到游戏之中呢？3.在游戏中有不同的模式吗？这些模式让事情变得更简单还是更复杂？如果使用更少的模式会让游戏变得更好吗？那如果使用更多的模式又有怎样呢？4.谁来执行游戏中的规则？5.这些规则易于理解吗，或者它们会让玩家困惑吗？如果规则会产生困惑，为了解决这个问题，应该改变规则还是应该将规则表达得更清晰呢？ 有一种广泛的误解——设计师只是坐着写出一套规则来制作游戏的。但这种形容完全不是真实的情况。一款游戏的众多规则是通过逐步地试验进而得出的。设计师的思考大多集中在“操作规则”的范围，但当思考如何来改变或提升游戏时，偶尔会转移到“基本规则”的范围。“书面规则”的制定过程通常都会从游戏可玩直至游戏最终完成。设计师的部分工作之一就是确保这些规则能够覆盖所有的情况，并要切实、仔细地记录试玩的结果，因为在这些测试过程中，你的规则中的漏洞将会显露出来，如果只是快速地修补规则而并不进行记录的话，同样的漏洞还将会再次出现。游戏就是规则，你需要给予这些规则应得的时间的照料。 lens #27:技能要想使用该lens，请先停止审视游戏本身，开始审视要求玩家所要掌握的技能。 请询问自己如下问题：1.游戏都要求玩家掌握什么技能？2.游戏中是不是缺乏某些技能类型？3.哪些技能是主要技能？4.这些技能可以创造出我所希望的游戏体验吗？5.是否有些玩家对于这些技能的掌握会明显好过其他玩家？这会使游戏感觉不公平吗？6.玩家能否通过练习来提升他们的技能水平？7.这款游戏是否需要某种程度的技能水平？ 对于技能的练习是一件充满乐趣的事情，这是人们喜爱游戏的原因之一。当然了，只有技能是有趣的和能够得到回报的，并且只有在挑战的等级在“太简单”和“太难”之间，这样的技能练习才会让人感到快乐。甚至是一些无聊的技能(就像按动作键)，都能通过将其转变为虚拟技能并加以适当的挑战来产生更多的乐趣。将这个lens作为通往玩家体验的窗口来使用。因为技能在相当大的程度上决定了体验，所以lens#27“技能”与lens#1“核心体验”可以很好地结合起来使用。 lens #28:期望值使用该lens，请思考在游戏中不同事件的发生几率，以及这些几率对于玩家意味着什么。 请询问自己如下问题：1.某个事件的实际发生几率是多少？2.感知的几率又是多少？3.那个事件拥有什么样的结果值？这个值能够被量化吗？我们是否没有认识到这个值的某些潜在方面呢？4.当我们相加所有的可能结果时，玩家所拥有的每种行为都具有不同的期望值。我对于这些值感到满足吗？这些期望值感到满意吗？这些期望值给玩家带来有趣的选择了吗？这些值是否给玩家过于丰厚的奖励，或对于严厉的惩罚呢？ 期望值是用来分析游戏平衡性的最有价值的工具之一。使用期望值分析的挑战在于，要找到一种方式来量化发生在玩家身上的各种表现。获得和失去金钱是非常容易表现的。但一个让你跑得更快的“速度之靴”的量化值是多少，或可以让你跳过两关的“传送门”的量化值又是多少呢？它们确实很难被量化好，但那并不意味着你不能进行猜想。当你经历了多次游戏测试、参数和数值调整的迭代后，你同样也会对不同结果的估计值进行调整。这些潜在元素的量化过程能让你产生巨大的启迪，因为这个过程会让你正确地思考对玩家有价值的东西，以及它们之所以有价值的原因。这种切实的知识将会推动你进行游戏平衡性的控制。 lens #29:概率使用该lens，要将焦点集中在包含了随机因素和风险因素的部分上，并谨记这两种事物是存在差异的。 请询问自己如下问题：1.游戏中那些部分是真正随机的？又有那些部分只是让人感觉是随机的？2.这些随机的部分是给玩家带来了兴奋和挑战的积极体验，还是产生了失望和难以控制的消极感受呢？3.通过调整概率分布曲线能否提升游戏？4.在游戏中玩家是否为了有趣体验而承受风险？5.在游戏中，几率和技能之间的联系是什么？是否存在多种方式让原本随机的元素使玩家感到更像是技能的练习？是否拥有多种方式让技能的练习更像是在承受风险？ 风险和随机很像调料。一款没有任何调料的游戏会变得完全乏味，倘若添加得过多又会盖住其他东西。适量的使用，它们会使游戏中的其他元素渗透出鲜美的滋味。但不幸的是，在游戏中使用它们可不是将它们洒在表面那么简单。你必须洞穿你游戏中自然显现的那些有风险和随机的元素，然后决定如何能最好地调和它们以达到你的要求。不要调入陷阱之中，认为几率元素只能出现在像掷骰子这样的游戏中，或几率元素只能生成数字。恰恰相反，你能够在任何玩家所遇到的未知事物中找到它们。 lens #30:公平使用公平lens去站在每名玩家的角度谨慎地思考游戏。考量每名玩家的技能水平，找出一种方式来让每名玩家都有获胜的机会，并让其相信游戏是公平的。 请询问自己如下问题：1.游戏应该是对称的吗？为什么？2.游戏应该是非对称的吗？为什么？3.最重要的是：游戏是拥有最佳技能玩家的可信标尺吗，或游戏是否为所有玩家都提供了有趣的挑战呢？4.如果希望拥有不同技能水平的玩家能够同场竞技，那意味着让游戏对每个人来说都是有趣和充满挑战的的吗？ 公平性是一个棘手的课题。有些情况下，一边虽然拥有超过另一边的优势，但游戏看上去仍然公平。有些情况下，甚至拥有不对等技能的玩家们却能玩到一起，而这就是另一个问题了。例如，在游戏《异形大战铁血战士》中，一般都会认为在多人模式下，铁血战士所拥有的优势明显超过异形。尽管如此，但玩家们却不认为这不公平，因为游戏忠实于《异形大战铁血战士》的故事世界，同时玩家们能接受他们扮演外星人，他们认为自己虽然处于不利的局面，但是可以使用特殊的技能来弥补。在玩家中的一个象征就是能用外星人来赢得游戏。 lens #31:挑战挑战几乎是所有游戏性的核心，甚至能够说一款游戏就是由目标和挑战来定义的。 当检查游戏中的挑战时，请询问自己如下问题：1.游戏中的挑战是什么？2.这些挑战的难度是太过容易还是太过困难，或者是正合适呢？3.我的挑战能够适合大量不同的技能水平吗？4.挑战的等级如何随着玩家的不断胜利而有所提生呢？5.挑战拥有足够的多样性吗？6.游戏中最终的挑战是什么？ lens #32:有意义的选择当我们进行有意义的选择时，选择与我们紧密相连的事物。 使用这个lens，询问自己如下问题：1.我让玩家都进行什么样的选择呢？2.这些选择有意义吗？如何体现其意义的？3.为玩家提供了合适数量的选择了吗？更多的选择会让玩家感到更强大吗？更少的选择会让游戏更加清晰吗？4.游戏中有优势策略吗？ lens #33:犄角之势为玩家提供选择，让他们可以小心谨慎地获得有限的回报或是冒险取得丰厚的奖励，这种做法会让游戏变得有趣和刺激。 使用犄角之势，询问自己如下问题：1.我的游戏有犄角之势吗？如果没有，如何能获得它呢？2.所尝试的犄角之势平衡了吗？就是说，回报与风险相称吗？ 一旦开始在游戏中寻找犄角之势时，你会在任何地方见到它们。当在游戏中加入一点犄角之势，一款无趣和单调的游戏就能迅速变成刺激和有价值的游戏。 lens #34:技能和几率 为了帮助确定如何平衡游戏中的技能和几率，请询问自己如下问题：1.玩家更喜欢判断（技能），还是更喜欢承担风险（几率）？2.技能比几率更加重要：我的游戏是严肃的还是休闲的？3.游戏是否有些部分是单调乏味的呢？如果真的是那样，添加一些几率元素是否能让这些部分变得活跃起来？4.游戏是否有些部分让人感到过于随机呢？如果真是这样，使用技能或策略元素来替换几率元素是否能让玩家拥有更多的控制感呢？ lens #35:动脑与动手约吉.贝拉曾经说过“棒球有90%靠脑力，而剩下的才靠体力。”为了确保游戏拥有更加现实的脑力和体力元素的平衡，请使用动脑与动手lens。 请询问自己如下问题：1.玩家是否在寻找不假思索的行为，或是理智的挑战呢？2.在游戏中添加更多包含解谜要素的地方是否会让游戏更加有趣呢？3.是否有地方让玩家能够放松他们的大脑，并不假思索地进行游戏呢？4.我能为玩家提供一种选择——让玩家获得成功的方式，既可以是通过练习高水平的敏捷技能，又可以是只要最小化动手能力的聪明策略吗？5.如果“1”代表完全动手，而“10”代表完全动脑的话，我的游戏会是数字几呢？ 这条lens当与lens #16“玩家”混合使用时，其效果尤佳。 lens #36:对抗确定谁在某些方面的技能是最棒的是人类的一种本能的冲动。对抗类游戏能够满足这样的冲动。使用这条lens来确保对抗游戏让人们想要获得胜利。 请询问自己如下问题：1.游戏是否为玩家的技能提供了公平的尺度？2.人们想要赢得我的游戏吗？为什么？3.人们会由于战胜了游戏中的某些东西而感到自豪吗？为什么？4.在游戏中新手能否具有对抗的意义？5.在游戏中高手能否具有对抗的意义？6.高手能否大致确信他们会击败新手呢？ lens #37:协作一个团队获得成功是非常快乐的，这种快乐会建立持续的社会关系。使用这条lens来学习游戏中的协作方面。 请询问自己如下问题：1.协作需要沟通。玩家是否有足够的时机去进行沟通呢？如何来促进沟通呢？2.玩家们已经是朋友还是陌生人？如果他们是陌生人，我能帮他们打破沉默吗？3.当玩家们一同游戏时，是否有增效作用或对抗作用呢？为什么？4.所有的玩家们都有相同的角色吗，或者它们拥有特殊的工作吗？5.当一个个体不能够独自完成任务时，协作就被极大地强大了。我的游戏拥有像那样的任务吗？6.任务会强迫沟通并激发协作。我有强迫沟通的任务吗？ lens #38:对抗与协作平衡对抗与协作能够能够用很多有趣的方法来完成。使用这条lens来判断它们在你的游戏中是否被正确的平衡了。 请询问自己如下问题：1.如果“1”是对抗而“10”是协作，那么我的游戏应该是什么数字？2.能否提供给玩家一种选择，让他们决定是否以协作或对抗的方式进行游戏？3.我的受众更喜欢对抗、协作还是两者的混合呢？4.团队对抗对于游戏具有某些意义吗？我的游戏是在团队对抗中更有趣味，还是在单人对抗中更有趣味呢？ lens #39:时间都说“时间就是一切。”作为设计师的目标就是创造体验，而体验却容易被时间过短或时间过长所毁掉。 请询问自己如下问题来让游戏的长度恰到好处：1.什么决定了游戏活动的时间长短？2.玩家们会因为游戏结束得太早而感到失落吗？如何能改变这种状况呢？3.玩家们会因为游戏进行得时间过长而感到厌烦吗？如何能改变这种状况呢？4.设置时间限制能让游戏性更加刺激。但这对于我的游戏来说是一个好方法吗？5.时间层次结构能够给游戏带来帮助吗？就是说，几个简短的回合一同构成一个较大的回合能够给游戏带来帮助吗？ 游戏时间是很难正确把握的，但它却能成就或毁掉一款游戏。 lens #40:奖励每个人都喜欢被告知表现很好。 请询问自己如下问题来确定游戏是否在正确的时机按合适的数量给了玩家正确的奖励：1.游戏现在给予的是什么样的奖励呢？游戏还能给予其他不错的奖励吗？2.当玩家们在游戏中获得奖励时，这些奖励是让他们兴奋还是让他们厌烦？为什么？3.获得一个你根本就不理解的奖励就好像没有获得任何奖励一样。玩家们是否理解他们所获得的奖励呢？4.游戏中的奖励是否给予的过于有规律？这些奖励能否以更多的方式呈现呢？5.奖励之间如何相互联系？是否有一种方式让它们能建立更好的联系呢？6.我的奖励完成的如何？太快、太慢还是刚刚好？ 对于奖励的平衡在每个游戏中都有不同。设计师不应该只是关注给予正确的奖励，同时还要关注在合适的时机，给予恰当数量的奖励。要达到很好的效果，只能通过不断地摸索。即使是这样，同样的奖励也不会适合每个人。当你尝试平衡奖励时，很难做到完美，你时常必须对“足够好”感到满意。 lens #41:惩罚惩罚一定要微妙地进行使用，因为毕竟玩家在游戏中拥有自己的意图。很好平衡的结果会让游戏中的每样事物都更具意义，而当玩家在游戏中获得成功时，也会拥有真正感到自豪的理由。 为了检验游戏中的惩罚，请询问自己如下问题：1.我的游戏中都有哪些惩罚？2.为什么要惩罚玩家？希望借此达到什么目的？3.对于玩家的惩罚看上去公平吗？为什么公平或为什么不公平？4.是否存在某种方式使得这些惩罚可以被转换成奖励，但同时又获得了同样的或是更好的效果？5.严厉的惩罚与丰厚的奖励是否平衡呢？ lens #42:简单性/复杂性要在简单性和复杂性之间取得平衡是很困难的，而还必须拥有正确的理由。使用这条lens来帮你将游戏从一个简单的系统中衍生出具有意义的复杂性。 请询问自己如下问题：1.在游戏中拥有什么样的固有复杂性元素？2.是否有方法能让这种固有复杂性转变为突发复杂性呢？3.游戏产生出了突发复杂性元素吗？如果没有，为什么呢？4.游戏中的元素是否过于简单呢？ lens #43:优雅多数“经典游戏”都被认为是优雅的杰作。使用这条lens来使游戏尽可能优雅。 请询问自己如下问题：1.我的游戏都有那些元素？2.每个元素的目的都是什么？计算这些目的的数量，并给出每个元素的“优雅评分”。3.对于那些只拥有一个或两个目的的元素，能否将这些元素相互合并，或干脆全部去掉呢？4.对于那些拥有多个目的的元素，它们还是否可能拥有更多的目的呢？ lens #44:个性优雅和个性是两个对立的层面。它们都好像缩小版的简单性与复杂性一样，而且必须加以平衡。 为了确保游戏拥有可爱的定义，请询问自己如下问题：1.在游戏中是否有哪些事物让玩家谈论起来激动不已？2.游戏是否拥有让其独树一帜的有趣格调呢？3.游戏中是否存在玩家喜爱的瑕疵呢？ lens #45:想象力所有的游戏都拥有一些想象力元素及一些与现实关联的元素。使用这条lens来帮助你找到平衡细节和想象力的方法。 请询问自己如下问题：1.玩家要玩游戏所必须理解的事物是什么？2.一些想象力元素能够帮助他们更好的理解吗？3.能够在游戏中提供哪些高质量的真实细节？4.所提供的哪些细节会以低质量呈现给玩家？玩家的想象力能否填充这些缺口呢？5.所提供的细节能否被想象力多次使用？6.所提供的哪些细节能够激发想象力？7.所提供的哪些细节会抑制想象力？ lens #46:经济将经济引入游戏能够为其带来惊人的深度和属于它自己的生命。但就像一切有生命的物体一样，它很难被控制。 使用这条lens来确保你的经济保持平衡：1.玩家如何赚取金钱？还有其他的方式吗？2.玩家可以购买什么？为什么？3.金钱是否得到的过于容易？还是过于困难？如何来改变这种状态？4.赚取和消费是有意义的选择吗？5.通用货币在我的游戏中是一个好主意吗，或者应该使用特殊货币？ lens #47:平衡游戏平衡包含了很多的类型，而每种类型都是重要的。尽管如此，仍然会漏掉某些细节和忘记全景图。 使用这条简单的lens来走出泥潭，并只询问自己唯一重要的问题：游戏感觉上正确吗？为什么正确或为什么不正确？ lens #48:可用性 当把一个谜题展现给玩家时，请问自己如下问题：1.玩家是否知道怎么解决问题或者玩游戏？我是否需要解释这一点，还是不言自明的？2.谜题和游戏的行为接近他们以前看到过的事物吗？如果接近，怎样才能把玩家的注意力吸引到这个相似点上？如果不接近，怎样才能让玩家明白它是怎么工作的？3.我的谜题或者游戏能吸引人过来，并使他们想接触和操作游戏吗？如果不能，怎样才能改变这一点？ lens #49:可见的进展玩家们在解决困难时，需要看到他们的进展。 为了确保他们得到这个反馈，问自己这些问题：1.游戏或者谜题里有进展是什么意思吗？2.在游戏里有足够的进展吗？有没有什么办法增加更多进展的步骤？3.什么进展是可见的？什么进展是不可见的？我能找到揭示不可见进展的办法吗？ lens #50:平行谜题里的平行法给玩家的体验带来平行的好处。 为了使用这个lens，请问自己如下问题：1.设计中有什么瓶颈是玩家不能解决某个挑战就无法继续的？如果有，怎么才能为玩家在受阻时增加另一个平行的挑战。2.如果这些平行的挑战都是类似的，平行法就提供不了什么好处。而平行的挑战之间是否有足够的差别来给玩家带来多样性？3.平行的挑战是某种程度上相互联系的吗？当解决一个问题时能对解决另一个问题有帮助吗？ lens #51:金字塔金字塔因为它们的高高的顶点吸引着我们。 为了让你的谜题具备古老金字塔的吸引力，请问自己如下问题：1.有没有办法让谜题的各个组件最后成为一个最终的单一的挑战？2.大的金字塔通常是由小的金字塔组成的——我能够做出一个由更加富有挑战性的谜题组成的体系吗？这个体系最后产生一个最终的谜题？3.金字塔顶端的挑战是否有趣，有吸引力，足够清晰？它是否让人们想去解开它？ lens #52:谜题谜题让玩家们停下来思考。 为了让谜题像你想的那样促成玩家的体验，请问自己如下问题：1.游戏中的谜题是什么？2.游戏中应该有更多的谜题或者更少的谜题？为什么？3.10条谜题原则都有哪些应用于我的谜题了？4.游戏中有古怪的谜题吗？怎样才能把它们更好地集成到游戏里？(使用lens #43“优雅”) lens #53:控制这条lens不仅仅可以用于测试你的界面设计，因为有意义的操控是让玩家高度沉浸在人机交互里。 在使用这条lens之前，请自问以下几个问题：1.当玩家使用这些界面时，它是否提供了玩家期望的功能？如果没有，为什么？2.直观的界面更易于提供操控感。你的界面掌握起来是难，还是容易？3.玩家感觉他可以对游戏结果产生重要影响了吗？如果没有，你打算如何改变它？4.强大的自我感觉=良好的操控感，你的玩家感觉到自身的强大了吗？你能通过某种方法让他们感到更强大吗？ lens #54:物理接口从某种角度上来说，玩家和游戏之间存在物理上的交互。照搬其他已有的物理接口设计很容易落入陷阱。 使用这条lens可以确保物理接口设计得非常适合你自己的游戏，你需要回答如下几个问题：1.玩家需要看到什么或是触摸到什么？有办法把这个交互做得更有趣吗？2.物理接口如何映射到游戏世界中的行为？这个映射关系是否可以更加直接？3.如果你不能创造一套自定义的物理接口，当你需要映射物理输入设备到游戏世界时，你打算用什么样的例子？4.如果想要像“玩具一样”去设计物理接口，那么物理接口看起来如何？5.玩家如何看、听、感触游戏世界？有没有办法使用一种物理输出设备使玩家想象中的游戏世界更加真实？ 在视频游戏的世界里，有时设计师会觉得灵感枯竭，他们觉得不太可能创造一种新的自定义物理输入设备。但是市场总会因为实验产品、新奇事物或是突然出现的特殊设计的游戏物理输入设备而茁壮成长。比如，Dance Dance Revolution里的跳舞毯、Guitar Hero里的吉他，以及任天堂的wii手柄Wiimote的出现，给予旧玩法新生命，它给予了玩家一个“与传统游戏机制交互的新途径”。 lens #55:游戏界面设计游戏界面的设计很有技巧。如果设计得不好，它将成为游戏世界和玩家之间的障碍。如果设计得好，它会极大地增强玩家在游戏世界里的力量感和操控感。 为了确保你的界面设计正在尽可能地增强玩家的体验，你需要回答如下几个问题：1.什么信息是玩家需要得到，并且只需要不经意间看一眼游戏世界就可以知道的？2.玩家什么时候需要这个信息？任何时候吗？还是只是偶尔？或是只是在关卡结束的时候？3.这些信息如何传递给玩家，并且不会妨碍玩家与游戏世界的交互？4.游戏世界里是否有一些元素，以菜单的形式（比如一个弹出菜单）交互会比直接跟它们交互更方便些？5.什么样的游戏界面最适合我的物理接口？比如说弹出窗口对于一个基于游戏手柄控制的游戏来说就不是一个好主意。 lens #56:透明最理想的游戏界面的设计，就是让界面不可见。这样会让玩家的想象力完全沉浸在游戏世界当中。 为了能够尽量透明，请自问以下几个问题：1.玩家想要什么？游戏界面中有让玩家做他们想做的事情吗？2.界面是否足够简单，能够让玩家通过一些练习，就可以不用思考就能使用它？3.新玩家是否觉得界面很直观？如果不是，能把界面做得更加直观一点吗？允许玩家自定义操控是有利还是有害？4.是否在所有情况下界面都能很好地工作？在某些情况下(靠近角落、快速移动等)界面是否会干扰玩家？5.玩家是否能在有压力的情况下仍然继续使用该界面？还是说他们开始在操作上犯错误，或者错过关键的信息？如果是这样，如何改进界面的设计？6.是否有一些东西使玩家对于界面的理解产生迷惑？ lens #57:反馈玩家从游戏里得到的反馈包括很多方面，比如，裁决、奖励、说明、鼓励和挑战。 使用这条lens可以保证你的反馈循环正在创造你期望的体验，在你的游戏里随时问自己如下几个问题：1.玩家此时需要知道什么？2.玩家此时想要知道什么？3.此时你希望玩家感受到什么？你给予什么样的反馈来创造这种感受？4.玩家此时希望感受到什么？对他们来说，是否有机会为了玩家来创造一种这样的场合，让玩家体验到他期望的感受？5.玩家此时的目标是什么？什么样的反馈可以帮助他们到达这个目标？ 游戏里的反馈是持续性的，因此使用这条lens会起到一定的作用，但是别忘了随机应变。在游戏里经常使用这条lens会对玩家的精神支持有很大的帮助，因为这条lens可以保证游戏让人理解起来非常清除，富有挑战性。 lens #58:“多汁”反馈将接口称之为“多汁的”或许看起来有点傻，但是经常会听到人们将反馈非常少的接口设计称之为“干巴巴的”。多汁奖励的接口设计，一旦你学会它就会觉得很好玩。 为了最大化“多汁”，请自问以下几个问题：1.针对玩家的这种动作，我的接口是否有持续不断地给玩家反馈？如果没有，为什么不呢？2.玩家的动作产生了二级动作吗？如果有，那么二级动作是否有趣并是有力的？3.多汁的系统会同时从很多方面奖励玩家，当我给玩家一个奖励时，有多少种方法同时奖励玩家？我能找到更多的方法吗？ lens #59:通道和属性的妙方设计游戏界面的核心，就是选择如何将游戏信息映射到各种各样的通道和属性上。使用这个lens可以确保你的界面设计周全并且优秀。 请自问以下几个问题：1.什么样的数据需要传递给玩家或是由玩家传递给系统？2.哪些数据是最重要的？3.我有哪些可用的通道来传输这些数据？4.对于某些数据来说，哪些通道是最合适的？为什么？5.对于不同的通道来说，哪些属性是可用的？6.我该如何使用那些属性？ lens #60:模式任何复杂的事物，其接口都需要模式。 为了确保你的模式能够让玩家感到权威性和可控性，并且不会产生疑惑或是受到打击，请自问以下几个问题：1.我的游戏需要什么样的模式？为什么？2.哪些模式可以被分解或是被合并？3.是否有模式重叠了？如果是这样，我能将这些模式放在不同的输入通道上吗？4.当游戏改变模式时，玩家如何知道？游戏能否通过多种方式来和“模式切换”交流？ lens #61:兴趣曲线对每个人来说人类的思维是多么让人捉摸不透啊，但是对每个人来说最令人舒畅的魅力模式都是简单并且引人注目的。 想看看在游戏体验中玩家的兴趣是如何变化的，请自问以下几个问题：1.我是否有绘制一个体验的兴趣曲线，它看起来是什么样的？2.曲线有“钩子”吗？3.曲线是否有逐渐上升，并且时不时会有休息的部分？4.是否有一个爆炸性的压轴戏，比之前任何时候都要有趣？5.改变什么地方可以给我一条更好的兴趣曲线？6.兴趣曲线里是否有分形结构？这个结果是否应该存在？7.我对兴趣曲线的直觉是否和玩家兴趣吻合？如何要求玩家来画一条兴趣曲线，它看起来会是什么样子？8.因为每个玩家都不一样，你可能会发现将“兴趣曲线”和lens16“玩家”同时使用会非常有用，要试着为游戏的每一个类型的玩家创造一种独一无二的兴趣曲线。 lens #62:与生俱来的兴趣使用这条lens可以保证游戏拥有与生俱来的有趣质量。 请自问以下几个问题：1.游戏什么方面会立即抓住玩家的兴趣？2.游戏是否有让玩家看到或是做一些他们从没有看到或是做过的事情？3.游戏对什么基本直觉有吸引力？能够更有吸引力一些吗？4.游戏对什么高级直觉有吸引力？能够更有吸引力一些吗？5.游戏里有戏剧性的变化或是预期的戏剧性变化发生吗？如何才能够更有戏剧性？ lens #63:美丽我们热爱体验美丽的事物。 请自问如下几个问题来使游戏成为永远的玩具：1.游戏是由什么组成的？如何能够使每个东西看起来更美？2.有些东西本身并不美，但是组合在一起就很美。在游戏中的那些元素如何才能组织在一起，使它们充满诗意与魅力？3.在游戏里美丽意味着什么呢？ lens #64:代入感显示某人正在享受体验的关键指标之一是他们将自己的想象力融入其中。当他们这么做的时候，体验带给他们的感受会以一种良性循环的方式快速增加。 为了检验你的游戏是否很适合包含用户的代入感，请自问以下几个问题：1.在游戏里有什么是和玩家有关的？还能加入什么？2.在游戏里有什么东西是可以抓住玩家的想象力的？还能加入什么？3.游戏里是否存在一些玩家总想去的地方？4.玩家是否能成为他们想象的那个人？5.游戏里是否存在一些角色是玩家很感兴趣去见的？（或者去监视他？）6.玩家是否有机会去做一些他们在真实世界里想做又不能做的事情？7.游戏里是否有一些活动是玩家一旦开始就很难停下来的？ lens #65:故事制造机一个好的游戏是一个故事制造机，当玩家在玩的时候能够创造出故事。 为了确保你的故事制造机是尽可能多的，请询问以下几个问题：1.当玩家对完成目标拥有多个不同的选择时，新的和不同的故事才能够浮现出来。我如何添加更多的选择？2.不同的冲突引发不同的故事。如何能让更多的冲突类型从游戏中产生出来？3.当玩家能够个性化角色和设定时，他们会更关心故事的结果，并且在面对类似的故事时会感觉到不同。如何能驱动玩家将故事个性化？4.好的故事拥有好的兴趣曲线。我的规则能产生拥有良好兴趣曲线的故事吗？5.能够讲给别人听的故事才是好故事。你真正关心了玩家会把故事讲给那些人听吗？ lens #66:障碍没有障碍的目标是不值得追求的。 使用这个lens来确保你的挑战是玩家希望去征服的：1.主角和目标之间的关系是什么？为什么主角在意这个目标？2.角色和目标间的障碍是什么？3.在障碍的背后是否存在对手？主角和对手之间是什么关系？4.障碍的难度是否在逐步提升？5.有人说“障碍越大，故事越棒！”你的障碍够大吗？它们还能更大吗？6.伟大的故事常常包含主角的转变，用以克服障碍。你的主角如何转变？ lens #67:简单感和卓越感lens 为了确保正确融合简单感和卓越感，请自问以下几个问题：1.我创造的世界是如何比现实世界简单的？它还能以其他的方式再简单点吗？2.给了玩家什么样的卓越能力？如何能在不降低挑战难度的前提下，给玩家更多的能力。3.我的简单感和卓越感的组合做作吗，或者说这种组合是否给了玩家一种实现愿望的特别方式呢？ lens #68:英雄之旅许多英雄故事拥有相似的结构。使用此lens可以确保你没有丢失任何可以改进你故事的元素。 请自问如下几个问题：1.故事中拥有适合英雄故事的元素吗？2.如果拥有，如何匹配英雄之旅模型的故事结构？3.故事能通过包含进更多的典型元素而获得改进吗？4.故事是否和这种形式靠得太近，以至于让人感觉陈词滥调？ lens #69:古怪事物在你的故事中加入古怪的事物可以帮你带来不同寻常的游戏机制，它可以捕捉玩家的兴趣，而且能够让你的世界看起来更特别。大量的奇怪事物会使你的故事令人费解和难以进入。 为了确保你的故事是好的古怪类型，请自问如下几个问题：1.我的故事中什么是古怪的东西？2.我如何能确定古怪的东西不会困惑或疏远我的玩家？3.如果有多个古怪的东西，我应该去除或合并其中的一些吗？4.如果我的故事中没有任何古怪的东西，我的故事仍然是有趣的吗？ lens #70:故事 请自问如下几个问题：1.游戏真的需要一个故事吗？为什么？2.为什么玩家会对这个故事感兴趣？3.故事是如何支持四分体的其他部分的（美学、技术、游戏性）？它能做得更好吗？4.四分体的其他部分支持这个故事吗？它们能做得更好吗？5.如何让我的故事变得更好？ lens #71:自由自由感是区别游戏和其他形式的娱乐方式的一个重要方面。 为了保证玩家尽可能多地感受到自由，请自问如下几个问题：1.什么时候玩家们可以自由行动？这时他们感受到自由了吗？2.什么时候他们被限制行动？这时他们感受到被限制了吗？3.有什么地方我可以让玩家们感受到比目前更多的自由？4.有什么地方给予玩家过多的自由而使他们不知所措？ lens #72:间接控制每一个设计师对于“要让玩家做什么事情才能得到理想的游戏体验”都有自己的先见之明。 为了帮助你保证玩家是处于自己的自由意愿做这些事情，问你自己如下问题：1.最理想的情况下，希望玩家去做什么？2.我能设置一些限制来促使玩家去做吗？3.我能设置目标促使玩家去做吗？4.我能设计界面促使玩家去做吗？5.能利用游戏里的角色促使玩家去做吗？6.能利用音乐或是音效促使玩家去做吗？ 能利用其他办法强制玩家接近理想的行为而不侵犯他们的自由感吗？ lens #73:合谋各种人物都要在游戏中充分扮演自己的角色，但是在需要的时候，也要变成设计师的仆人，朝着设计师的最终目标而努力，保证赋予玩家迷人的游戏体验。 为了保证游戏角色履行这个职责，问你自己如下问题：1.我希望玩家体验什么？2.如何让游戏角色来帮助玩家达成这个体验，同时又不改变他们在游戏里的目标？ lens #74:游戏世界游戏中的世界是独立存在的。游戏是通向这个只存在于玩家想象中的魔法世界的门户。 为了保证你的世界既有力又完整，请自问如下几个问题：1.我的世界比真实的世界好在哪里？2.我的世界能有多个门户吗？它们之间有什么区别？它们之间如何彼此支持？3.我的世界是由一个单独的故事组成的，还是由很多故事组成的？ lens #75:虚拟角色虚拟角色是玩家通向游戏世界的门户。 为了保证虚拟角色尽可能地展示出玩家所期望的身份，请自问如下几个问题：1.我的虚拟角色对玩家来说是有吸引力的理想化形式吗？2.为了让玩家能够把自己投影到角色中，我的虚拟角色具备抽象化的图标品质吗？ lens #76:角色功能 为了保证角色正在做游戏需要完成的事情，请自问如下几个问题：1.我需要游戏人物担任什么样的角色？2.我想到了什么样的角色？3.哪个角色特别适合某一个功能？4.能让某些角色匹配多种功能吗？5.为了更好地适应某项功能我需要改变角色吗？6.需要新角色吗？ lens #77:角色性格特征 为了保证你的角色所说的和所做的都能体现他的性格，请自问如下问题：1.我的角色的性格特征的定义是什么？2.这些性格特征如何体现在角色的言语、动作和外观上？ lens #78:人际关系特征环理解你的角色间的关系是至关重要的。方法之一是建立一个图形，在一个坐标轴上标注敌对/友好，在另一个坐标轴上标注顺从/支配。选一个角色来分析，把他放到中心。 然后将与其有关的角色摆放到图表中，然后自问如下几个问题：1.在图表中有空缺的地方吗？为什么会有空缺？如果填补上空缺会更好一些吗？2.图表上有“极端角色”吗？如果没有，是不是有会更好些？3.角色的朋友们是否在同一个象限，或是在不同象限？如果在不同象限上会怎么样？ lens #79:角色关系网 为了更好地充实你的角色关系，给所有的角色制作一个名单，请自问如下几个问题：1.每个角色对于其他人的感觉如何？2.有丢失的关联吗？如果有，我该如何利用这些关联？3.相似的关联是不是太多了？如何能让它们更有区别呢？ lens #80:身份地位当人们打交道时，会根据身份地位等级的不同呈现不同的行为。 为了让你的角色能够更充分地认识彼此，请自问如下几个问题：1.游戏中地角色相对的身份地位等级是如何的？2.如何才能让他们做出于身份一致的行为？3.身份地位上的冲突很有趣，我的角色如何争取身份地位？4.身份地位的改变很有趣，在游戏中的什么地方出现身份的改变呢？5.如何让玩家有机会表达自己的身份地位？ lens #81:角色变化强有力的故事能够改变他们的角色。 为了保证角色是通过有趣的方法发生改变的，请自问如下几个问题：1.游戏中的每一个角色在整个游戏中是如何发生改变的？2.要如何将这些变化传达给玩家？我能传达得更清晰、更强有力一些吗？3.转变足够多吗？4.转变意外并且有趣吗？5.这些转变能够让人信服吗？ lens #82:内在矛盾一个好的游戏不应该包含违背游戏目的的属性。 为了去掉这些矛盾的属性，请自问以下几个问题：1.我游戏的目的是什么？2.游戏中各个子系统的目的是什么？3.游戏中有任何因素是和这些目的矛盾的吗？4.如果有矛盾，怎么改变它？ lens #83:无名品质因为一些物体的自然鲜活的设计，使人感到特别精彩。 为了让游戏具有这些属性，请自问以下几个问题：1.我的设计带着生活的特别感觉吗？或者设计的某个部分感觉像死去一样吗？怎样才能让设计感觉更有生命力一些？2.我的设计拥有Alexander的15个品质中的哪几个？3.能拥有更多的那些品质吗？4.我的设计哪里感觉像我自己一样？ Alexander的生活结构的15个特点：尺度的层次，鲜明的中心，边界，交替重复，积极的空间，好的形状，局部对称，内部死锁和歧义，对比，渐变，粗糙，回音，虚无，简单和冷静，不可分割性。 lens #84:友谊人们喜欢和朋友一起玩游戏。 为了确保游戏有让人们发展并保持友谊的特质，请自问以下几个问题：1.我的玩家在寻找什么样的朋友关系。2.玩家之间怎样从陌生发展到相识。3.游戏的玩家有足够的机会和彼此交流吗？有足够的交流话题吗？4.他们在什么时候可以成为朋友？5.我给玩家们什么工具来保持朋友关系？ lens #85:自我表达当玩家有机会表达自我时，他们会感到生动、自豪、重要和互动。 为了使用这个lens，请自问以下几个问题：1.怎么才能让玩家表达他们自己？2.忽视了什么手段吗？3.玩家为他们自己的标识感到自豪吗？为什么自豪或者为什么不自豪？4.这个lens时很重要的，而且它能和其他lens同时起效，例如lens#63和lens#80 lens #86:社区 为了让游戏催生一个强壮的社区，请自问以下几个问题：1.社区内的冲突是什么？2.社区是怎么规划的？3.游戏怎么支持3种不同水平的体验？4.有社区事件吗？5.为什么玩家们互相需要？ lens #87:捣乱 为确定你游戏的捣乱行为已经被最少化了，请自问以下几个问题：1.游戏中的什么部分容易被捣乱？2.怎样才能在游戏中的捣乱行为变得无趣？3.是不是忽视了一些漏洞？ lens #88:爱的 为了使用这个lens，请自问以下几个问题：1.我喜欢我的项目吗？如果不喜欢怎样才能改变这点？2.团队中的每个人都喜欢这个项目吗？如果不喜欢，怎样才能改变？ lens #89:团队 为了让你的团队运作起来像一部加好了油的机器，请自问以下几个问题：1.这个团队适合这个项目吗？为什么？2.这个团队沟通的时候客观吗？3.这个团队沟通的时候清晰吗？4.团队成员们彼此之间相处的舒服吗？5.团队中有信任和尊重的氛围吗？6.团队最终可以统一观点吗？ lens #90:文档 为了确保书写你所需要的文档，并省略那些你不需要的，请自问以下几个问题：1.在制作游戏的过程中什么是我们需要记载的？2.在制作游戏的过程中什么是我们需要交流的？ lens #91:游戏测试游戏测试是你在实际环境中看到游戏表现的机会。 为了让游戏测试尽可能的完成，请自问以下几个问题：1.为什么我们需要游戏测试？2.谁应该参加？3.在哪里进行测试？4.什么是应该被寻找的？5.怎样才能得到我们需要的信息？ lens #92:技术 为了保证你在用正确的方法使用正确的技术，请自问以下几个问题：1.什么样的技术能帮助我想创造的游戏体验？2.技术使用是基础性的还是装饰性的呢？3.如果不是将技术用于基础方面的，那还应该使用它们吗？4.这项技术像我想的那么酷吗？5.有任何值得我考虑的“革新性技术”吗？ lens #93:水晶球 如果你想知道特定游戏技术的未来，请自问以下几个问题，并尽量具体回答：1.2年后__会怎么样？为什么？2.4年后__会怎么样？为什么？3.10年后__会怎么样？为什么？ lens #94:客户如果你在为别人制作游戏，那么就应该知道他们想要什么。 请自问以下几个问题：1.客户口头上想要什么？2.客户认为他自己想要什么？3.客户在内心深处想要什么？ lens #95:推销 为了保证你的推销尽可能得好，请自问以下几个问题：1.为什么要向这个客户推销这个游戏？2.我认为什么才是“成功的推销”？3.对推销的对象而言什么才是有价值的？4.推销的对象都需要知道游戏的哪些信息？ lens #96:利润利润保持着游戏工业的生机。 请自问以下几个问题来让游戏成为有利润的游戏：1.在游戏的商业模型里，金钱是怎样流动的？为什么？2.需要多少成本来制作、宣传和销售游戏？为什么？3.这份游戏将会销售多少？为什么我如此认为？4.需要销售多少份游戏才能保持游戏收支平衡？ lens #97:改变游戏创造体验，体验改变人类。 为了保证只让玩家们发生有益的改变，问自己这些问题：1.怎样才能让游戏使玩家向好的方向改变？2.怎样才能让游戏使玩家向坏的方向改变？3.那么关心游戏如何影响玩家是不是真的是你的责任呢。 lens #98:责任 为了负起你作为游戏设计者的责任，请自问下面一个问题：我的游戏能帮助人们吗？怎么帮？ lens #99:乌鸦 为了记住只投入在重要的工作上，请自问以下这个问题：制作这个游戏值得我投入时间吗？ lens #100:你的秘密目的 为了确保你在向你真实的目标前进，请自问以下这个重要的问题：为什么我要做这件事？ 一个小拇指戒指你想过你的小拇指吗？为什么它那么异常，比其他指头都要小？小拇指看起来像一个意外，像某种萎缩的附属物。但它不是附属物。它的功能是我们大部分人所没有想到的。你的小拇指是你的手的向导。每当你捡起一样东西或者放下一样东西的时候，你的小拇指是第一个接触东西的。小拇指就像天线一样感觉物品安全地把手引导到位置。在1922年，多伦多大学请Rudyard Kipling来设计一个仪式。这个仪式主要是提醒毕业生们负有回报社会的责任。在这个仪式的结尾，直到今天，每个毕业生会被给予一个铁戒指，放在他们右手的小拇指上，作为这个责任的终生提示物。有一天，游戏设计者也会制作他们自己的责任仪式，但你不能等到那一天才担起责任。你的责任从今天就开始，从这一分钟开始。如果你真的相信游戏可以帮助人们，那么戴上这个戒指，它是隐形的，就像我的戒指一样，这样你永远不会丢掉它，但在你戴之前慎重思考，因为戴上就不能取下。如果你仔细看，你会看到戒指带着这样的铭文：责任","path":"2022/11/30/quan-jing-tan-mi-you-xi-she-ji-yi-zhu-de-li-wu/","date":"11-30","excerpt":"","tags":[{"name":"游戏设计","slug":"游戏设计","permalink":"https://jia_k3.gitee.io/blog/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"APK汉化经历","text":"一、使用到的工具：1.apktool(jdk命令) 需要安装Java，一般自带apktool工具 使用apktool来反编译apk修改英文翻译 2.MT管理器(安卓) 使用自带签名功能，无需VIP 二、操作步骤注：本次汉化程序选择GnaCAD，一个安卓手机绘图软件 1.将需要的apk放置在一个文件夹中，在该位置打开命令行(可以在文件管理器的地址栏输入cmd来快速打开)，反编译apk 反编译命令：将APK反编译出同名文件夹 apktool d gnacad.apk 2.打开gnacad&gt;res&gt;values&gt;strings.xml，替换英文 3.在1中唤出的命令行输入编译命令编译新的APK 编译命令： apktool b gnacad -o cad.apk 4.将新编译出的APK发送到安卓手机，用MT管理器找到安装包 长按APK选择签名功能，使用默认V1+V2+V3签名方式，获得新的已签名APK 5.点击安装 三、问题问题：使用jarsigner签名安装失败 解决方法：使用jarsigner需要用不同代码先后为APK添加不同等级的签名 ​","path":"2022/11/05/apk-han-hua-jing-li/","date":"11-05","excerpt":"","tags":[{"name":"Android","slug":"Android","permalink":"https://jia_k3.gitee.io/blog/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://jia_k3.gitee.io/blog/tags/Java/"}]},{"title":"Unity安卓打包报错解决方法","text":"Unity版本2021.3.8f1c1 核心报错：CommandInvokationFailure: Gradle build failed. 错误原因：Gradle打包需要签名 错误解决：1.前往File-&gt;Build Settings-&gt;Player Settings-&gt;Publishing Settings-&gt;Keystore Manager新建用户签名2.返回Publishing Settings选择Custom Keystore为True3.在下方选择签名（一般自动会选择）","path":"2022/08/27/unity-an-zhuo-da-bao-bao-cuo-jie-jue-fang-fa/","date":"08-27","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"}]},{"title":"《数据库系统》课程笔记","text":"​ 一、绪论1.数据1.1数据是描述现实世界中各种具体事物或抽象概念的可存储编码，是信息的载体 1.2数据的类型：数字、字符串、日期、逻辑值、文本、图像、声音、图型结构、树型结构 2.数据库2.1数据库：是长期储存在计算机内、有组织的、可共享的数据集合 2.2数据库的特征：不是临时存储，数据按一定的数据形式组织、描述和储存，可为各种用户共享 2.3数据库的类型： 2.3.1按照数据的类型：简单结构数据库（关系数据库，时、空数据库），复杂结构数据库（图数据库），半结构化数据库（XML数据库），非结构化数据（文本、音视频、图像等多媒体数据库） 2.3.2数据存储的方式：单机数据库，分布式数据库，并行数据库 2.3.3数据存储的介质、时长：内存数据库、流数据库 2.4数据库目的：把现实世界映射到计算机世界，支持各种实际应用 2.5数据库模式：数据集合的结构定义 2.6数据库实例：数据集合的具体内容 3.数据库管理系统及其结构3.1数据库管理系统(DBMS)：管理数据库，支持应用的软件系统 3.1.1定义、组织、存储、管理数据 3.1.2数据操纵 3.1.3确保数据正确、安全、完整 3.1.4并发控制与事务处理 3.2数据字典是数据库管理系统的信息中心 3.3数据库管理系统的功能与特点： 3.3.1有效地支持数据抽象与数据定义（具有坚实的数据模型基础、支持数据的不同视图） 3.3.2有效地组织存储数据（提供丰富的数据存储方法、提供有效的数据存取方法） 3.3.3有效地处理数据查询与更新（提供有效的数据操纵语言、提供高效的数据操作算法、优化地处理数据查询） 3.3.4支持数据独立性 3.3.5控制数据冗余（综合考虑所有用户的数据库视图，把它们集成为一个逻辑模式，数据项只存储1次或少数几次） 3.3.6支持数据共享/并发控制（允许多个用户或多个应用程序同时访问数据库中的相同数据，即允许数据共享；为了支持数据共享，数据库管理系统具有并发控制机制） 3.3.7限制非授权的存取（为了保证数据库的安全，防止对数据库的非法存取，DBMS具有一个安全与授权子系统） 3.3.8提供多种用户界面（图形界面，查询语言界面，程序设计语言界面） 3.3.9表示数据之间的复杂联系（数据间联系的定义机制，通过数据间联系查询数据的机制） 3.3.10支持完整性约束（数据库应用对数据语义一般都有一定的限制，称为完整性约束） 3.3.11有效的数据恢复与事务处理（在系统硬件或软件发生故障时，能够保证数据库的正确性） 4.数据库系统4.1数据库系统有多种看法，但一般都包括数据库和数据库管理系统 4.2文件系统：不同部门拥有各自独立的数据文件。由于一下因素而使用数据库系统：数据冗余和不一致、数据访问异常、数据孤立、完整性问题、原子性问题、并发访问异常、安全性问题 4.3数据库系统：按照某种数据模型，将全部门的各种数据组织到一个统一的结构化的数据库中，整个部门的数据不是一盘散沙，可表示出数据之间的有机关联 4.4数据统一存储在关系数据库中 4.5查询：只需提交查询要求，由系统完成查询过程 5.数据抽象与数据模型5.1数据抽象的作用：对于用户系统地隐藏关于数据存储和维护的某些细节；屏蔽复杂性，简化用户与系统的交互 5.2视图抽象：把现实世界信息按不同用户观点抽象为多个逻辑数据结构，每个逻辑结构称为一个视图，描述了每个用户所关心的数据；所有视图的集合形成了多个数据库用户的若干外模式（一个数据库可以有多个外模式） 5.3逻辑抽象：综合外模式中所有视图，把所有用户关心的现实世界抽象为逻辑模式，形成数据库整体逻辑（一个数据库有唯一的概念模式） 5.4物理模式：对逻辑模式进行抽象成为数据库的内模式，确定如何在物理存储设备上存储数据库（一个数据库有唯一的物理模式） 5.5物理数据独立性：由内模式/逻辑模式映射实现，数据库内模式发生改变时仅需修改内模式/逻辑模式映射，数据的逻辑结构不变，应用程序可以不变 5.6逻辑数据独立性：由逻辑模式/外模式映射实现，当逻辑模式发生改变时仅需要修改逻辑模式/外模式映射，数据库的外模式不变，应用程序可以不变 5.7数据抽象：视图抽象为外模式，概念抽象为逻辑模式，物理模式抽象为内模式 5.8数据独立：物理独立性（内模式发生改变时，概念模式可以不变），逻辑独立性（概念模式发生改变时，外模式可以不变） 5.9数据模型是实现数据抽象的工具，是数据库系统关键、决定，数据模型的必要条件 5.10数据模型的基本要素：数据结构、数据操作、数据的完整性约束 5.11常用的数据模型：实体关系(E-R)数据模型，面向对象(O-O)数据模型，关系数据模型，对象关系(O-R)数据模型，层次和网络数据模型 5.12层次数据模型 5.12.1满足下列两个条件的基本层次联系的集合为层次模型：有且只有一个结点没有双亲结点，这个结点称为根节点；根以外的其他结点有且只有一个双亲结点 5.12.2层次模型的数据结构是满足下列条件的树：每个结点：现实世界的对象的一个抽象（一类对象），又称实体；边表示对象之间的联系 5.12.3特点：结点的双亲是唯一的；只能直接处理一对多的实体联系；任何记录值只有按其路径查看时，才能显示它的全部意义；没有一个子女记录值能够脱离双亲记录值而独立存在 5.12.4完整性约束：无相应的双亲结点值就不能插入子女结点值；如果删除双亲结点值，则相应的子女结点值也被同时删除 5.12.5优点：简单、直观、自然、容易理解；性能优于关系模型，不低于网状模型；层次数据模型提供了良好的完整性支持 5.12.6缺点：多对多联系表示不自然；对插入和删除操作的限制多；查询子女结点必须通过双亲结点；面向过程 5.13网状数据模型 5.13.1数据结构是满足下列条件的图：每个结点是一个对象记录；边表示对象之间的联系；允许多个结点无双亲结点；允许结点有多个双亲结点；允许两个结点之间有多种联系 5.13.2层次结构是网状结构特例 5.13.3完整性约束条件不严格：允许插入尚未确定双亲结点值得子女结点值；允许只删除双亲结点值；一些具体系统提供了一些完整性约束 5.13.4优点：能够更为直接地描述现实世界；具有良好得性能，存取效率较高 5.13.5缺点：结构比较复杂，不利于最终用户掌控；DDL\\DML语言复杂，用户不容易使用；面向过程 二、关系数据库1.关系模型1.1数据结构 1.1.1关系模型建立在集合代数的基础上，单一的数据结构（关系，现实世界的实体以及实体间的各种联系均用关系来表示），数据的逻辑结构是二维表 1.1.2元组表示一个实体；关系是元组的集合 1.1.3属性：用来指代关系表的列，n元关系有n个属性，属性的顺序无关紧要 1.1.4域：属性的所有可能取值的集合（原子域：域中值不可再分；空值：一个特殊的值，表示值未知或不存在） 1.1.5笛卡尔积：给定一组域D1,D2,…,Dn，这些域中可以有相同的。D1,D2,…,Dn的笛卡尔积为D1*D2*…Dn={(d1,d2,…,dn)|di属于Di,i=1,2,…,n}（所有域的所有取值的一个组合，不能重复） 1.1.6元组：笛卡尔积中每一个元素(d1,d2,…,dn)叫做一个n元组或简称元组 1.1.7关系的数学定义：D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，称为n元关系 1.1.8关系的性质：列是同质的，每一列中的分量来自同一个域；关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性；列的次序可以任意交换，即满足交换律；任意两个元组不能完全相同；行的顺序无所谓，可以任意交换；属性值必须取原子值 1.1.9关系模式：关系的型，具有形式R(U,D,I,F)，其中：R是关系名，U是R的属性集合，D是U中属性的域集合，I是完整性约束集合，F是属性间的函数依赖关系（简单记作R(U)，把属性集合为U={A1,A2,…,An}的关系模式R记作R(A1,A2,…,An)） 1.1.10关系、关系模式与关系实例：关系是一个数据集合；关系模式描述关系的数据结构和语义描述，非集合；关系模式是相对稳定的；关系是随时间而变化的；关系实例是某一时刻的关系，是某一时刻现实世界状态的真实反映 1.1.11数据库中常见的关系类型：基本关系（基本表、基表）由用户定义，在数据库中实际存储的关系，可以查询与更新；中间结果关系：对关系进行查询，产生的中间结果，在数据库中临时/永久存储，只可查询，不可更新；视图关系：用户根据需要定义的关系，定义在基本关系或视图上，只有模式，没有实例，没有对应的实际存储的数据，可查询，更新受限 1.1.12关系数据库模式：一组关系模式的集合DB={R1,R2,…,Rn}，其中，Ri是第i个关系模式 1.2完整性约束 1.2.1超码(superkey)：关系模式R(U)的属性集K是超码，如果K的值可以在R中唯一地标识一个元组 1.2.2候选码(候选键)：关系模式R(U)的属性集合k包含于U是候选码，如果k是超码（唯一性）且k的任何真子集都不满足条件（最小性）（一个关系模式可能具有多个候选键） 1.2.3主键：被数据库设计者选中的，用来在同一关系中区分不同元组的候选键（选择原则：值从不或很少变化）（一个关系模式只能具有一个主键，主键中的属性称为关系的主属性） 1.2.4外键：设有关系模式S(U’)和R(U)，及属性集合X，X包含于U’且X属于U，若X是S(U’)的主键，则称X是R(U)关于S(U’)的外键（不一定与对应的主键同名，外键取值对应主键的某个值或者空值） 1.2.5实体完整性约束：如果A是关系模式R(U)的主键属性，则A不能取空值 1.2.6关联完整性约束：定义了主键与外键之间的规则（外键只能取空值或与之关联的主键值） 1.3关系代数运算： 选择：选择行（元组）投影：选择列（属性）并：合并元组，删除重复（约束条件：属性相容（相同））差：从前者元组中删除后者包含的元组（约束条件：属性相容）笛卡尔积：将任意两个关系的信息组合在一起重命名：重命名关系，属性依次重命名交：找到同时包含于两个关系的元组（约束条件：属性相容）连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组自然连接：特殊的等值连接，比较两个关系的同名属性，最后将同名属性列去冗余除：根据除关系的属性B找到被除关系的同名属性B的相同元组(A,B)得到A为最终结果左（右）外连接：左右关系做自然连接，取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把所产生的元组加到自然连接的结果中广义投影：将算术运算作为投影的一部分比如2020-age可以作为投影属性出现分组聚集：依据属性的值分组，分别对每组数据进行运算（sum\\count\\max\\min\\avg） 1.4当我们书写关系代数表达式时，我们提供了产生查询结果的过程序列，与之相反，元组关系演算是非过程化的查询语言，它只描述所需信息，不给出获得该信息的具体过程 1.5元组关系演算： 1.6域关系演算： 1.7安全关系运算系统：如果一个关系运算系统不产生无限关系和无穷验证，则这个运算是安全的 1.7.1关系代数系统安全（有限关系上的关系代数操作结果都不会导致无限关系和无穷验证） 1.7.2元组关系演算和域关系演算系统不安全（若定义域无穷，判断需要无穷验证）（需要加以限制来保证其安全性） 1.8关系代数、元组和域演算的等价性： 1.8.1如果两个表达式所表达的关系相同，我们称这两个表达式为等价表达式 1.8.2设E是任意关系代数表达式，则存在一个与E等价的安全元组演算表达式 1.8.3每个安全的元组演算表达式都有一个等价的安全域演算表达式 1.8.4每个安全域演算表达式都有一个等价的关系代数表达式与之对应 2.SQL查询语言2.0关系运算是关系数据库查询语言的基础关系代数语言：ISBL：纯关系代数查询语言元组关系演算语言：QUEL：元组关系演算的查询语言域关系演算语言：QBE关系代数+关系演算语言：SQL：目前使用最广泛 2.1数据库语言的两种使用方式： 2.1.1交互式：通过计算机终端设备直接操作数据库 2.1.2嵌入式：在宿主语言(如C、C++)程序中使用数据库语言语句 2.2SQL的特点：综合统一，高度非过程化，面向集合的操作方式，语言简捷，易学易用2.3SQL的九条语句： 2.4​SQL的数据定义语句：| | | | || :-: | :-: | :-: | :-: || |创建 | 删除 | 修改 || 表 | CREATE TABLE |DROP TABLE | ALTER TABLE || 视图 | CREATE VIEW | DROP VIEW | 无 || 索引 | CREATE INDEX | DROP INDEX |无 |视图和索引无修改语句2.5一般语法格式： SELECT [DISTINCT/ALL] &lt;列表达式&gt;[别名] [,&lt;列表达式&gt;[别名]]... FROM &lt;表名&gt;[&lt;别名&gt;][,&lt;表名&gt;[&lt;别名&gt;]]1~n [WHERE &lt;条件表达式&gt;] [GROUP BY &lt;分组属性表&gt; [HAVING &lt;条件表达式&gt;]] [ORDER BY &lt;列名&gt;[ORDER],...,&lt;列名&gt;[ORDER]] 三、数据库的安全性与完整性0.引子0.1为了保证数据库数据的安全可靠和正确有效，DBMS必须提供统一的数据保护功能0.2数据库的安全性：数据库的任何部分都不允许受到恶意侵害或未经授权的存取和修改0.3数据库的完整性：一般指语义完整性与事务完整性，本章主要讨论数据库的语义完整性0.4用户操作权限和完整性约束都存储在数据库管理系统的数据字典中0.5数据库的安全性和完整性都由数据库管理系统来确保 1.数据库安全性1.1数据库的一大特点是数据可以共享，但数据共享必然带来数据库的安全性问题1.2数据库安全性控制的常用方法：用户标识和鉴定，存取控制，视图，审计，加密存储1.3用户标识与鉴别：1.3.1系统提供的最外层安全保护措施1.3.2用户身份鉴别的方法有：静态口令，动态口令，生物特征鉴别，智能卡鉴别1.4存取控制机制：1.4.1存取控制机制的组成：定义存取权限（权限通过编译后存储在数据字典中）；检查存取权限（用户向数据库发出存取请求后，DBMS查找数据字典，检查权限可否执行）用户权限定义和合法权检查机制一起组成了DBMS的安全子系统1.4.2存取控制机制（常用存取控制方法）：自主存取控制(DAC)；SQL对自主存取控制提供的支持（Grant授予权限；Revoke收回权限）强制存取控制(MAC)：用户不能直接感知或进行控制，适用于对数据有严格而固定秘密分级的部门1.4.2’强制存取控制（续）：主体：系统中的活动实体，包括用户、代表用户的各个进程客体：系统中的被动实体，包括文件、基本表、索引、视图等审计：审计功能启用一个专用的审计日志，系统自动将用户对数据库的所有操作记录在上面，DBA可以利用审计日志中的跟踪信息，重现导致数据库现有状况的一系列事件，以找出非法存取数据的人数据加密：防止数据库中数据在存储和传输中失密的有效手段加密的基本思想：根据一定的算法将原始数据（明文）变换为不可直接识别的格式（密文）1.4.3用户权限的两个要素：数据库对象，操作类型1.4.4数据库角色：被命名的一组与数据库操作相关的权限，可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程 2.数据库完整性2.1数据库完整性：为保证数据库中数据的正确性和相容性，对比关系模型提出的某种约束条件或规则2.2完整性约束通常包括：域完整性，实体完整性，关联完整性（参照完整性），用户定义完整性（前三者是关系模型必须满足的完整性约束条件）2.3为维护数据库完整性，DBMS必须提供如下功能：定义完整性约束条件的机制，完整性检查方法，违反约束的处理方法2.4域完整性：保证关系表属性取值的合理性2.4.1域完整性检查：包括检查、默认值、不为空、列值唯一等2.5实体完整性：关系的主码不能重复也不能取空值2.6关联完整性（参照完整性）：在建立关系的时候用FOREIGN KEY短语定义外码，用REFERENCES短语指明这些外码参照哪些表的主码2.6.1对被参照关系和参照关系进行增、删、改操作时可能破坏关联完整性，必须进行检查以保证两个关系中数据的相容性2.6.2一个操作破坏关联完整性时，系统可以采取的策略：拒绝执行，级联操作（将不一致元组删除），设置为空值（将不一致元组设置为空值）2.7用户定义的完整性：2.7.1属性上的约束条件：NOT NULL|UNIQUE|CHECK子句2.7.2元组上的约束条件：CHECK子句可以设置不同属性之间的取值的相互约束条件2.8完整性约束命名子句语法结构：2.8.1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;2.8.2&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK子句等2.9断言Assertion2.9.1通过声明断言，可以定义更具一般性的约束，例如涉及多个表或聚集操作的比较复杂的完整性约束2.9.2对断言所涉及关系的操作将触发RDBMS对断言的检查2.9.3任何使断言不为真的操作都会被拒绝2.9.4语法结构：CREATE ASSERTION &lt;断言名&gt; &lt;Check子句&gt; DROP ASSERTION &lt;断言名&gt;2.10触发器Trigger2.10.1触发器是用户定义在关系表上的一类由事件驱动的特殊过程2.10.2定义之后的触发器存储在数据库服务器中2.10.3任何用户对表的增、删、改操作均由服务器自动激活相应的触发器2.10.4不同RDBMS实现的触发器语法各不行同，互不兼容2.10.5语法结构：定义触发器CREATE TRIGGER &lt;触发器名&gt; {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW|TABLE AS &lt;变量&gt; FOR EACH {ROW | STATEMENT} [WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;删除触发器DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;2.10.6只有表的拥有者（创建者）可以在表上定义触发器；触发器名中可以包含模式名，同一模式下触发器不能重名，而且触发器名和表名必须在统一模式下；触发器只能定义在基本表上，不能定义在视图上2.10.7触发器激活顺序：执行该表上的BEFORE触发器-激活触发器的SQL语句-执行该表上的AFTER触发器-多个BEFORE（AFTER）触发器时, 先执行先创建的, 或按名字排序 四、数据库设计1.数据库设计概念与需求分析1.1数据库设计：对于一个给定的应用领域，设计优化的数据库逻辑和物理结构，使之满足用户的信息管理要求和数据操作要求，有效地支持各种应用系统的开发和运行1.2数据库设计目标：为用户和各种应用系统提供一个信息基础设施和高效率的运行环境，高存取效率，高存储空间利用率，高运行管理效率1.3数据库设计特点：结构（数据）设计和行为（处理/查询）设计二者结合1.4数据库的各级模式1.4.1需求分析阶段：综合各个用户的应用需求1.4.2概念设计阶段：形成独立于机器特点，独立于各个数据库管理系统产品的概念模式(E-R图)1.4.3逻辑设计阶段：首先将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式；然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图（View），形成数据的外模式1.4.4物理设计阶段：根据数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式1.5需求分析：是分析用户的要求，是设计数据库的起点，结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用1.6需求分析的任务：详细调查现实世界要处理的对象（组织、部门、企业等）；充分了解原系统（手工系统或计算机系统）工作概况；明确用户的各种需求；在此基础上确定新系统的功能；新系统必须充分考虑今后可能的扩充和改变1.7需求分析的重点：“数据”和“处理”，获得用户对数据库要求1.7.1信息要求：用户需要从数据库中获得信息的内容与性质；由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据1.7.2处理要求：用户要完成什么处理功能；对处理的响应时间的要求；对处理方式的要求(批处理 / 联机处理)1.8需求分析的步骤：应用领域的调查分析（协助用户明确要求）；定义数据库支持的信息与应用；定义数据库操作任务；定义数据项字典1.8.1常用调查方法：跟班作业，开调查会，专人介绍，询问，调查问卷，查询记录1.8.2数据项字典的组成：数据项：不可再分的数据单位；描述：数据项名、数据项含义说明、别名、数据类型、长度、取值范围、取值含义、与其他数据项的逻辑关系、数据项之间的联系数据结构：反映数据之间的组合关系，由数据项和其他数据结构组成；数据结构描述：数据结构名、含义说明、组成数据流：数据结构在系统内传输的路径；数据流描述：数据流名、说明、数据流来源、数据流去向、组成（包括哪些数据结构）、平均流量、高峰期流量数据存储：数据结构停留或保存的地方，数据流的来源和去向之一，可以是手工文档、凭单或计算机文档；数据存储描述：数据存储名、说明、编号、输入的数据流、输出的数据流、组成、数据量、存取频度、存取方式处理过程：具体处理逻辑一般用判定表或判定树来描述，数据项字典中只描述其说明性信息；处理过程描述：处理过程名、说明、输入（数据流）、输出（数据流）、处理（简要说明，包括功能和要求） 2.概念数据库设计2.1概念数据库设计的任务包括概念数据库模式分析和事务设计2.1.1概念数据库模式设计：以需求分析阶段所识别的数据项和应用领域的未来改变信息为基础，使用高级数据模型建立概念数据库模式2.1.2事务设计：考察需求分析阶段提出的数据库操作任务，形成数据库事务的高级说明2.2概念数据库模式设计的目标：准确描述应用领域的信息模式，支持用户的各种应用；既易于转换为逻辑数据库模式，又容易为用户理解2.3概念模型：用于将需求分析阶段所得到的应用需求抽象为信息世界的结构，是各种数据模型的共同基础，更加独立于DBMS和机器 （更高级）2.4概念模型的特点：2.4.1能真实、充分地反映现实世界，包括事物和事物之间的联系2.4.2易于理解，可用于和不熟悉计算机的用户交换意见2.4.3易于改变，应用环境和应用要求改变时容易对概念模型进行修改2.4.4易于向关系、网状、层次模型转换2.5实体联系模型(ER模型)：用于概念数据库设计的高级数据模型（概念数据库模式独立于任何数据库管理系统，不能直接用于数据库的实现）2.5.1表示为“实体-联系”图2.5.2三个主要元素：实体、属性、联系2.5.3实体是ER模型的基本对象；实体是现实世界中各种事物的抽象2.5.4每个实体都有一组特征或性质，称为实体的属性。实体属性的一组特定值确定了一个特定的实体。实体的属性值是数据库中存储的主要数据2.5.5实体集：相同类型(即具有相同性质或属性) 的实体集合（实体集不必互不相交）2.5.6实体属性：多数实体属性都是单值属性，即对于同一个实体只能取一个值，但是，在某些情况下，实体的一些属性可能取多个值，这样的属性称为多值属性；可以划分为多个具有独立意义的子属性。我们称这类属性为复合属性，复合属性具有层次结构；导出属性不仅可以从另外的属性导出，也可以从有关的实体导出；在某些情况下，实体的有些属性可能没有适当值可设置，这些属性通常被设置一个称为空值的特殊值2.5.7码：在ER模型中每个实体集具有一个由一个或多个属性组成的码，用来区别不同的实体2.5.8联系：不同实体集之间可能具有某种关联，我们称这种关联为实体间的联系2.5.9联系集：同类联系的集合。称一个联系集所关联的实体集的数量为这个联系集的阶。阶为n的联系集称为n元联系集2.5.10实体之间的联系既可以使用联系集定义，也可以通过实体属性来表示2.5.11实体之间的联系（3类映射基数，映射基数：一个实体通过一个联系能关联的实体的个数）：一对一，一对多，多对多注意：同一实体内部个体间可以有二元联系2.5.12联系集的属性：描述性属性2.5.13弱实体：现实世界中存在这样的一些实体集，它们没有足够的属性形成自己的主码。为了区分各个实体，它们必须与其它实体集相关联。这样的实体集称为弱实体集合与弱实体集相关联的实体集: 识别实体集(主实体集)主实体集与它的弱实体集之间的联系称为识别联系主实体与弱实体的关系都为一对多的关系，弱实体为多方一个主实体对应的多个弱实体之间可以相互区别弱实体集必须具有一个或多个属性，使得这些属性可以与主实体集的主码相结合，形成相应弱实体集的主码。这样的弱实体属性称为弱实体集的部分码2.6实体联系图：是表示ER模型的图形工具，简称ER图，ER图用来表示实体集和实体联系集。矩形：实体集椭圆：属性菱形：联系集线段：将属性连接到实体集或将实体集连接到联系集2.7ISA联系：继承联系分类属性：根据分类属性的值把父实体集的实体分派到子实体集中不相交约束（父实体集中的一个实体不能同时属于多个子实体集）、可重叠约束（允许父实体集中的一个实体能同时属于多个子实体集）、完备性约束（完全特化：父实体集中的一个实体必须是属于某一个子实体集中的实体；部分特化：父实体集中的存在实体不属于任何子实体集）、基数约束（对一对一、一对多和多对多的细化，参与联系的每个实体集用基数约束说明其中任何一个实体可以在联系中出现的最小次数和最大次数）2.8E-R模型设计中的一些讨论：2.8.1实体集和联系集的定义方式并不精确2.8.2为了简化E-R模型，现实世界中的事物能用作属性对待的尽量用作属性2.8.3独立的二元联系表达父母与孩子的联系更为自然2.8.4当单纯地描述实体间的行为时，采用联系集2.9概念数据库设计的基本步骤：确定实体集、实体集的属性、主码；确定实体集之间的联系及其相关的约束；形成概念数据库的E-R图2.10概念数据库的设计方法：集中式设计方法（合并在需求分析阶段得到的各种应用需求；在上述基础上设计一个概念数据库模式，满足所有应用的需求），视图综合设计法（不要求应用需求合并，分为视图设计阶段和视图合并阶段）2.11概念数据库设计策略：自顶向下的策略（首先定义全局概念结构框架，然后逐步细化），自底向上的策略（首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构）2.12局部概念模式设计：抽取各局部应用涉及的数据，标定各局部应用中的实体、实体的属性、标识实体的码，确定实体之间的联系及其类型，并形成局部E-R图2.13全局概念模式的合成：各个局部概念模式即局部E-R图建立好后，还需要对它们进行合并，集成为一个整体的数据概念结构即总E-R图集成局部E-R图的步骤：识别局部概念模式间的冲突-修改局部模式-局部模式合并-消除不必要的冗余2.14各局部E-R图存在冲突：各个局部应用所面向的问题不同，由不同的设计人员进行设计，各个局部E-R图之间必定会存在许多不一致的地方，合并分E-R图的主要工作与关键所在：合理消除各局部E-R图的冲突2.15冲突的种类：命名冲突：异名同义，同名异义值域冲突：属性值的类型、取值范围、计量单位等不同模式结构冲突：相同概念在不同的局部模式中使用不同的概念模式表示2.16不必要的冗余：冗余的数据：可由其他基本数据导出的数据冗余的联系：可由其他的联系导出的联系冗余的潜在危险：破坏数据库的完整性，给数据库维护增加负担2.17事务的设计：事务：一个或多个数据操作构成的集合，这组操作满足原子性事务设计任务 ：定义事务功能（说明事务的输入与输出） 3.逻辑数据库设计3.1逻辑数据库设计的任务：把概念数据库设计阶段产生的概念数据库模式变换为逻辑数据库模式3.2逻辑数据库设计的目标：满足用户的完整性和安全性要求动态关系至少具有第三规范形式，静态关系至少具有第一规范形式能够在逻辑级上高效率地支持各种数据库事务的运行存储空间利用率高3.3逻辑数据库设计的步骤：3.3.1形成初始关系数据库模式初始关系数据库模式：指直接由概念数据库模式生成的关系数据库模式初始关系数据库模式生成的目的：把概念数据库模式的实体、实体间联系等模型结构变换为关系模式由概念数据库模式生成初始关系数据库模式的方法：1普通实体集的变换为概念数据库模式中的每个普通实体集E建立一个关系S；S包含E的所有简单属性和E的复合属性的简单子属性；E的主码是S的主码2弱实体的变换设W是概念数据库模式中以实体集E为识别实体集的弱实体，建立一个与W对应的关系R，W的所有简单属性和复合属性的简单子属性映射为R的属性，E的主键为R的属性，R的主键由E的主键和W的部分键组合而成，E对应的关系的主键是R的外部键3多值属性的变换设实体集E具有多值属性，S是E对应的关系，为E的每个多值属性A建立一个关系T，用T表示A ，如果A是简单属性，T的属性为A与S的主键K，A和K形成T的主键，如果A是复合属性， T包含A的简单子属性和S的键K ，A的简单子属性和K形成T的键，S关系中忽略属性A 。对联系R的多值属性类似处理4实体间联系的变换1：1联系的变换：通过在关系中增加有关信息来表示联系；建立一个单独的关系表示联系1：n联系的变换不需建立新关系，在关系中添加外键和关联相关信息；建立一个单独的关系表示联系n：m联系的变换建立新关系表示联系，添加其他关系的主键作为外键n元联系类似n：m联系ISA联系的变换：保留所有关系，建立类似1：n联系；保留子关系，父关系属性加入5确定函数依赖集与用户协商，确定每个初始关系的函数依赖集，并且要使用关系数据库设计理论，对关系模式进行规范化处理3.3.2函数依赖与关系模式规范化1.初始关系模式不是逻辑设计的最终结果，其中某些关系模式可能存在由属性间的函数依赖引起的问题：冗余问题，插入问题，更新问题，删除问题2.相关概念：函数依赖：(只能根据数据的语义来确定函数依赖)如果X-&gt;Y而且Y不是X的子集，则称X-&gt;Y是非平凡函数依赖，若不特殊声明，我们总是讨论非平凡函数依赖；如果X-&gt;Y，我们称X为这个函数依赖的决定属性集函数依赖的公理系统：在关系模式的规范化处理过程中，只知道一个给定的函数依赖集合是不够的。还需要知道由给定的函数依赖集合所蕴涵的所有函数依赖的集合。为了能够从给定的函数依赖集合推导出这个集合蕴涵的所有函数依赖，我们需要一个有效而完备的公理系统。Armstrong公理系统就是这样一个系统3.Armstrong公理系统：一套推理规则，是模式分解算法的理论基础用途：求给定关系模式的候选键，从一组函数依赖求得蕴含的函数依赖三条推理规则：由自反律所得到的函数依赖均是平凡的函数依赖导出规则：4.闭包：若X的关于F闭包为U，则X为该关系的候选键闭包算法只生成由F根据Armstrong公理能够导出的依赖于X的属性集合5.快速求解候选键的方法：6.极小函数依赖集：（不唯一）7.关系模式的规范形式范式是符合某一种级别要求的关系模式的集合，关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式8.关系模式不能说规范化程度越高的关系模式就越好，上面的规范化步骤可以在其中任何一步终止9.关系模式的分解关系模式分解必须满足：分解的无损连接性和函数的依赖保持性判断对关系模式的一个分解是否于原关系模式等价的标准：具有无损连接性以及保持函数依赖10.当关系模式R被分解为两个子模式时，下述定理给出了一个判别无损连接性的简单方法保持函数依赖的模式分解11.关系模式分解算法分解具有无损连接性和分解保持函数依赖是两个互相独立的标准具有无损连接性的分解不一定能够保持函数依赖，保持函数依赖的分解也不一定具有无损连接性11.1分解算法1如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖该算法的正确性分析：11.2分解算法2正确性分析11.3分解算法3正确性分析3.3.3关系模式优化1.关系模式的优化是根据需求分析和概念设计中定义的事务的特点，对关系进行分解，提高数据操作的效率和存储空间的利用率2.关系数据模型的优化通常以规范化理论为指导：确定数据依赖；极小化模式之间的数据依赖、消除冗余的联系；逐一分析各个模式中是否存在部分函数依赖、传递函数依赖、多值依赖等，确定范式等级；根据需求分析阶段得到的处理要求确定是否要合并或分解某些模式；对某些模式进行必要的分解，提高操作效率和存储空间的利用率（水平分解和垂直分解）3.常用的关系分解方法：3.1水平分解3.2垂直分解3.3.4定义关系上的完整性和安全性约束1.每个关系模式上的完整性约束分为三类：属性上的完整性约束、多个属性间的完整性约束、不同关系模式的属性间的完整性约束2.安全性约束分两类：属性上的安全性约束、关系模式上的安全性约束3.3.5子模式定义利用视图定义外模式：使用更符合用户习惯的列名（属性重命名）、为不同级别的用户定义不同的视图、简化用户对系统的使用3.3.6性能估计：性能估计是对已经设计完成的逻辑数据库的时间复杂性和空间复杂性进行估算，其结果可以用来检验现有的计算机软硬件环境是否满足要求，以便调整软硬件环境或数据库的设计三个测度：逻辑记录存取数、信息传输量、存储空间占用量 4.物理数据库设计4.1设计任务：在逻辑数据库设计基础上，为每个关系模式选择合适的存储结构和存取方法，使得数据库上的事务能够高效率的运行4.2设计步骤：分析影响物理数据库设计的因素为关系模式选择存取方法设计关系、索引等数据库文件的物理存储结构4.3影响物理数据库设计的因素1.对于数据库查询事务，需得到如下信息：查询的关系；查询条件所涉及的属性；连接条件所涉及的属性；查询的投影属性2.对于数据更新事务，需得到如下信息：被更新的关系；每个关系上的更新操作的类型；删除和修改操作条件所涉及的属性；修改操作要改变的属性值3.了解每个事务在各关系上运行的频率4.了解每个事务的时间约束4.4常用的存取方法可以分为三类：索引方法、HASH方法、聚簇方法4.5索引存取方法的选择4.6物理存储结构设计确定如何在磁盘存储器上存储关系、索引和聚簇，使得空间利用率最大化，数据操作引起的系统开销最小化 五、数据库实现1.物理存储结构1.物理存储结构的设计主要考虑数据库的操作效率、响应时间和空间利用率2.数据库存储设备层次由高到低（层次越高、成本越高、速度越快）：基本存储（易失性存储）cache\\main memory-&gt;辅助存储/联机存储（非易失性存储）flash memory\\magnetic disk-&gt;三级存储/脱机存储（非易失性存储）optical disk\\magnetic tapes3.磁盘存储器4.磁盘存储器的读写方式4.1磁盘存储器是一种随机存储器4.2磁盘存储器的读写单位是扇区4.3主存储器与磁盘存储器交换信息必须以磁盘块为单位，磁盘块由一个或多个扇区组成4.4磁盘块地址的形式：柱面号+面号+扇区号4.5进行磁盘读写时，主存储器中必须具有与磁盘块容量匹配的缓冲区，用来存储磁盘块的数据。可以一次读写一个磁盘块的数据，也可以一次读写多个邻接磁盘块中的数据5.磁盘读写的代价5.1寻找时间：磁头定位到指定磁道的时间5.2旋转延迟：指定磁盘块转到磁头下的时间5.3传输时间：主存和磁盘间传输数据的时间6.磁盘读写策略6.1先来先服务策略：按照读写请求先后次序处理各请求，效率很低6.2近者优先策略：优先处理离磁头当前位置最近的请求，读写请求多时，效率较高6.3全程移动扫描策略：磁臂在0号至最大号磁道之间往返移动，边移动边处理请求6.4移动扫描策略：磁臂视情况改变其移动方向，前进方向上无请求时，反方向移动6.5分组扫描策略：所有读写请求分组，逐次使用移动扫描策略处理各组请求6.6间歇式全程扫描策略：磁臂反复从0号柱面扫描到最大号柱面，在每个柱面停留一段时间，等待磁盘旋转n次，使各扇面被存取概率相等7.一次磁盘读写需要毫秒级的时间7.1寻找时间和旋转延迟一般在10毫秒级别7.2数据传输时间大约在1到2毫秒时间之内7.3与CPU在主存储器处理数据的时间相比，磁盘读写时间是相当高的7.4磁盘读写是数据库应用的瓶颈，数据库的物理存储结构、数据库操作算法和查询优化的研究都把最小化磁盘读写次数作为重要目标之一8.磁盘缓冲处理技术8.1当在主存储器和磁盘之间传输多个数据块时，可以在主存储器中设置多个数据缓冲区8.2磁盘系统和CPU可以并行工作。当磁盘驱动器与一个缓冲器区交换数据时，我们可以令CPU同时处理另一个缓冲区中的数据9.缓冲区管理10.缓冲区内容替换10.1最近最少使用(LRU)策略：把最长时间没有都或者写过的数据释放10.2先进先出(FIFO)策略：把占用缓冲区时间最长的数据释放10.3立即丢弃策略：一旦缓冲器中的数据被使用结束，立即释放注意：释放缓冲区时，需要考虑该缓冲区数据是否需要写回磁盘存储器11.磁盘容错技术11.1磁盘故障将导致数据丢失11.2解决方法用一或多磁盘（数据磁盘）保存数据，用附加磁盘（冗余磁盘）保存故障恢复信息；当数据磁盘发生故障时，冗余磁盘的信息可以用来实现故障磁盘的恢复；当冗余磁盘发生故障时，数据磁盘或其他冗余磁盘用来实现故障磁盘的恢复12.基于磁盘冗余技术的策略通常称为RAID(Redundant Array of Independent Disk)12.1RAID1策略：每个数据盘附加一个冗盘（也称镜像盘）RAID1使用的冗余磁盘和数据磁盘一样多正常运行时，两盘数据保持一致12.2RAID4策略：仅使用一个冗余盘完成n个数据盘的奇偶校验；冗余盘的第i块存储所有n个数据盘第i块数据的奇偶校验位；如果所有n个数据磁盘的第i块的第j位上1的个数是偶数，则冗余磁盘的第i块第j位为0，否则为112.3RAID5策略：13.磁盘文件文件和关系13.1数据项：表示关系数据库中元组的属性值13.2文件记录1.文件记录定义：数据项的集合，对应于一个关系元组2.文件记录的种类：定长记录，非定长记录3.文件记录的存储方法：跨块存储（一个记录存储在多个文件块）、非跨块存储（一个记录只存储在一个文件块）4.定长记录5.变长记录6.文件块：记录集合，一个磁盘块7.文件：7.1定义：文件块的集合，对应于一个关系7.2种类：无序文件、有序文件、索引文件、Hash文件无序文件无序文件的查找操作无序文件的插入操作无序文件的删除操作无序文件的修改操作有序文件记录按照某个（或某些）域的值的大小顺序排序，用于排序的域称为排序域有序文件的查找操作若查找操作的条件定义在排序域上，可以使用二分查找，平均时间复杂性为O(logN)；若查找操作的条件定义在非排序域上，排序文件没有提供任何优越性，需要对文件进行顺序搜索，查找时间与无序文件相同有序文件的插入操作有序文件的删除操作可以使用删除标志位和周期整理存储空间的方法实现删除操作有序文件的修改操作7.3文件的存储方法：连续存储方法、链接存储方法、索引存储方法14.Hash文件1.概述用Hash函数来存储和存取关系记录，对文件中每个记录的同一属性或属性集需要计算一个散列函数，散列函数的结果确定了记录应该存储到文件的哪个物理块中2.Hash桶3.如果文件的记录在Hash属性上分布不均匀，可能产生桶溢出问题4.简单Hash方法4.1查找4.2插入4.3删除4.4缺点只能有效地支持在Hash码上具有相等比较的数据操作；由于Hash桶的数量一成不变，当文件记录较少时，将浪费大量存储空间；当文件记录超过一定数量以后，磁盘块链将会很长，影响记录的存取效率5.动态Hash方法6.可扩展Hash方法7.线性Hash方法15.索引文件15.1为了方便实现查询，通常一个关系建立一个或多个索引。索引是一种数据结构，通常是有序文件15.2按结构对索引进行分类1.稀疏索引把所有记录按索引域的值分组，每组一个索引项，这种索引的索引项少，管理方便，但更新代价较高2.稠密索引每个索引域的值对应一个索引项，索引文件有序，查找、更新方便，但索引项多，空间复杂性大15.3多级索引索引文件可以再加索引，乃至建立多级索引15.4按索引域特点分类索引主索引聚集索引辅助索引16.B+树文件索引16.1索引树结构16.2索引树的缺点16.3B+树16.4相关算法17.多维索引17.1问题17.2分类1.类散列表方法网格文件分段散列2.类树方法多键索引kd树四叉树R树 2.查询处理与优化2.0关系代数操作算法算法运行环境：M+1个缓冲区（输入和输出）+外存中存放的数据算法运行代价：磁盘块存取数算法处理能力：能够处理输入关系大小的最大值外存中的MergeSort（归并）建立在外存中的哈希文件2.1选择操作算法2.2投影操作算法2.3连接操作算法0-连接操作算法等值连接操作算法等值连接和自然连接是应用最多的连接操作，两者的操作算法无本质区别自然连接循环嵌套连接(Nest-Loop-Join)算法、排序合并连接(Sort-Merge-Join)算法、Hash-连接算法三种连接算法的小结：2.4集合操作算法输入关系的约束：具有相同的属性集合，并且属性的排序顺序必须也相同实现这些操作的常用算法：首先利用排序算法在相同的键属性上排序两个操作关系；然后扫描这两个排序后的关系，完成并、交或差操作2.5查询优化1.下推选择当查询中涉及视图时，某些情况下：首先将选择操作尽可能往树的上部移动是很重要的，然后再把选择下推到所有可能的分支2.涉及投影的定律3.有关连接与笛卡尔积的定律4.启发式优化的原则5.操作代价的估计逻辑计划可以派生出多个不同物理计划，对每个物理计划进行评价，或估计实现这个转换的代价（称为基于代价的枚举），从中选择具有最小估计代价的物理查询计划。中间结果关系大小的估计用于处理中间关系的磁盘I/O数是描述查询计划代价大小的一个函数由于未经计算，一般难以准确地获得中间关系的元组数。因此，只能通过一些原则，对中间结果关系的大小进行尽可能准确地估计符号：V(R,Y):表示关系R在属性Y上的值域大小6.选择操作结果大小的估计7.并、交、差操作结果大小的估计8.消除重复、分组聚集结果大小的估计9.连接大小的估计10.连接顺序的选择11.选择连接顺序的贪心算法初始化：从最小的关系开始启发式策略：在所有还没有包含在当前树中的关系里，寻找与当前树进行连接能生成估计代价最小的关系. 当前树作为连接的左参数，选中的关系作为右参数来形成新的当前树 3.事务处理与恢复3.1事务概念1.事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位2.事务与程序不同在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句或整个程序一个程序通常包含多个事务3.事务是并发控制和恢复的基本单位4.事务定义4.1显式定义BEGIN TRANSACTION SQL 语句1 SQL 语句2 …. COMMIT事务正常结束，提交事务的所有操作，事务中所有对数据库的更新写回到硬盘BEGIN TRANSACTION SQL 语句1 SQL 语句2 …… ROLLBACK事务异常终止；事务运行的过程中发生了故障，不能继续执行；系统将事务中对数据库的所有已完成的操作全部撤销；事务回滚到开始的状态4.2隐式方式：当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务5.事务的特性(ACID)5.1原子性(Atomicity)：即事务完全执行或完全不执行5.2一致性(Consistency)：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态一致性状态：数据库中只包含成功事务提交的结果不一致性状态：数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态5.3隔离性(Isolation)：表面看起来，每个事务都是在没有其他事务同时执行的情况下执行的一个事务内部的操作及使用的数据对其他并发事务是隔离的并发执行的各个事务之间不能互相干扰5.4持久性(Durability)：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的接下来的其他操作或故障不应该对其执行结果有任何影响6.保证事务ACID特性是事务处理的任务7.破坏事务ACID特性的因素7.1多个事务并行运行时，不同事务的操作交叉运行数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性7.2事务在运行过程中被强行停止数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响8.事务调用以下两个操作访问数据8.1Read(X)：从数据库把数据项X传送到事务的局部缓冲区8.2Write(X)：从事务的局部缓冲区把数据项X传回数据库3.2事务的并发执行和调度1.多用户数据库系统：允许多个用户同时使用的数据库系统特点：在同一时刻并发运行的事务数可达数千或万个2.事务执行的方式2.1串行执行每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行不能充分利用系统资源，发挥数据库共享资源的特点2.2交叉并发方式在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率2.3同时并发方式多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行最理想的并发方式，但受制于硬件环境3.事务并发执行带来的问题：3.1会产生多个事务同时存取同一个数据的情况3.2可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性4.DBMS必须提供并发控制机制，并发控制机制是衡量一个DBMS性能的重要标志之一5.并发操作带来的数据不一致性问题5.1丢失修改(Lost Update)5.2不可重复读(Non-repeatable Read)：指事务1读取数据后，事务2执行更新操作，使1无法再现前一次读取结果5.3读“脏”数据(Dirty Read)6.事务的调度6.1一个或多个事务的重要操作按时间排序的一个序列6.2READ/WRITE序列7.串行调度如果一个调度S的动作组成首先是一个事务的所有动作，然后是另一个事务的所有动作，依次类推、没有动作的混合，那么我们称S是串行的更精确地讲，如果有任意两个事务T和T’，若T的某个动作在T’的某个动作前，则T的所有动作在T’的所有动作前，那么调度S是串行的串行调度是正确的，然而串行调度使系统资源的利用率不高8.可串行化调度如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则我们称这个调度是可串行化的9.可串行性(Serializability)是并发事务正确调度的准则一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度10.事务和调度的一种记法11.冲突调度中一对连续的动作它们满足：如果它们的顺序交换，那么涉及的事务中至少有一个行为会改变不同事务的任何两个动作在顺序上可以交换，除非：它们涉及同一数据库元素，并且至少有一个动作是写12.冲突等价我们说两个调度是冲突等价的，如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另一个13.冲突可串行化如果一个调度冲突等价于一个串行调度，那么我们说该调度是冲突可串行化的一个调度若是冲突可串行化的，则一定是可串行化的调度14.优先图15.冲突可串行判断构造调度S的优先图，判断其中是否有环冲突可串行化调度是可串行化调度的充分条件，不是必要条件存在不满足冲突可串行化条件的可串行化调度3.3并发控制协议1.锁的概念锁是数据库元素上的并发控制标志锁的类型有很多，考虑两种：1)共享锁(S)：如果事务T得到了数据库元素Q上的共享锁S，则T可以读Q，但不能写Q2)排他锁(X)（也称互斥锁）：如果事务T得到了数据库元素Q上的排他锁X，则T既可以读Q，也可以写Q多粒度的锁：上锁的数据库元素可以是关系表、磁盘块、元组每个事务在存取一个数据库元素之前必须获得这个数据库元素上的锁一个事务需要获得的锁的类型依赖于它将在数据库元素上执行什么样的操作给定一个各种类型锁的集合，如下定义这个锁集合上的相容关系事务通过执行LOCK-S(Q)操作申请数据库元素Q上的共享锁事务通过执行LOCK-X(Q)操作申请数据库元素Q上的排他锁UNLOCK(Q)操作用来释放Q上的锁若事务T要存取数据库元素Q，T必须申请在Q上加锁。若Q已经被其他的事务加以非共享锁，则事务T必须等待，直到所有其他事务的非共享锁全部被释放事务T可以释放它在任何数据库元素上所加的任何类型的锁一个事务只要存取一个数据库元素，它就必须持有该数据库元素上的一个锁如果一个事务完成了对一个数据库元素的最后一次存取之后就立即放弃它的锁，则不能确保调度的可串行性2.两阶段锁协议两阶段锁协议要求每个事务分两个阶段进行数据元素的加锁和解锁1)加锁阶段：在这个阶段，事务可以申请获得任何数据库元素上的任何类型的锁，但是不能释放任何锁2)解锁阶段：在这个阶段，事务可以释放任何数据库元素上的任何类型的锁，但是不能再申请任何锁每个事务开始运行后即进入加锁阶段，申请获得所需要的锁当一个事务第一次释放锁时，该事务进入解锁阶段。进入解锁阶段的事务不能再申请任何锁任何一个满足两阶段锁协议的合理调度都是冲突可串行的3.数据库图协议另一种基于锁的并发控制协议数据库图一个简单的数据库图协议：树协议树协议不但可以保证调度是冲突可行的，而且保证无死锁4.基于时间戳的协议时间戳协议不但可以保证调度是冲突可串行的，而且保证无死锁5.对比时间戳和锁的协议6.死锁处理在数据库系统运行期间，如果存在一组事务{T0,T1,…Tn}，使得T0等待T1持有的数据库元素锁，T1等待T2持有的锁，，，Tn等待T0持有的锁，则称系统处于死锁状态解决死锁：预防死锁，使用预防死锁协议，如数据库图协议、时间戳协议等；死锁的检测于恢复7.死锁检测8.死锁恢复3.4日志与故障恢复1.数据库恢复数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策2.恢复子系统是数据库管理系统的一个重要组成部分3.恢复技术是衡量系统优劣的重要指标4.故障种类4.1介质故障（硬故障）4.2系统故障（软故障）故障表现：整个系统的正常运行突然被破坏，所有正在运行的事务都非正常终止，不破坏数据库，内存中数据库缓冲区的信息全部丢失常见原因：特定类型的硬件错误（如CPU故障），操作系统故障，DBMS代码错误，系统断电系统故障恢复：4.3事务故障事务故障分类：1)可预期的事务故障：可以通过事务程序本身发现2)更多的是非预期的，不能由应用程序处理：运算溢出，并发事务发生死锁而被选中撤销该事务，违反了某些完整性限制等（如输入某一位数是错的）后面的事务故障仅指这类非预期的故障4.4计算机病毒：不仅涉及数据库技术5.数据库恢复的关键问题：如何建立冗余数据：数据转存(backup)、日志文件(logging)如何利用这些冗余数据实施数据库恢复6.基于日志的恢复6.1日志文件：是日志记录的一个序列，用于记载数据库事务对数据库的更新操作情况6.2日志记录的格式6.3日志用途：进行事务故障恢复，进行系统故障恢复，协助后备副本进行介质故障恢复6.4为保证数据库是可恢复，日志文件必须遵循两条原则：次序严格按并行事务执行的时间次序；必须先写日志文件，后写数据库7.日志缓冲技术通常一个日志记录远远小于永久性存储器的读写单位经常向永久存储器写单个日志记录将导致很大的系统开销对日志记录的读写操作使用缓冲技术：1)主存中设立缓冲区，其大小等于永久性存储器的读写单位2)被写的日志记录先存储到缓冲区，缓冲区满之后再一起写入永久性存储器缓冲区中的日志记录在系统发生故障时会丢失为了保证事务的原子性，数据库恢复协议需遵循如下规则：8.数据库缓冲区技术9.基于日志的数据库恢复技术9.1推迟更新技术推迟更新协议：每个事务在提交之前不能更新数据库；在一个事务所有更新操作对应的日志记录写入永久性存储器之前，该事务不能提交每个事务在到达提交点之前不能更新数据库在一个事务的所有更新操作对应的日志记录写入永久性存储器之前，该事务不能到达提交点9.2即时更新技术即使更新：允许事务直接更新数据库处于活动状态的事务直接在数据库上实施的更新称为非提交更新即使更新协议：在一个事务的所有更新操作对应的日志记录写入永久存储器之前，事务不能更新数据库；在一个事务的所有更新操作对应的日志记录写入永久存储器之前，事务不允许提交10.具有检查点的恢复当系统故障发生后，数据库恢复机制必须搜索日志，确定那些日志需要redo，那些事务需要undo11.数据库镜像","path":"2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/","date":"06-01","excerpt":"","tags":[{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"}]},{"title":"《算法设计与分析》课程笔记","text":"一、绪论1.算法在计算机科学中扮演的角色1.解决一个计算问题的过程：可计算理论-&gt;计算复杂性理论-&gt;算法设计与分析-&gt;数据结构与程序设计-&gt;编译、OS等2.可计算理论：计算模型（图灵机、递归函数、正则算法、POST系统）、（不可）可计算问题、计算模型的等价性–图灵Church命题（所有合理的计算模型，其计算能力是等价的）3.计算复杂性理论：在给定的计算模型下研究问题的复杂性（固有复杂性、复杂性上下界、平均复杂性、复杂性问题的分类（P=NP?）、公理复杂性理论：抽象复杂性研究）4.算法设计和分析：解决可计算问题的算法的设计与分析，设计算法的理论、方法和技术，分析算法的理论、方法和技术5.计算机软件：系统软件、工具软件、应用软件 2.算法概念1.计算：可由一个给定计算模型机械地执行的规则或计算步骤序列称为该计算模型的一个计算1.1一个计算机程序是一个计算（计算模型是计算机）1.2计算可能永远不停止—不是算法2算法：算法是一个满足下列条件的计算：2.1终止性：有限步内必须停止（有穷性）2.2确定性：每步都是严格定义和确定的动作2.3能行性：每个动作都能被精确地机械执行2.4输入：具有满足给定约束条件的输入2.5输出：产生满足给定约束条件的结果3.问题：设Input和Output是两个集合。一个问题是一个关系P包含于Input*Output，Input称为问题P的输入集合，Input的每个元素称为P的一个输入，Output称为问题P的输出或结果集合，Output的每个元素称为P的一个结果4.问题实例：问题P的一个实例是P中的一个二元组4.1问题是一个二元组集合，问题实例是一个二元组4.2一个算法求解一个完整的问题，而不是仅求解一个问题的一个或几个实例 3.算法分析1.算法正确性：一个算法是正确的，如果它对于每个输入都最终停止，而且产生正确的输出2.不正确算法：在一个或多个输入上不停止，对所有输入都停止，但对一个或多个输入产生不正确结果3.近似算法/随机算法的正确性：对所有输入都停止，产生近似正确的解/产生不多的不正确解4.程序调试只能证明程序有错，不能证明程序无错误5.算法的复杂性分析：5.1目的：分析算法对不同输入所需资源量5.2复杂性测试：时间、空间、I/O等；是输入大小的函数5.3用途：为求解一个问题选择最佳算法、最佳设备5.4需要的数学基础：离散数学、组合数学、概率论、代数5.5需要的数学能力：建立算法复杂性的数学模型，数学模型化简6.输入的大小：设Input是问题P的输入集合，P的输入大小是一个函数F：Input-&gt;N，N是正整数集合6.1size(a)表示输入a属于Input的大小7.实例时间复杂性：一个算法对特定输入的时间复杂性是该算法对该输入产生结果需要的原子操作数7.1时间复杂性是输入大小的函数T(n)7.2我们假设每一步的执行需要常数时间，实际上每步需要的时间量可能不同8.实例空间复杂性：一个算法对特定输入的空间复杂性是该算法对该输入产生结果所需要的存储空间大小8.1空间复杂度是输入大小的函数S(n)9.算法最坏复杂性：设Input是问题P的输入集合，Complexity(Size(x))是求解P的实例x的算法A的复杂性函数，A的最坏复杂性是Max{Complexity(size(x))|x属于Input}10.算法最小复杂性：Min{Complexity(size(x))|x属于Input}11.算法平均复杂性：设x属于Input，x作为算法A的输入出现的概率是px，A的平均复杂性为：px*Complexity(size(x))对所有x的累和12.随机访问模型（RAM）：单处理机，串行执行，无并发；基本数据类型；基本操作：算数、数据移动、控制13.时间复杂性分析并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快14.算法得正确性分析：14.1循环不变量方法：主要结构为循环的算法正确性证明的通用方法14.2主要步骤：确定循环不变量，判断循环初始、循环步骤和循环终止时P的成立14.3循环不变量可以理解为每次循环需要达到的目的 二、算法分析的数学基础1.计算复杂性函数的阶1.同阶函数（紧界）2.低阶函数3.高阶函数4.如果f(n)=O(n^k)，则称f(n)是多项式界限的5.极少用高阶函数来描述算法的运行时间和复杂性（算法追求时间短，一定用已知上届函数）6.严格低阶函数（任意c，不等）6.1O可能紧，o必定不紧6.2某个正常数c在O标记中，但所有正常数c在o标记中7.严格高阶函数8.函数阶的性质：传递性、自反性、对称性、反对称性9.数学公式中的函数阶，独立地表示一个匿名函数；等号左侧和右侧都出现函数的阶，表示无论如何选择等号左侧的匿名函数，都存在一个等号右侧匿名函数的选择方法，使得公式中的等号成立 2.和式的计算与估计1.线性和2.级数3.直接求和的界限 3.递归方程1.递归方程是使用具有较小输入值的相同方程来描述一个方程（用自身来定义自身）2.求解递归方程的三个主要方法：2.1替换方法：先猜测方程的解，然后用数学归纳法证明（替换变量，根据已知结果猜测）2.2迭代方法：把方程转化为一个和式，然后用估计和的方法来求解2.3Master方法：求解型为T(n)=aT(n/b)+f(n)的递归方程(将大小为n的问题分成大小为n/b的a个子问题，递归地求解这些子问题，然后用所得到的子问题的解以f(n)的代价求解原始问题)3.针对替换方法的细节处理：猜测正确却归纳错误，可以尝试从猜测函数中减去一个低阶项4.Master定理：5.Master解决例题：6.扩展Master定理： 三、排序与分治算法1.分治算法的原理1.分治算法的设计过程：Divide（划分子问题）-&gt;Conquer（求解各子问题，递归调用算法）-&gt;Combine（合并子问题的解，形成原始问题的解）2.分治算法的分析过程：建立递归方程-&gt;求解3.递归方程的建立方法：3.1设输入大小为n，T(n)为时间复杂性3.2当n&lt;c，T(n)=$(1)（c为常数，$(1)是1的同阶函数集）3.3Divide阶段的时间复杂性计算：划分a个子问题，每个问题大小为n/b，划分问题花费时间大小D(n)3.4Conquer阶段的时间复杂性计算：递归调用，解决每个子问题时间=aT(n/b)3.5Combine阶段的时间复杂性计算：结合结果时间消耗C(n)3.6得到递归方程：当n&lt;=c时，T(n)=$(1)；当n&gt;c时，T(n)=aT(n/b)+D(n)+C(n)3.7T(n)=aT(n/b)+D(n)+C(n)中每个组成元素都能尝试优化 2.基于分治思想的排序算法1.划分子序列的策略：根据某一策略将数据集合划分成两个部分（Mergesort：中间点；Quicksort：任选一个划分点，根据这个点将数据划分成两部分）2.合并策略：不同的划分策略对应不同的合并策略3.主要结构是循环结构的算法正确性证明方法：循环不变量方法3.1循环不变量：数据或数据结构的关键性质（依赖于具体的算法和算法特点）3.2三个阶段：初始阶段（循环开始前循环不变量成立）-&gt;循环阶段（循环体每次执行，循环不变量成立）-&gt;终止阶段（算法结束后，循环不变量保证算法正确）4.问题的下界：用于解决该问题的任意算法所需要的最小时间复杂度（通常情况下指代最坏情况下届），问题的下界不唯一（但只有最高的有意义）5.如果一个问题的下界与算法的时间复杂性相同，那么这个算法是最优的6.通常，基本操作是比较和交换的排序算法可以用一个二叉决策树描述6.1通过忽略比较以外的细节来抽象表示比较排序算法6.2每个内节点表示一个比较操作6.3所有被排序元素的全排序是树的叶节点6.4对于特定输入数据集的排序过程，对应于从树的根节点到叶子节点的一条路径6.5设树高度为h，则2^h&gt;=n!（最多2^h个叶子节点）7.排序的下界是nlogn的高阶函数集 3.Decrease and Conquer原理1.分治算法与减治算法：前者要递归求解每一个子问题，然后通过合并各个子问题的解最后得到原始问题的解；后者仅需要求解某一个子问题的解得到原始问题的解2.减治算法：原始问题划分为若干个子问题，将原始问题转化为其中某一个子问题的计算问题3.减治算法通常用于解决优化问题 四、动态规划算法1.关于分治算法：如果子问题不是相互独立的，分支方法将重复计算公共子问题，效率很低2.优化问题2.1问题可能有很多解，每个可能的解都对应一个代价2.2优化问题是要在该问题所有可能的解中找到一个最优解2.3一个问题的最优解不一定唯一2.4优化问题就是给定一个代价函数，在问题的解空间中搜索具有最小或最大代价的优化解3.动态规划是解决优化问题的一种常见方法3.1把原始问题划分成一系列子问题（不同子问题的数目常常只有多项式量级）3.2求解每个子问题记一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间3.3自底向上地求解子问题4.使用动态规划的条件：4.1优化子结构（一个问题的优化解包含了子问题的优化解）4.2重叠子问题（在问题求解过程中，很多子问题的解将被多次使用）5.动态规划算法的设计步骤：分析优化解的结构；递归地定义最优解的代价；递归地划分子问题，直至不可分；自底向上地求解各个子问题，计算优化解的代价并保存之，获取构造最优解的信息；根据构造最优解的信息构造优化解 五、贪心算法1.贪心算法的基本思想：求解最优化问题的算法包含一系列步骤，每一步都有一组选择，作出在当前看来最好的选择，希望通过作出局部优化选择达到全局优化选择2.贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解，在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似3.Greedy算法产生优化解的条件3.1优化子结构：若一个优化问题的优化解包含它的子问题的优化解，则称其具有优化子结构3.2Greedy选择性：一个优化问题的全局优化解可以通过局部优化选择得到4.Greedy选择性的证明：归纳法（每一步都比其他算法好），交换论证法（在保证最优性不变前提下，从一个最优解逐步替换，最终得到贪心算法的解）（证明贪心算法一定能够找到一个至少与其他最优解一样的解，贪心选择性做出的选择至少包含一个优化解中）5.Greedy算法的设计步骤：5.1设计贪心选择方法：贪心选择方法，剩余子问题5.2证明：对于1中贪心选择来说，所求解的问题具有优化子结构5.3证明：对于1中贪心选择来说，所求解的问题具有Greedy选择性5.4按照1中设计的贪心选择方法设计算法6.归纳法证明方式总结：6.1一般要证明3个命题，首先证明贪心选择包含在某个优化解中，其次证明问题具有优化子结构，最后证明贪心选择方法具有Greedy选择性6.2整个过程与归纳法极为相似，第一个命题相当于证明n=1成立，第二个命题辅助证明n=i-1转化到n=i成立条件，第三个命题相当于证明数学归纳法。最后注意贪心算法是自顶向下的算法6.3引理一：证明某个优化解包括自己用贪心策略选出的第一个活动（通过证明合理性论证）6.3引理二（具有优化子结构）：证明包括活动1的一个优化解去除活动1后是更新的活动集合对应问题的优化解（通过优化解的最大型反证）6.3引理三：证明按照自己贪心策略选出的活动集合为问题的一个优化解（通过引理一二和归纳假设证明，归纳假设m-1存在（不包括活动1问题的最优解存在），引理二组合只包括活动1问题的最优解与不包括活动1问题的最优解）7.交换论证法证明方式总结：7.1在保证最优性不变的前提下，从一个最优解逐步替换，最终得到贪心算法的解7.2证明贪心算法一定能够找到一个至少与其他最优解一样优化的解，并且贪心选择性做出的选择至少包含于一个优化解中 六、平摊分析1.平摊分析基本原理1.平摊分析目的：分析给定数据结构上的n个操作代价上界，将总的代价平摊到每个操作上2.平摊分析(Amortized Analysis)的3种方法:2.1聚集(Aggregate Analysis)方法：确定n个操作的上界T(n)，每个操作平摊T(n)/n2.2会计(Accounting)方法：不同类型操作赋予不同的平摊代价，某些操作在数据结构的特殊对象上“预付”代价2.3势能(Potential)方法：不同类型操作赋予不同的平摊代价，“预付”的代价作为整个数据结构的“能量” 2.聚集方法1.目的：分析n个操作系列中每个操作的复杂性上界2.思想：根据最坏情况得到所有步骤的代价和T(n)，每个操作被赋予相同代价，得到平摊代价T(n)/n 3.会计方法1.目的：分析n个操作序列的复杂性上界，一个操作序列中有不同类型的操作，不同类型操作的代价各不相同2.思想：为每种操作分配不同的平摊代价。平摊代价可能比实际代价大，也可能比实际代价小；如果平摊代价比实际代价高：一部分用于支付实际代价，多余部分作为Credit附加在数据结构的具体数据对象上；当一个操作的平摊代价比实际代价低时，Credit用来补充支付实际代价3.平摊代价的选择规则：4.理解：针对证明n次代价O(n)的试题，需要找到一个必经过程，并且赋予过程代价（一般是常数，并且与其他代价相比较大），来使整个过程的这一常数代价过程最多，最终得到O(n)。例如：二进制计数器的0-&gt;1-&gt;0过程；数据-&gt;缓存栈-&gt;输出栈-&gt;输出；数据由底层随着高层输出而使层数变高，最终输出 4.势能方法1.目的：分析n个操作系列的复杂性上界2.思想：在会计方法中，如果操作的平摊代价比实际代价大，我们将余额与数据结构的数据对象相关联，此方法把Credit余额与整个数据结构关联，所有这样的余额之和，构成数据结构的势能如果操作的平摊代价大于操作的实际代价，势能增加如果操作的平摊代价小于操作的实际代价，要用数据结构的势能来支付实际代价，势能减少 5.动态表性能平摊分析1.动态表的数据结构：用一个(一组)数组来实现动态表2.虽然插入和删除操作可能会引起表的扩张和收缩，从而具有较高的实际代价。但是，利用平摊分析能够证明，插入和删除操作的平摊代价为O(1)。同时保证动态表中未用的空间始终不超过整个空间的一部分3.动态表的扩张：3.1插入一个数组元素时,完成的操作包括：分配一个比原表包含更多的槽的新表，再将原表中的各项复制到新表中去3.2常用的启发式技术是分配一个比原表大一倍的新表，只对表执行插入操作,则表的装载因子总是至少为1/2 ，浪费掉的空间就始终不会超过表总空间的一半4.动态表的收缩：4.1当动态表的装载因子很小时，对表进行收缩理想情况下，我们希望：表具有一定的丰满度，表的操作序列的复杂度是线性的4.2表的收缩策略：4.3改进的收缩策略（允许装载因子低于1/2）：满表中插入数据项时，将表扩大一倍；删除数据项引起表不足1/4满时，将表缩小为原表的一半；扩张和收缩过程都使得表的装载因子变为1/2；表的装载因子的下界是1/4 七、树搜索1.数搜索的应用场景1.很多问题的解可以表示成为树，解为树的节点或路径，求解这些问题可以转化为树搜索问题2.问题的定义：2.1输入：n个布尔变量x1,x2,…,xn关于x1,x2,…,xn的k个析取式2.2输出：是否存在x1,x2,…,xn的一种赋值使得所有k个析取式皆为真3.处理方式：把问题的解表示为树，通过不断地为赋值集合分类来建立树（根节点-&gt;根据x1的取值建立第一层-&gt;根据x2的取值建立第二层-&gt;…-&gt;叶子节点创建），问题的解是由根到叶的一条路径 2.理想的树搜索策略1.爬山策略：使用贪心方法确定搜索的方向，是优化的深度优先搜索策略（使用启发式测度来排序节点扩展的顺序）2.最佳优先搜索策略（最少代价优先）：根据一个评价函数，在目前产生的所有节点中选择具有最小评价函数值的节点进行扩展（具有全局优化观念，而爬山策略仅具有局部优化观念）3.分支界限策略：迅速找到一个可行解，将该可行解作为优化解的一个界限，利用界限裁剪解空间，提高求解的效率（相比与上述方法，此方法可以更有效地求解组合优化问题） 八、图算法1.网络流算法1.流网络：一个无自环的有向图G=(V,E)1.1图中的每条边(u,v)属于E有一个非负的容量值c(u,v)(&gt;=0)，若(u,v)不属于E，c(u,v)=01.2有两个特殊结点s,t属于V，s称为源结点(source)，t称为汇点(sink)1.3对于任意结点v属于V，存在一个s到t的路径s-&gt;v-&gt;t1.4流网络是连通的1.5除源结点外，每个结点都至少有一条进入的边，所以|E|&gt;=|V|-12.流：对于1.1中定义的流网络（c为容量函数），定义G中的流是一个实值函数f: V*V-&gt;R，满足下列属性：2.1容量约束：任意u,v属于V，有0&lt;=f(u,v)&lt;=c(u,v)2.2流量守恒：任意u属于V-{s,t}，有所有v属于V的f(v,u)和=所有v属于V的f(u,v)和称f(u,v)为从结点u到结点v的流一个流f的值|f|定义为所有v属于V的f(s,v)和3.只需讨论单源单汇的网络流4.一些假设5.最大流问题：5.1输入：流网络G=(V,E)5.2输出：具有最大流值的流f6.直观想法：6.1循环递进6.2关键在于如何找到路径p，以便得到更大的流，以及如何判断循环结束的条件（无法找到更大的流也就无法找到最大流） 2.Ford-Fulkerson方法1.在一个关联的剩余网络中寻找一条增广路径2.剩余网络：3.剩余网络类似于一个容量为cf的流网络，但包含反向边4.也可以把流网络G看成是一个当前流f=0的剩余网络5.可以在剩余网络中定义一个流6.设f’是剩余网络Gf中的流，f’同样满足容量限制和流量守恒，f’也有大小7.引理：给定流网络G(V,E)和其中的流f，流f’是剩余网络Gf中的流，则通过f’提升f可以得到如下的流：8.增广路径：剩余网络中的由源结点s到汇点t的一条路径p9.增广路径p的剩余容量：10.FF算法的核心是：通过增广路径不断增加路径上的流量，直到找到一个最大流为止（如何判断算法结束时确实找到最大流）11.流网络的割：12.引理：设f为流网络G的一个流，该流网络的源结点为s，汇点为t，设(S,T)为流网络G的任意一个割，则横跨割(S,T)的净流量为|f|13.推论：流网络G中任意流的值不能超过G的任意割的容量14.一个流网络的最小割是指：整个网络中容量最小的割15.Max-Min关系：16.对同一问题从不同角度考虑，有两种对立的描述17.利用Max-Min关系求解最大流问题18.Ford-Fulkerson算法：正确性分析：1)算法输出的一定是最大流（最大流-最小割定理）2)算法可终止性（假设整数容量，每次流量增加1） 3.Edmonds-Karp算法1.加速增广路径的寻找1.1最短增广路径算法：始终沿着Gf中具有最少边的路径进行增广1.2最大增广路径算法：始终沿着Gf中具有最大容量的路径进行增广2.算法内容：3.引理：如果Edmonds-Karp算法运行在流网络G(V,E)上，该网络的源结点为s，汇点为t，则对于所有的结点v属于V-{s,t}，剩余网络Gf中的最短路径距离gf(s,v)随着每次流量的递增而单调递增4.定理：若Edmonds-Karp算法运行在流网络G(V,E)上，该网络的源结点为s，汇点为t，则算法所执行的流量递增操作的总次数为O(VE) 4.单源最短路径问题1.问题定义：1.1输入：给定一个带权的有向连通图G(V,E)和权重函数W:E-&gt;{实数}，源点s1.2输出：对于任意v属于V，由s到v的权值最小路径，即最短路径2.最短路径树2.1一棵有根结点的树，包括了从源结点s到每个可以从s到达的结点的一条最短路径2.2最短路径不是唯一的，最短路径树也不是唯一的3.优化子结构：最短路径包含最短子路径说明：该问题可以用贪心或动态规划方法来解4.最短路径权重满足三角不等式性质5.最短路径的相关问题6.最短路径的核心技术 5.Bellman-Ford算法1.针对一般情况下的单源最短路径问题2.算法3.正确性证明：4.DAG中单源最短路径5.Dijikstra算法","path":"2022/05/22/suan-fa-she-ji-yu-fen-xi-ke-cheng-bi-ji/","date":"05-22","excerpt":"","tags":[{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"}]},{"title":"《运筹学与最优化方法》笔记","text":"一、绪论1.运筹学与优化问题简介1.运筹学定义：1.1《大英百科全书》：运筹学是一门应用于管理有组织系统的科学，为掌管这类系统的人提供决策目标和数量分析的工具1.2《中国大百科全书》：运筹学是数学方法研究经济、民政和国防等部门在内外环境的约束条件下合理分配人力、物力、财力等资源，使实际系统有效运行的技术科学，它可以用来预测发展趋势，制订行动规划或优选可行方案1.3运筹学是应用数学的一个分支，主要是将生产、生活、管理、军事等现实世界中的普遍性问题加以提炼形成数学模型然后利用优化方法进行求解2.最优化问题：2.1最优化问题是决策问题，选择一些可以执行的策略使目标最优2.2最优化问题的组成：决策变量；一个或多个目标函数；一个由可行策略组成的集合，可由等式或不等式描述（约束条件）2.3最优化问题的基本组成： 2.最优化问题分类与建模1.无约束优化（没有约束条件）与约束优化（含约束条件）2.线性规划（高中学习内容）与非线性规划（举例：均值方差模型）3.连续优化与离散优化（可行集中的点是离散点）4.单目标优化与多目标优化（多个目标函数，通常通过变换将多目标转换为单目标）5.确定性优化（约束条件中常数值固定）、随机优化（约束条件中常数值不确定，是随机变量）与鲁棒优化（约束条件中常数值取自某一特定集合或区间）6.建模：根据实际情况写出目标函数与约束条件 二、凸集与凸优化问题0.引子1.凸优化问题形式：min f(x)；s.t. gi(x)&lt;=0,i=0,…,m；hi(x)=0,j=1,…l1.0f是凸函数，可行集为凸集合2.特性：凸优化问题的任意局部最优解就是一个全局最优解3.局部最优解：指对于一个问题的解在一定范围或区域内最优，或者说解决问题或达成目标的手段在一定范围或限制内最优4.全局最优解：指针对一定条件或环境下的一个问题或目标，若一项决策和所有解决该问题的决策相比是最优的 1.基本概念和符号1.向量和子空间投影定理1.1n维欧氏空间（Rn），点（向量）（x属于Rn，x=(x1,x2,…,xn)T，分量xi属于实数集），方向（自由向量）（d属于Rn，d！=0，d表示从0指向d的方向），实际应用中，常用x+ad表示从x点出发沿d方向移动ad长度得到的点1.2向量运算（xy内积，xy距离，x长度，三角不等式）（点列{x^k}包含于Rn，x属于Rn，点列收敛于x，记为lim(k-&gt;∞)x^k=x &lt;=&gt; lim(x^k到x的距离)=0 &lt;=&gt; lim(xi^k)=xi）1.3子空间（由向量生成的子空间，简记为L），正交子空间（L’中向量与L中向量正交），子空间投影定理（参考平面xy轴）1.4规定子空间中向量比较大小的方式：x&lt;y &lt;=&gt; xi&lt;yi,针对任意i成立2.多元函数及其导数 2.凸集的定义1.凸集：对任何x，y属于C，线段xy上的点都在C内部，则C为凸集2.凸组合：x1,x2,…,xn的凸组合为y1x1+…,ynxn,其中y1,…,yn均大于0，且和为13.凸包：C的凸包指由C中点的凸组合构成（凸包可以将非凸优化转换为凸优化问题） 3.常见凸集 4.保持凸性的运算1.集合的交集运算，加减运算2.仿射变换 5.凸集合的性质1.投影定理2.分割超平面定理3.支撑超平面定理 6.凸函数的定义1.凸函数：设C是非空凸集，f是定义在C上的函数，如果对于任意的x，y属于C和a属于[0,1]，均有f(ax+(1-a)y)&lt;=af(x)+(1-a)f(y)，则称f为C上的凸函数2.凹函数：凸函数定义中不等式符号相反3.严格凸（x!=y,0&lt;a&lt;1,f(…)&lt;…）4.强凸： 7.常见凸函数 8.凸函数的性质 9.保持凸性的操作 10.凸集与凸函数的关系1.函数f(x)的水平集：La={x|f(x)&lt;a,x属于C}2.f(x)是凸函数，则其水平集都是凸集3.函数f(x)的上镜图epi(f)={(x y)T|f(x)&lt;=y,x属于C}4.f(x)是凸函数&lt;=&gt;epi为凸集 11.凸优化问题 12.几种特殊凸优化问题的最优性条件 13.常见凸优化问题的类型0.线性规划、二次规划、带二次规划的二次规划、二阶锥规划，半定规划、几何规划 三、无约束优化问题1.无约束优化问题的最优化条件 2.迭代算法1.迭代算法的基本思想：1.1利用无约束优化问题的最优性条件求解无约束优化问题困难很多，如：导数不存在、计算麻烦1.2无约束优化问题一般采用数值计算的迭代方法1.3迭代方法的基本思想：给定初始点，产生点列{xk}，并且点列满足条件f(x(k+1))&lt;f(xk)1.4关键问题：如何从当前点迭代到下一点1.5两种策略：线搜索方法和信赖域方法2.迭代算法的一般步骤：2.1给定初始点x0，k=02.2判断xk是否满足终止条件：是，结束；不是，进行下一步2.3寻找xk处的下降方向dk2.4选择合适的步长ak&gt;0，使f(xk+ak*dk)&lt;f(xk)成立2.5令x(k+1)=xk+ak*dk，且k=k+1，转2.23.总共两个问题：寻找合适的步长a与寻找下降方向d两个核心问题 3.一维搜索（线搜索）1.dk方向上的任何一点可以表示为x(k+1)=xk+ak*dk，其中ak是步长因子，是实数。dk方向上的任何一点的函数值可表示为f(xk+ak*dk)，是参数ak的一元函数。沿dk方向求f(x)的极小点就转化为ak’:min f(xk+ak*dk)，求解最优步长ak的过程就是线索搜过程，也叫一维搜索过程2.求解一元函数O(a)=f(x+ad)的极小点a’，采用解析法，即利用一元函数的最优条件O’(a)=0，求a注意：O(a)是以步长a为自变量的函数，而不是以变量x为自变量的函数3.解析解法：4.解析解法缺点：需要求导，对于函数关系复杂、求导困难或无法求导的情况，使用解析解法不合适5.线搜索数值解法：利用计算机反复迭代求最佳步长因子a’的近似值5.区间探索法一般为两步：5.1确定一维函数极小点再内的单谷区间作为初始搜索区间[a,b]的方向，如进退探索法5.2在单谷区间[a,b]内，通过缩小区间寻找极小点的方法，如黄金分隔法在给定区间内仅有一个谷值即唯一极小值点的函数称为单谷函数，其区间为单谷区间6.进退探索法6.1目的：确定O(a)=f(x+ad)极小点a’所在区间[a,b]6.2思路：从一点出发，按照一定的步长，试图确定函数值呈现“高-低-高”的3点。沿着搜索方向若不成功就退回来，再沿相反方向探索，若探索成功，则加大步长进行探索，最终找到a1,a2,a33点，满足a1&lt;a2&lt;a3,O(a1)&gt;O(a2)&lt;O(a3)为止6.3进一步缩小搜索空间：再大间隔中添加一个点，找到最小的点左右临点作为新区间7.黄金分割法7.1黄金分割法适用于[a,b]（可由进退探索法得到）区间上的任何单谷函数求极小值问题7.2单谷函数与单谷区间的性质：若O(x)是单谷区间[a,b]上的单谷函数，极小点为x’，在[a,b]中任取两点[a1,b1]，且a1&lt;b1，则：1)当O(a1)&lt;O(b1)时，x’属于[a,b1]2)当O(a1)&gt;O(b1)时，x’属于[a1,b]3)当O(a1)=O(b1)时，x’属于[a1,b1]7.3黄金分割法对插入点的要求：1)要求插入点a1,b1的位置相对于区间[a,b]两端点具有对称性，即a1=b-x*(b-a)b1=a+x*(b-a)x为待定参数2)要求在保留下来的区间内再插入一点所形成的新的三段区间与原区间的三段具有相同的比例分布7.4黄金分割法的搜索过程：1)给出初始搜索区间[a,b]及收敛精度c，设步长y=0.6182)按照坐标点计算公式计算a1,b1并计算其对应的函数值O(a1),O(b1)3)根据单谷函数的性质缩短搜索区间4)检查探索区间是否足够小以及函数值收敛到足够精度，如果收敛条件满足，则取最后两插入点的平均值作为极小点的数值近似解，如果条件不满足则转3)8.函数逼近法的主要思想：在极小点附近用近似表达式取代目标函数O(a)，从而求出O(a)的极小点的估计值牛顿法是采用二阶泰勒多项式近似取代目标函数O(a)抛物线法是采用二次三项式近似取代目标函数O(a)9.牛顿法9.1假定极小点的近似点为a0，在a0点将O(a0)作二阶泰勒展开，忽略高阶项得到U(a)=O(a0)+O'(a0)(a-a0)+(1/2)O''(a0)(a-a0)^2在a0处可用U(a)近似O(a)，然后用U(a)的极小点作为O(a)极小点的近似a1，根据无约束优化问题的极值必要条件得：U’(a)=0=&gt;a(k+1)=ak-O’(ak)/O’’(ak)(k=0,1,…,)9.2牛顿法得几何解释：9.3牛顿法的计算步骤：1)给定初始点a0，控制误差c，并令k=02)计算O’(ak)，O’’(ak)3)求a(k+1)=ak-O’(ak)/O’’(ak)4)若|a(k+1)-ak|&lt;=c，则求得近似解a’=a(k+1)，结束；否则转5)5)令k=k+1，转2)9.4牛顿法的特点：优点：收敛速度快缺点：每一点都要求二阶导数，工作量大，要求初始点离极小点不太远，否则可能使极小化发散或收敛到非极小点10.抛物线法（二次插值法）10.1基本思想：极小点近似点附近3个不同点的函数值构成一个与原函数O(a)近似的二次多项式U(a)，以函数U(a)的极小值点作为目标函数O(a)的近似极值点10.2公式计算：最后得到O(a)极小值a’的近似解ai10.3最后判断ai1)如果区间长度|a3-a1|足够小，则由|ai-a’|&lt;|a3-a1|，得出近似极小点a’~=ai2)如果区间长度|a3-a1|不足够小，必须根据单谷函数得性质收缩区间[a1,a3]3)依据单谷函数性质，需要已知区间内两点的函数值，类似黄金分割法7.211.区间试探法和函数逼近法的比较11.1区间试探法中试探点位置是由某种给定的规律确定的，它不考虑函数值的分布。函数逼近法中，试探点位置是按照函数值近似分布的极小点确定的11.2区间试探法只对试探点函数值的大小进行比较，但函数值本身的特性没有得到充分利用，这样即使对一些简单的函数如二次函数，也必须像一般函数那样进行同样多的函数值计算。函数逼近法是利用函数在已知试探点的值(或导数值)来确定新试探点的位置11.3当函数具有比较好的解析性质比如连续可微性，函数逼近法要优于区间试探法 4.非精确的线搜索1.Armijo-Goldstein准则：1.1Armijo-Goldstein准则的几何意义：1.2Armijo-Goldstein准则可能会把极值点排除在可接受的区间之外2.Wolfe-Powell准则：2.1Wolfe-Powell准则的几何意义：2.2强Wolfe-Powell准则的几何意义： 5.变量轮换法1.对于一个迭代问题，不仅要求其是收敛的，还要考虑收敛速度问题，一般用阶衡量收敛速度2.构造探索方向问题2.1直接搜索法：在计算过程中只用到目标函数值，不用计算导数2.2解析法：计算过程中要用到目标函数的导数计算3.变量轮换法（坐标轴交替下降法）：把多变量函数的优化问题转化为一系列单变量函数的优化问题求解4.基本思路：搜索方向是各坐标轴的方向，轮流按各坐标轴方向搜索最优点。即从初始点出发，按第i个坐标轴方向搜索时，在n个变量中，只有xi在变化，其余n−1个变量保持不变，依次从x1到xn做n次单变量的一维搜索，就完成了变量轮换法的一次迭代5.算法步骤：5.1给定初始点x’0=(x1,x2,…,xn)’T,k=0注意：x'0为x上标为05.2检查点x’k是否满足终止条件，满足则结束，否则转5.35.3完成变量轮换法的一次迭代5.4令x’(k+1)=yn，k=k+1，转5.26.优点：搜索方向的获得不需要花费成本，基本思想简单、容易理解7.缺点：收敛速度较慢，搜索效率较低，对于一般问题未必收敛，只适用于具有特殊结构的函数8.变量轮换法效果：8.1若目标函数的等值线为圆形、球形或长短轴平行于坐标轴的椭圆形，搜索最快（变量之间无交互作用）8.2若目标函数的等值线类似与椭圆形，而且长短轴不平行与坐标轴，搜索速度较慢（变量之间存在弱交互作用）8.3若目标函数的等值线出现山脊时，该方法无效（变量之间存在强交互作用） 6.最速下降法（梯度法）1.基本思想：当前点xk处选择负梯度方向-Vf(x’k)作为搜索方向注意：V表示梯度2.步骤：2.1给定初始点x’0，终止误差c&gt;0，k=02.2判断是否满足终止条件||Vf(x’k)||&lt;c，满足则终止；否则转2.32.3构造负梯度方向d’k=-Vf(x’k)2.4进行线搜索求得ak，令x’(k+1)=x’k+ak*d’k，k=k+1，转2.23.优点：思想简单，每一步迭代只需要计算一阶导数，代价极小4.缺点：不能处理一阶不可微的函数，接近极小点时会出现锯齿现象锯齿现象：用最速下降法极小化目标函数时，相邻两个搜索方向是正交的 7.牛顿法1.基本思想：对于当前点x’k处选择牛顿方向注意：纯牛顿法规定步长因子a'k=1V^2f(x'k)为海塞矩阵2.基本步骤：2.1给定初始点x’0，终止误差c&gt;0，k=02.2计算梯度Vf(x’k)判断是否满足终止条件||Vf(x’k)||&lt;c，满足则终止，否则转2.32.3构造牛顿方向d’k2.4计算x’(k+1)=x’k+d’k，令k=k+1转2.23.若[V^2f(x’k)]^(-1)&gt;0，则牛顿方向是下降方向，否则不是4.缺点：要求海塞矩阵正定；需要计算海塞矩阵及其逆，计算量大5.优点：当初始点接近于最优解且海塞矩阵正定时，牛顿法二阶收敛；对于凸二次函数，只需要一步牛顿法即可找到最优解 8.修正的牛顿法1.对于步长的修正：保留牛顿方向为搜索方向但摒弃了步长恒为1的做法，而是采用线搜索确定最优步长来构造算法2.对于方向的修正：选取d’k=-Bk^(-1)Vf(x’k) 9.拟牛顿法1.基本思想：2.DFP(Davidon,Fletcher,Powell)方法3.DFP算法步骤：4.BFGS(Broyden,Fletcher,Goldarb,Shanno)算法5.拟牛顿法SR1方法： 10、共轭梯度法1.二次型及二次终结性2.概念：求解n元二次正定函数极小化问题2.1迭代法求解上面问题的方法称之为“线性”共轭梯度法2.2求解最小化一般函数的方法称之为“非线性”共轭梯度法3.共轭方向法是一类方法，共轭梯度法是其中的一种方法4.线性共轭梯度法基本框架：5.非线性共轭梯度法：6.适合大规模运算，收敛速度介于最速下降法和牛顿法之间 四、约束优化1.线性规划的下界与对偶1.下界：在凸优化问题中，我们想要找到最优值的下界，B&lt;=min(x) f(x)2.对于问题：min(x,y) px+qys.t.x+y&gt;=2x,y&gt;=02.1求解本问题为主线性规划(primal LP)a+b=pa+c=qa,b,c&gt;=0对于满足上述约束的a,b,c，下界B=2a2.2找到下界，通过最大化下界，可以得到对偶线性规划(dual LP)max(a,b,c) 2as.t.a+b=pa+c=qa,b,c&gt;=0注意：对偶变量的数目是原问题约束的数目3.一般形式线性规划的对偶： 2.最大流和最小割3.LP对偶的另一种理解方式 4.拉格朗日对偶函数1.拉格朗日对于一般化的最小值问题注意：这里的函数可以不是凸函数2.拉格朗日对偶函数3.二次规划的例子： 5.拉格朗日对偶问题 6.软对偶与强对偶1.对于拉格朗日对偶问题2.对偶间隙：2.1给定主问题可行点x和对偶问题可行点u,v，项f(x)-g(u,v)称为x和u,v之间的对偶间隙2.2已知f(x)-f’*&lt;=f(x)-g(u,v)，所以当对偶间隙为0时，x就是主最优的，相应的，u,v是对偶最优的2.3从算法角度来看，这提供了一个终止判别标准：若f(x)-g(u,v)&lt;=c，那么我们可以保证f(x)-f’*&lt;=c 7.KKT条件1.KKT(Karush-Kuhn-Tucker)条件:2.KKT条件的意义：对于有不等式约束的拉格朗日对偶问题，KKT条件可以总结为：约束条件、、对x偏导为0、对偶互补条件3.KKT条件等价于0对偶间隙，通常是充分的，在强对偶条件下是必要的 8.约束形式与拉格朗日形式1.约束形式与拉格朗日形式：2.两种形式等价，要求f(x)和h(x)是函数3.两者之间的转化：3.1约束形式到拉格朗日形式的转化：如果前者严格可行，那么强对偶成立，如果再存在一个r&gt;=0，那么前者中的任意解可最小化f(x’)+r(h(x’)-t)，得知x’也是后者的一个解3.2拉格朗日形式到约束形式的转化：如果x’是前者的一个解，令t=h(x’)，后者的KKT条件就得到满足，从而x’就是后者的一个解3.3结论：U(r&gt;=0){拉格朗日形式的解}包含于U(t&gt;=0){约束形式的解}U(r&gt;=0){拉格朗日形式的解}包含U(令约束形式严格可行的t){约束形式的解}注意：可以产生一个可行但不严格可行约束集t的唯一值t=0，我们也可以得到完美的等价4.对偶的重要应用：在强对偶条件下，可以通过求解对偶问题解达到求解原问题解的目的 9.只有等式约束的KT条件1.概念：2.几何意义： 10.只有不等式约束的KT条件1.概念：2.几何意义：3.定理（最优性必要条件）：4.应用：可能的K-T点：两约束曲线的交点、目标函数与一条曲线的交点对每一个上述得到的点求解乘子ui，若所有ui&gt;=0，即为KT点 11.一般约束的KT条件1.一般约束优化问题：2.一般约束优化问题的KT条件： 12.凸规划的一阶充分条件1.当一般约束最优化问题是凸优化时，KT条件称为充要条件2.充分条件： 13.对偶范数1.范数||x||概念2.对偶范数的对偶时其本身：||x||**=||x|| 14.共轭函数1.共轭函数：给定一个函数f: R^n-&gt;R，定义它的共轭函数f*:R^n-&gt;R，f*(y)=max(x) (y'T)*x-f(x)2.f*通常是凸函数：它是对于y的凸函数的逐点最大化，f*是线性函数y’Tx和f(x)之间的最大间隙3.对于可微的f，共轭称作勒让德变换4.性质：5.共轭和对偶问题的关系：共轭常常出现在对偶问题的推导中例如：支撑函数：若f(x)=Ic(x)，那么它的共轭被称为C的支撑函数6.对偶公式可以帮助我们把一个目标函数的一部分变为对偶函数的一部分 15.对偶锥1.定义：2.举例：3.对偶锥和对偶问题： 16.对偶技巧1.我们会把对偶转化为等价的问题并称之为对偶问题。在强对偶条件下，我们可以用对偶问题的解计算原问题的解注意：转换的对偶问题的最优值未必是原问题的最优值2.推导无约束问题对偶的一个常见技巧：增加一个哑变量和等式约束来转换原问题3.双对偶：4.事实上，对偶的对偶与共轭之间的关联不局限于线性约束 17.制约函数法1.基本思想：通过构造制约函数，把约束优化问题转化为一系列无约束优化问题，进而使用无约束优化方法求解该方法也被称为序列无约束最优化方法SUMT2.常用的制约函数法分为两类：2.1惩罚函数法（外点法）2.2障碍函数法（内点法）3.两种方法的缺点： 18.外点法（惩罚函数法）1.概念：2.目的：使满足约束的x有a(x)=0，不满足约束的x有a(x)&gt;03.注意事项：4.惩罚函数法相关定理与性质：5.算法： 19.内点法（障碍函数法）1.定义：2.相关定理与性质：3.算法：4.求初始内点： 20.乘子法 21.对偶分解1.对偶问题：2.对偶上升(Dual Ascent)：3.对偶分解(Dual Decomposition) 22.乘子法乘子法(Method of Multipliers)也叫ALM(Augmented Lagrangian Method)增广拉格朗日法 23.交替方向乘子法1.交替方向乘子法ADMM(Alternating Direction Method of Multipliers)2.放缩形式的ADMM(Scaled form ADMM)3.收敛性： 24.常见的模式1.几类常见的模式，可以利用它们特有的结构简化变量的更新操作2.可分解Decomposition3.邻近算子Proximal Operator4.二次目标函数Quadratic Objective5.光滑目标函数Smooth Objective 25.一致性","path":"2022/05/19/yun-chou-xue-yu-zui-you-hua-fang-fa-bi-ji/","date":"05-19","excerpt":"","tags":[{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"}]},{"title":"Python课程笔记","text":"一、基础知识1.基础数据与操作1.1基本语法1.版本说明：Python 3.0并没有向下兼容2.标识符：2.1作用：表示变量、函数、类、模块等对象的名称2.2规则：由字母、数字、”_”组成，首字符不能是数字2.3注意：大小写敏感3.关键字：Python语言规定其语法含义查看关键字的方法： &gt;&gt;&gt;help() Help&gt;keyworks Help&gt;return 4.预定义标识符：Python语言包含的预定义的内置类、异常、函数等5.保留标识符：5.1”_”在交互式执行中使用，代表计算结果 &gt;&gt;&gt;100+200 #300 &gt;&gt;&gt;_+200 #500 5.2”__*__“系统定义的函数名字如：__new__() #创建新对象的函数6.Python语句：6.1通常一行编写一个语句6.2Python语句的结束符：换行或分号，其中分号表示多条语句同行7.缩进规则：7.1在代码行前面添加空格或Tab，代表从属关系7.2平级的语句行（代码块）缩进必须相同7.3分支、循环、函数定义都采用缩进格式，且末尾有冒号8.注释： #单行注释 ''' 多行注释 ''' \"\"\" 多行注释 \"\"\" 9.输入： #&lt;变量&gt;=input([提示]) a=int(input(\"请输入整数：\")) 10.输出： #print(&lt;输出项列表&gt;,sep=&lt;分隔符&gt;,end=&lt;结束符&gt;) a=6 b=6.28 print(a,b,sep=',',end=';') #6,6.28; 1.2数字类型1.常量：内存中用于保存固定值的单元，在程序中常量的值不能发生改变1.1Python常量包括数字、字符串、布尔值和空值等1.2在库中也有可能存在关联紧密的常量2.对象：某种类型事务的一个具体实例2.1Python中一切皆对象2.2通过一些函数可以对所有类型对象操作：id(),type(),del()2.3对象的类型是不能改变的3.变量：运行过程中值可以改变的量3.1变量是一个标识符，通过赋值运算符创建，指向一个对象3.2Python变量不需要声明，可以随时赋不同类型的值，也可以使用一个赋值符号给多个变量赋值4.对象与数据：对象包含属性和方法，数据是某类对象的属性值5.数字类型：整数型、浮点型、复数型、布尔型、高精度数与分数 1.3运算符1.基本概念：1.1运算：对数据的变换1.2运算符：运算的符号1.3操作数：运算数、操作对象1.4表达式：按运算规则将值、变量和操作符组合2.算术运算符：+，-，，/，%，//，*2.1对于数字操作数来讲，运算符全部适用，且//为整除，*为指数2.2对于字符串操作数来讲，+代表连接两个字符串，代表复制多次3.lambda： f=lambda x,y:x+y f(1,2) #输出3 4.if…else：m=x if y else z5.逻辑运算符：or\\and\\not6.关系运算符：&lt;,&lt;=,!=,==…7.复合运算符：+=，-=…8.位运算符：|,^,&amp;,&gt;&gt;,&lt;&lt;,~9.成员运算符：in,not in,is,is not x=\"bc\" y=\"abc\" x in y #True 10.运算符优先级（由高到低）：函数调用、寻址、下标-&gt;幂运算(**)-&gt;翻转运算符(~)-&gt;正负变换(+x,-x)-&gt;算术运算符(*,/,%,//)-&gt;算术运算符(+,-)-&gt;位运算符(&gt;&gt;,&lt;&lt;,&amp;,|,^)-&gt;关系运算符(&lt;,&lt;=,!=,==…)-&gt;赋值运算符(=,/=..)-&gt;同一性运算符(is,is not)-&gt;成员运算符(in,not in)-&gt;逻辑运算符(not,and,or) 1.4内置函数1.Python提供67个内置函数2.转换函数：2.1abs(x),bin(x),bool(x),int(x),complex([real[,imag]]),ord(x),bytes([source[,encoding[,errors]]]),str(x)2.2divmod(a,b)返回a除以b的商和余数x,y=divmod(a,b)2.3eval(expression)返回字符串表达式的值x=eval(\"a+b\")2.4pow(x,y)返回x的y次方2.5sorted()返回有序表 1.5模块1.模块：多个函数及变量可以组成模块，多个模块可以组成包，多个包可以组成库2.要使用模块中的函数，需要导入模块 #两种导入方式 #全模块导入 import math math.sin(0.7) #只导入需要的部分 from math import sin sin(0.7) 2.控制结构与异常处理2.1顺序与条件分支控制结构1.一路分支结构： if &lt;条件表达式&gt;: &lt;语句块&gt; 2.二路分支结构 if &lt;条件表达式&gt;: &lt;语句块1&gt; else: &lt;语句块2&gt; 3.多路分支结构 if &lt;条件1&gt;: &lt;语句块1&gt; elif &lt;条件2&gt;: &lt;语句块2&gt; ...... elif &lt;条件n&gt;: &lt;语句块n&gt; else: &lt;语句块n+1&gt; 4.分支嵌套：用缩进表示嵌套层次 2.2顺序程序设计1.列表-集合类数据类型1.1定义：在一对方括号中用逗号隔开的若干数据1.2成员特点：任何合法数据类型，多个成员的数据类型可以不同1.3访问方式：正向索引、逆向索引、区间访问1.4相关操作：+*\\in\\len()\\min()\\max()1.5用列表表示多维数据：列表的每个维度长度可以不同，元素类型可以不同2.for循环2.1常用格式： for in range(begin,end,step): &lt;循环块&gt;/&lt;语句块&gt; 2.2一般格式： for in &lt;可迭代对象的集合&gt;: &lt;循环体&gt;/&lt;语句块&gt; else: &lt;语句块&gt; 3.while循环格式： while&lt;循环条件&gt;: &lt;循环块&gt;/&lt;语句块&gt; else: &lt;语句块&gt; 4.循环中的特殊语句4.1break中断循环4.2continue跳过当前剩余语句，执行下一次循环4.3pass啥也不做 2.3异常处理1.异常：程序中产生的错误2.后果：若异常对象未被处理或捕获，程序就会用所谓的回溯(Traceback)终止执行3.格式： try: except : #捕获异常name1 except : #捕获异常name2，name3 else: #无异常 finally: #无论有无异常，一定执行 4.自定义异常类 class SomeCustomException(Exception) pass #抛出异常：raise 5.断言5.1用途：期望满足用户指定的条件。当用户定义的约束不满足时触发AssertionError异常。它是条件式的raise语句5.2一般格式 assert ,#test为逻辑表达式,data是test为假时的提示信息 #等效于下列代码 if not : raise AssertionError() 2.4函数1.函数定义一般格式： def 函数名(&lt;形式参数&gt;): #形式参数可以=默认值 #参数可以设置可变长 &lt;函数体&gt; 2.参数传递方式：2.1位置绑定2.2关键字绑定3.函数可以返回多个数值 2.5函数式编程1.匿名函数lambda #格式：lambda 参数列表:语句块 f=lambda x,y:x+y 2.内嵌函数：可以在函数中内嵌函数，在本函数中可以使用次内嵌函数3.递归算法的设计要点：3.1递推公式3.2递归结束条件4.高阶函数：4.1定义：一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数，满足其一则为高阶函数4.2内置高阶函数 #zip函数：同时遍历多个序列,遍历次数为最短序列长度 a=[1,2,3] b=['a','b'] for x,y in zip(a,b): print(x,y) #map函数：根据提供的函数对指定序列做映射 print(*map(lambda x:x*x, [1,2,3])) #filter(function,iterable):根据函数对给定的可迭代对象进行过滤 print(*filter(lambda x: x%2==1, [1,2,3])) 4.3闭包：函数的嵌套定义。在函数内部定义一个嵌套函数，将嵌套函数视为一个对象，将内嵌函数作为包含它的函数的返回结果（相当于返回一段函数代码） def func_lib(): def add(x,y): return x+y return add fadd=func_lib() print(fadd(1,2)) 3.面向对象编程3.1类和对象1.声明类： class 类名: 成员变量 成员函数 2.定义类的对象：对象名=类名()3.成员变量：私有变量格式：__xxx4.构造函数def __init__(self,其他参数)5.析构函数def __del__(self)6.静态成员与静态方法：静态方法无须传入self参数 #语法格式 class 类名: @staticmethod def 静态方法名(): 方法体 3.2类的继承1.继承格式： class 派生类名(基类名1,基类名2,......): 类体 2.派生类和基类的同名方法： class 派生类名(基类名1,基类名2,......): 与父类同名的子类方法(参数列表): super(子类).基类同名方法 子类语句 3.3多态与重载1.抽象类和多态 #定义抽象类格式 from abc import ABCMeta,abstractmethod class myAbc(object): __metaclass__=ABCMeta @abstractmethod def abstractmethod(self):pass #函数重载 @classmethod def 类方法名([cls[,参数列表]]): 方法体 2.运算符重载 __add__(self,rhs)#+ __sub__(self,rhs)#- __mul__(self,rhs)#* __truediv__(self,rhs)#/ __floordiv__(self,rhs)#//整除 __mod__(self,rhs)#%求余 __pow__(self,rhs)#** 3.4模态与类1.文件名.py是模块，一个类一个块2.引入类：import 模块名或from 模块名 import 类名3.包：一个包含__init__.py的文件夹被称为包4.引入包中的模块： import 包名.模块名 模块名.类名 4.复杂数据类型4.1序列的概念1.定义：若干有共同特征的数据元素的集合，元素容器2.分类：列表list、元组tuple、字符串string、Unicode字符串、buffer对象和range对象3.通用操作：分片(sliceing)-取一部分内容：s[i:j:k]、元素的位置检索：s.index(x[,start[,end]])、计算元素出现的频率：s.count(x) 4.2字符串1.定义：Unicode字符序列：’abc’\"abc”'‘’abc’’’可以相互嵌套2.索引方法：2.1顺次：从左向右：0n-1；从右向左：-1-n2.2片选：[N:M]：N到M-1；[:M]：左到M-1；[N:]：N到右2.3字节序列：数据是一系列的字节，并以b为前缀的字符串，可以通过很多方法将字符串转换为字节序列3.特有操作：3.1数字与字符串相互转化-str(),int(),float()3.2格式化生成字符串：'目标字符串'%(数据1,数据2,......)3.3子串查找与替换函数：str.find(sub)，str.rfind(sub)，str.replace(old,new)3.4查找子串的位置：str.index(sub)3.5统计元素出现的次数：sub.count(sub)3.6裁掉特定字符的函数：str.lstrip([chars])，str.rstrip([chars])，str.strip([chars])3.7分隔子串：str.split(sep) 4.3列表和元组1.列表操作函数：1.1添加：append()，extend()，insert()1.2删除元素：pop()，remove()，del命令1.3元素位置查找：index()1.4统计元素出现的次数：count()1.5列表排序：sort(key=None,reverse=None)，reverse()1.6清空列表元素：clear()2.元组是不可变的，可以看做元素固定不变的列表 4.4字典1.字典定义：以{key:value}形式组织数据2.基本操作：2.1创建：变量D={}或dict #空字典对象2.2元素修改：D[key]=value2.3元素添加：D[newkey]=newvalue2.4元素删除：del D[key],D.clear()2.5测试元素在字典中：key in D2.6元素个数：len(D)2.7判断两个字典是否相同：D1==D23.操作函数：3.1用keys(),values(),items()获取视图3.2用get()获取字典的值3.3创建字典fromkeys()3.4用pop()删除字典的值3.5用update()更新或添加元素 4.5集合1.元素是无序且不能重复的，分为可变集合(set)，不可变集合(frozenset)2.操作：2.1创建：s=set(['a','b'])2.2元素添加：s.add(元素),s.update()2.3元素删除：s.discard(obj),s.remove(obj),s.pop(),s.clear()2.4判断元素是否属于集合：s.discard('a')2.5元素个数：len(D)3.集合间的关系运算：&gt;代表包含关系 4.6迭代器和生成器1.迭代器1.1定义：提供在某种容器（列表、字典等）上的遍历元素的方法1.2惰性求值：不需要事先准备好整个迭代过程中的所有元素，迭代至某个元素时才获取该元素。可以遍历巨大文件1.3操作：创建：iter(某种可迭代的对象)；迭代器对象查看：__iter__()/iter；获取迭代器元素：__next__()/next2.生成器2.1定义：生成器是一个带有yield语句的函数，他用于产生一系列数据2.2格式： def 函数名(参数): ...... yield变量 二、高级应用1.网络程序1.1网络通信模型1.计算机网络：将地理位置不同且具有独立功能的多台计算机及其外部设备通过通讯线路连接起来，并在网络操作系统、网络管理软件及网络通讯协议的管理和协调下，实现资源共享和信息传递的计算机系统2.PDU(Protocol Data Unit)对等协议之间交换的信息单元统称为协议数据单元| OSI参考模型中的层次 | PDU的特定名称 || :-: | :-: || 传输层 | 数据段(Segment) || 网络层 | 数据包(Packet) || 数据链路层 | 数据帧(Frame) || 物理层 | 比特(Bit) |3.TCP/IP是Internet的基础网络通信协议 1.2Socket编程1.Socket基本概念1.1定义：计算机之间进行网络通信的一套程序接口，网络编程的标准1.2作用：Socket对象是网络通信的基础，相当于一个管道连接了发送端和接收端2.基于UDP协议的网络编程函数2.1socket():创建一个流式套接字，返回套接字号 socket(family,type[,protocol]) #family:地址家族，取值为AF_INET(IPv4)、AF_INET6(IPv6) #type:套接字类型，取值为SOCK_STREAM(TCP)、SOCK_DGRAM(UDP) #protocol:与特定的地址家族相关的协议，默认值为0 2.2bind():将套接字绑定到一个已知的地址及端口号2.3sendto():发送数据2.4recvfrom():接收数据3.基于TCP协议的网络编程函数3.1服务器端listen(backlog):开始监听TCP连接，backlog为网络最大连接数accept():接受TCP连接并返回(conn,address)3.2客户端connect(address):连接到address处，address=(host,port)3.3共有recv(bufsize[,flag]):接受TCP数据，以字符串形式返回，bufsize表示接收的最大数据量sendall(bytes[,flag]):完整发送TCP数据settimeout(timeout):返回当前超时期的值，单位是秒 1.3Internet编程1.网络协议：超文本传输协议(HTTP)2.数据访问方式：通过统一资源定位符(URL=IP:Port)请求访问资源3.访问web资源的方法：urllib模块3.1urllib.request:打开和读取url3.2urllib.parse:解析URL3.3urllib.error:urllib.request引发的异常3.4urllib.robotpaser:解析robots文件4.urllib.request获取资源4.1urlopen():创建一个表示远程URL的类文件对象4.2info():返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息4.3getcode():返回HTTP状态码4.4geturl():返回请求的url5.urllib.request保存web资源urllib.request.urlretrieve(url[,filename[,reporthook[,data]]])6.urllib.request的Request实例urllib.request.Request(key=value[,key=value,…])7.对url进行编码、解码的有用方法urllib.quote(string[,safe]), urllib.unquote(string)、urllib.quote_plus(string[,safe])、urllib.unquote_plus(string)8.邮件客户端编程：POP3(Post Office Protocol 3):负责从邮件服务器中检索电子邮件。支持多用户互联网邮件扩展，允许在电子邮件上附带二进制文件。是因特网电子邮件的第一个离线协议标准9.POP3类：poplib9.1POP3(host, post=POP3_PORT[,timeout]): 构造方法，连接host邮件服务器。POP3_PORT=1109.2user(username): 发送邮件的账号(登录用户名)9.3pass_(password): 发送用户密码9.4getwelcome(): 返回欢迎信息9.5stat():返回邮箱状态，结果为元组(邮件数量，邮件字节数)9.6list():返回邮件列表，结果是一个三元组9.7dele(i):设置邮件删除标志，调用quit()时从服务器删除9.8quit(): 注销，释放连接10.使用SMTP协议发送邮件10.1SMTP(host=‘’,port=0,local_h=None[,timeout],src_addr=Noe),构造函数，其主要参数host是发送邮件的服务器10.2login(user,password):登录服务器10.3sendmail(from_addr, to_addr, msg, mail_option=[], rept_option=[]): 发送邮件10.4send_message(msg, from_addr, to_addr): 以邮件对象的形式发送邮件。10.5quit():注销，释放连接 2.图形用户界面1.Python原生界面库：tkinter2.Pack布局 3.文件与数据库1.文件打开与关闭 #打开文件 fileObject = open(filename,mode) #filename存储文件路径 #mode为打开方式：r,w,a,rb,wb,ab,+ #文件关闭 fileObject.close() #常用方式 with open(filename,mode) as fileObject: 操作fileObject #with中语句执行完毕后，打开的文件自动关闭 2.打开文件异常FileNotFoundError3.使用struct读写二进制文件3.1字节流：以字节为单位的一系列二进制数据为字节流3.2struct的功能：将一系列不同类型的数据封装成一段字节流，或者字节解封3.3常用函数：pack()数据封装函数,unpack()数据解封函数,calcsize()格式大小计算函数4.使用pickle实现数据序列化4.1序列化：将任意python对象转化为一系列的字节存储到文件中4.2序列化方法：dump()将对象转换成字节流存入文件，load()解析文件中的字节流5.连接数据库需要的Python库：pymysql #导入库 import pymysql #打开数据库连接 db = pymysql.connect(host=\"localhost\",user=\"用户名\",password=\"密码\",database=\"连接的数据库\") #创建一个游标对象，执行SQL操作，读取返回的信息 cursor = db.cursor() #执行SQL查询 cursor.execute(\"SQL语句\") cursor.fetchone()#获取下一个查询结果集 cursor.fetchall()#接收全部的返回结果行 cursor.rowcount()#返回执行SQL语句（调用execute()方法）后影响的行数 #关闭数据库连接 db.close() 4.前后端分离技术1.基本概念：1.1前端：展示数据并与用户进行交互的程序模块（浏览器）1.2后端：为前端提供业务逻辑和数据准备程序模块1.3战略地位：开发模式与web应用的架构模式2.前后端分离优势：2.1提升开发效率（并行开发）2.2完美应对复杂多变的前端需求2.3增强代码可维护性 5.常用的AI工具库1.numpy：支持大量的多维数组与矩阵运算，此外针对数组运算提供大量的数学函数库2.scipy：数学、科学、工程领域的常用软件包，可以有效计算numpy矩阵，结合numpy高效解决问题3.sklearn-learn：专门用于机器学习的模块，具有分类、回归和聚类算法等功能，旨在联合numpy和scipy使用4.pandas：基于numpy的一种工具，是为解决数据分析任务而创建的，提供了高效地操作大型数据集所需的工具5.matplotlib：Python的绘图库，可与numpy一起使用，提供了一种有效的MatLab开源替代方案6.seaborn：基于matplotlib的图形可视化Python包，提供高度交互式界面，便于用户能够做出各种有吸引力的统计图表7.GBDT：梯度提升树8.XGBoost：极端梯度提升9.warnings：主要用于代码运行中忽略警告 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/05/05/python-ke-cheng-bi-ji/","date":"05-05","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://jia_k3.gitee.io/blog/tags/Python/"}]},{"title":"高级语言网络通信程序-端口","text":"端口理解1.计算机之间的通信实质上是不同计算机之间进程的通信，而端口号就是唯一的表示这些进程的编号，至于进程，可以理解为运行着的程序。 2.端口号有16位，0到65535，一共有2^16个端口号。通过端口号可以找到计算机运行的应用程序，联系网络安全，端口攻击。 3.在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型 4.从端口的分配来看，端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口。像这样分类：0-1024公共端口，1025-49151注册端口，49152-65535动态和私有端口）：4.1固定端口（0－1023）：使用集中式管理机制，即服从一个管理机构(IANA)对端口的指派，这个机构负责发布这些指派。（低于255用于公共应用，255-1023分配给各个公司来用于特殊应用）由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方 是否开启了这些服务，如TCP的20/21(ftp)、80(http)、139(netbios)、23(telnet)、25(smtp)、53(dns)，UDP的7(echo)、69(tftp)、161(snmp)4.2动态端口（1024－49151）：这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程， 同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的 4000端口，木马冰河的7626端口等都是固定而出名的。 PythonUDP网络编程实例-实时聊天软件1.Server服务器：反映连接情况 import socket s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) s.bind(('127.0.0.1',5005)) tar_address=[] tar_port=[] try: while True: data,addr=s.recvfrom(1024) print(addr) if not data or data.decode()=='-1': pass else: c=data.decode().split('&lt;') if len(c)==4: if c[2]=='aaa' and str(c[3])=='123456': tar_address.append(c[0].encode('utf-8')) tar_port.append(int(c[1])) print(\"address:\"+c[0]+\";port:\"+c[1]+\" in\\n\") msg=\"password","path":"2022/04/23/gao-ji-yu-yan-wang-luo-tong-xin-cheng-xu-duan-kou/","date":"04-23","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://jia_k3.gitee.io/blog/tags/Python/"},{"name":"网络通信","slug":"网络通信","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"观察者模式在C#和Java中的应用","text":"一、观察者模式定义1.实例比喻：报纸出版者（主题Subject）+报纸订阅者（观察者Observer）=观察者模式2.观察者与主题两种角色可以重叠，例如一个观察者作为主题，在得知它对应的主题信息更新后通知它对应的观察者信息3.观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新4.实现观察者模式的方法不只有一种，但是以包含Subject与Observer接口的类设计的做法最常见5.设计原则：为了交互对象之间的松耦合设计而努力5.1两个对象之间松耦合：依然可以交互，但是不太清除彼此的细节5.2观察者模式提供了一种对象设计，让主题和观察者之间松耦合5.3由于两者并非紧耦合，我们可以独立地复用主题或观察者5.4改变主题或观察者其中一方，并不会影响另一方，只要它们之间的接口仍被遵守，我们就可以自由地改变它们5.5松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降到了最低5.6“耦合”的理解：耦合不是简单的调用，而是依据调用代码内容做更改后的调用。例如：直接调用a.aa()是松耦合；“若a是A，调用a.aa()，否则如何”这样是紧耦合。或者说不根据彼此代码而作适应性编程就是松耦合6.要点摘抄：6.1使用此模式时，你可从被观察者处推或拉数据，推的方式被认为更“正确”6.2有多个观察者时，不可以依赖特定的通知次序 二、Csharp事件与委托1.事件+委托是观察者模式的一个典型例子，委托就是观察者(Observer)，事件就是主题(Subject)，事件发生改变，委托响应变动2.定义位置：2.1事件定义在类内部2.2委托通常定义在类外部，使用public修饰，方便外部调用；也可以定义在类的内部，但必须通过调用类的成员才可以取得委托引用3.类比接口，委托可以看作方法的模板，而且方便实现多态，作用可以参考类的多态4.使用方法： //定义委托 public delegate void Test(string t); Class Try { //定义具体方法，委托实现 protected void Test_1(string t1) { //实例内容 } propected void Test_2(string t2) { //实例内容 } //定义与Test委托联系的事件，他不仅是事件对象，也是委托对象 public event Test t; //测试方法 public void test() { //声明委托实例，可以向没有明确委托的事件添加方法 //Test t1 = new Test(Test_1); //Test t2 = new Test(Test_2); //为事件添加方法，存储与事件队列中，事件触发时，依次调用方法 //t += t1; //t += t2; //除以上添加方式外 //可以直接以下面的方式向已经声明委托类型的事件添加方法 t += Test_1; t += Test_2; //触发事件，事件对象通知委托方法调用 t(\"实例\"); /*不使用事件也可以调用t1(\"实例\")来实现委托函数调用*/ } } 5.事件与委托在C#中使用非常广泛，例如，在C#窗体应用程序中，“委托”的名字统一使用“EventHandler”，定义规范为“void EventHandler(object sender, EventArgs e)”6.另外，相比于C++的指针函数，委托不仅拥有面向对象的思想，又有安全可控的特点 三、Java1.Java内置的Observer模式不只支持主题推数据给观察者，还支持观察者从主题拉数据1.1观察者类：java.util.Observer1.2主题（被观察者）类：java.util.Observable2.java.util.Observable中的Obserable是一个类，违反针对接口编程的原则；类中setChanged()被保护，要更改函数必须继承，违反多用组合的原则2.1注意每次提醒观察者之前要先调用setChanged()3.设计中可以扩展java.util.Observable，若Java自带的API不符合需求，需要自己设计一整套观察者模式的代码4.在JDK中，并非只有在java.util中才能找到观察者模式，在JavaBeans和Swing中也存在观察者模式 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/04/10/guan-cha-zhe-mo-shi-zai-c-he-java-zhong-de-ying-yong/","date":"04-10","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"https://jia_k3.gitee.io/blog/tags/Java/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://jia_k3.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"时序图绘制","text":"一、时序图元素1.基本概念1.1Sequence Diagram:顺序图或称为时序图，亦称为序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作1.2使用时序图的好处：可以很清楚地表示按照时间顺序的消息传递（方法调用）1.3时序图是一个二维图，横轴表示对象，纵轴表示时间，消息在各对象之间横向传递，依照时间顺序纵向排列 2.组成元素2.1角色(Actor)：用于表示外部角色，可以是人、机器、其他系统、子系统2.2对象(Object)：2.2.1对象的命名方式：“对象名：类名”，“：类名”（匿名对象），“对象名”2.2.2对象先后排列：交互频繁的对象距离短，初始化整个交互活动的对象放置于最左端2.3生命线(Lifeline)：在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间2.4控制焦点(Focus of Control)：又称为激活期，在时序图中用小矩形表示，表示执行相应操作的时间段2.5消息(Message)：一般分为同步消息（发送信息后发送者等待返回信息）、异步消息（发送信息后发送者不等待返回信息）、返回消息（过程调用返回）和自关联消息（方法调用自身方法或自身对象方法）2.6组合片段：用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程| 片段类型 | 名称 | 说明 || :-: | :-: | :-: || Opt | 选项 | 包含一个可能发生或不发生的序列，可以在临界中指定序列发生的条件 || Alt | 抉择 | 包含一个片段列表，这些片段包含备选消息序列。相当于IF-ELSE，在任何场合下只发生不超过一个序列 || Loop| 循环 | 片段重复一定次数，可以在临界中指示片段重复的条件 || Break| 中断 | 若执行次片段，则放弃序列的其余部分 || Par | 并行 | 并行处理事件 || Critical | 关键 | 用于Par或Seq片段中，表示此片段中的消息不得与其他消息交错 || Seq | 弱顺序 | 对于多个操作数片段，只有涉及同一生命线的消息必须以片段的顺序发生 || Strict | 强顺序 | 对于多个操作数片段，必须以片段的顺序发生 |2.7时序图复用(ref)：引用其他地方定义的时序图，表示先遣行为 二、starUML绘制1.时序图建立1.1工具栏Model&gt;Add Diagram&gt;Sequence Diagram1.2右击右边栏显示的主文件，选择Add Diagram&gt;Sequence Diagram 2.时序图组件建立2.1角色(Actor)等：在右边栏选择合适的文件位置，右击选择Add&gt;Actor等2.2图示：左下边栏3种交互图示2.3片段类型选择：点选片段(Combined Fragment)-&gt;右下侧属性栏-&gt;Properties-&gt;interactionOpertor2.3区分片段与时序图复用框：2.3.1片段Combined Fragment2.3.2时序图复用Interaction Use2.4迷失信息：Found Message:来源迷失Lost Message:目标迷失 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/04/07/shi-xu-tu-hui-zhi/","date":"04-07","excerpt":"","tags":[{"name":"starUML","slug":"starUML","permalink":"https://jia_k3.gitee.io/blog/tags/starUML/"},{"name":"时序图","slug":"时序图","permalink":"https://jia_k3.gitee.io/blog/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"}]},{"title":"CSS属性速查表","text":"​ 一、定位1.position 默认值 static static 正常文档流，top\\right\\bottom\\left等属性不会被应用 relative 正常文档流，依据top\\right\\bottom\\left等属性偏移位置 absolute 脱离正常文档流，使用top\\right\\bottom\\left等属性进行绝对定位，层叠通过z-index属性定义 fixed 脱离正常文档流，使用top\\right\\bottom\\left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动 2.z-index 默认值 auto auto 遵从其父对象的定位 &lt;integer&gt; 用整数值来定义堆叠级别，可正可负 3.top 默认值 auto auto 无特征定位，根据HTML定位规则在文档流中分配 &lt;length&gt; 用长度值来定义距离顶部的偏移量，可正可负 &lt;percentage&gt; 用百分比来定义距离顶部的偏移量，可正可负 4.right 默认值 auto auto 无特征定位，根据HTML定位规则在文档流中分配 &lt;length&gt; 用长度值来定义距离右边的偏移量，可正可负 &lt;percentage&gt; 用百分比来定义距离右边的偏移量，可正可负 5.bottom 默认值 auto auto 无特征定位，根据HTML定位规则在文档流中分配 &lt;length&gt; 用长度值来定义距离底部的偏移量，可正可负 &lt;percentage&gt; 用百分比来定义距离底部的偏移量，可正可负 6.left 默认值 auto auto 无特征定位，根据HTML定位规则在文档流中分配 &lt;length&gt; 用长度值来定义距离左边的偏移量，可正可负 &lt;percentage&gt; 用百分比来定义距离左边的偏移量，可正可负 二、布局1.display none 隐藏对象，不为被隐藏的对象保留其物理空间 inline 指定对象为内联元素 block 指定对象为块元素 list-item 指定对象为列表项目 inline-block 指定对象为内联块元素 table 指定对象作为块元素级的表格，类同于html标签&lt;table&gt; inline-table 指定对象作为内联元素级的表格，类同于html标签&lt;table&gt; table-caption 指定对象作为表格标题，类同于html标签&lt;caption&gt; table-cell 指定对象作为表格单元格，类同于html标签&lt;td&gt; table-row 指定对象作为表格行，类同于html标签&lt;tr&gt; table-row-group 指定对象作为表格行组，类同于html标签&lt;tbody&gt; table-column 指定对象作为表格列，类同于html标签&lt;col&gt; table-column-group 指定对象作为表格列组显示，类同于html标签&lt;colgroup&gt; table-header-group 指定对象作为表格标题组，类同于html标签&lt;thead&gt; table-footer-group 指定对象作为表格脚注组，类同于html标签&lt;tfoot&gt; compact 分配对象为块对象或基于内容之上的内联对象，缺乏广泛支持，从CSS2.1删除 run-in 分配对象为块对象或基于内容之上的内联对象 ruby 将对象作为表格脚注组显示 ruby-base 将对象作为表格脚注组显示，类同于html标签&lt;rb&gt; ruby-text 将对象作为表格脚注组显示，类同于html标签&lt;rt&gt; ruby-base-groupruby-base-container 将对象作为表格脚注组显示，类同于html标签&lt;rbc&gt; ruby-text-groupruby-text-container 将对象作为表格脚注组显示，类同于html标签&lt;rtc&gt; box 将对象作为弹性盒模型显示 inline-box 将对象作为内联块级弹性盒模型显示 inherit 规定应该从父元素继承 display 属性的值 2.float 默认值 none none 设置对象不浮动 left 设置对象浮动在左边 right 设置对象浮动在右边 3.clear 默认值 none none 允许两边都可以有浮动对象 both 不允许有浮动对象 left 不允许左边有浮动对象 right 不允许右边有浮动对象 4.visibility 默认值 visible visible 设置对象可视 hidden 设置对象隐藏 collapse 主要用于隐藏表格的行或列，隐藏的行或列可以被其他内容使用，对于表格外的其他对象，作用等同于hidden 5.clip 默认值 auto auto 对象无剪切 rect(&lt;number&gt; auto . . .) 6.overflow 默认值 visible visible 不剪切内容 hidden 将超出对象尺寸的内容进行裁剪，不会出现滚动条 scroll 将超出对象尺寸的内容进行裁剪，并以滚动条的方式显示超出的内容 auto 在需要时剪切内容并添加滚动条，此为body对象和textarea的默认值 7.overflow-x 默认值 visible visible 不剪切内容 hidden 将超出对象尺寸的内容进行裁剪，不会出现滚动条 scroll 将超出对象尺寸的内容进行裁剪，并以滚动条的方式显示超出的内容 auto 在需要时剪切内容并添加滚动条，此为body对象和textarea的默认值 8.overflow-y 默认值 visible visible 不剪切内容 hidden 将超出对象尺寸的内容进行裁剪，不会出现滚动条 scroll 将超出对象尺寸的内容进行裁剪，并以滚动条的方式显示超出的内容 auto 在需要时剪切内容并添加滚动条，此为body对象和textarea的默认值 三、弹性盒模型1.box-orient 默认值 horizontal horizontal 设置弹性盒模型对象的子元素为水平排列 vertical 设置弹性盒模型对象的子元素为纵向排列 2.box-pack 默认值 start start 设置弹性盒模型对象的子元素从开始位置对齐（左对齐） center 设置弹性盒模型对象的子元素居中对齐 end 设置弹性盒模型对象的子元素从结束位置对齐（右对齐） justify 设置或弹性盒模型对象的子元素两端对齐 3.box-align 默认值 stretch start 设置弹性盒模型对象的子元素从开始位置对齐 center 设置弹性盒模型对象的子元素居中对齐 end 设置弹性盒模型对象的子元素从结束位置对齐 baseline 设置弹性盒模型对象的子元素基线对齐 stretch 设置弹性盒模型对象的子元素自适应父元素尺寸 4.box-flex 默认值 0 &lt;number&gt; 使用浮点数指定对象所分配其父元素剩余空间的比例 5.box-flex-group 默认值 1 &lt;integer&gt; 用整数值来定义弹性盒模型对象的子元素所在的组 6.box-ordinal-group 默认值 1 &lt;integer&gt; 用整数值来定义弹性盒模型对象的子元素显示顺序 7.box-direction 默认值 normal normal 设置弹性盒模型对象的子元素按正常顺序排列 reverse 反转弹性盒模型对象的子元素的排列顺序 8.box-lines 默认值 single single 弹性盒模型对象的子元素只在一行内显示 multiple 弹性盒模型对象的子元素超出父元素的空间时换行显示 四、尺寸1.width 默认值 auto auto 无特定宽度值，取决于其它属性值 &lt;length&gt; 用长度值来定义宽度，不允许负值 &lt;percentage&gt; 用百分比来定义宽度，不允许负值 2.min-width 默认值 0 &lt;length&gt; 用长度值来定义最小宽度，不允许负值 &lt;percentage&gt; 用百分比来定义最小宽度，不允许负值 3.max-width 默认值 auto auto 无最大宽度限制 &lt;length&gt; 用长度值来定义最大宽度，不允许负值 &lt;percentage&gt; 用百分比来定义最大宽度，不允许负值 4.height 默认值 auto auto 无特定高度值，取决于其它属性值 &lt;length&gt; 用长度值来定义高度，不允许负值 &lt;percentage&gt; 用百分比来定义高度，不允许负值 5.min-height 默认值 0 &lt;length&gt; 用长度值来定义最小高度，不允许负值 &lt;percentage&gt; 用百分比来定义最小高度，不允许负值 6.max-height 默认值 auto auto 无最大高度限制 &lt;length&gt; 用长度值来定义最大高度，不允许负值 &lt;percentage&gt; 用百分比来定义最大高度，不允许负值 五、外补白1.margin 默认值 其他独立属性 auto 设置为相对边的值 &lt;length&gt; 用长度值来定义外补白，可以为负值 &lt;percentage&gt; 用百分比来定义外补白，可以为负值 2.margin-top 默认值 0 auto 设置为相对边的值 &lt;length&gt; 用长度值来定义外补白，可以为负值 &lt;percentage&gt; 用百分比来定义外补白，可以为负值 3.margin-right 默认值 0 auto 设置为相对边的值 &lt;length&gt; 用长度值来定义外补白，可以为负值 &lt;percentage&gt; 用百分比来定义外补白，可以为负值 4.margin-bottom 默认值 0 auto 设置为相对边的值 &lt;length&gt; 用长度值来定义外补白，可以为负值 &lt;percentage&gt; 用百分比来定义外补白，可以为负值 5.margin-left 默认值 0 auto 设置为相对边的值 &lt;length&gt; 用长度值来定义外补白，可以为负值 &lt;percentage&gt; 用百分比来定义外补白，可以为负值 六、内部白1.padding 默认值 其他独立属性 &lt;length&gt; 用长度值来定义内补白，不允许负值 &lt;percentage&gt; 用百分比来定义内补白，不允许负值 2.padding-top 默认值 0 &lt;length&gt; 用长度值来定义内补白，不允许负值 &lt;percentage&gt; 用百分比来定义内补白，不允许负值 3.padding-right 默认值 0 &lt;length&gt; 用长度值来定义内补白，不允许负值 &lt;percentage&gt; 用百分比来定义内补白，不允许负值 4.padding-bottom 默认值 0 &lt;length&gt; 用长度值来定义内补白，不允许负值 &lt;percentage&gt; 用百分比来定义内补白，不允许负值 5.padding-left 默认值 0 &lt;length&gt; 用长度值来定义内补白，不允许负值 &lt;percentage&gt; 用百分比来定义内补白，不允许负值 七、边框1.border 默认值 看独立属性 [ border-width ] 设置或检索对象边框宽度 [ border-style ] 设置或检索对象边框样式 [ border-color ] 设置或检索对象边框颜色 2.border-width 默认值 看独立属性 &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 3.border-style 默认值 看独立属性 none 无轮廓 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓，两条单线与其间隔的和等于指定的border-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 4.border-color 默认值 看独立属性 &lt;color&gt; 指定颜色 5.border-top 默认值 看独立属性 [ border-top-width ] 设置或检索对象的顶部边框宽度 [ border-top-style ] 设置或检索对象的顶部边框样式 [ border-top-color ] 设置或检索对象的顶部边框颜色 6.border-top-width 默认值 medium &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 7.border-top-style 默认值 none none 无轮廓 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓，两条单线与其间隔的和等于指定的border-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 8.border-top-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 9.border-right 默认值 看独立属性 [ border-top-width ] 设置或检索对象的右边边框宽度 [ border-top-style ] 设置或检索对象的右边边框样式 [ border-top-color ] 设置或检索对象的右边边框颜色 10.border-right-width 默认值 medium &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 11.border-right-style 默认值 none none 无轮廓 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓，两条单线与其间隔的和等于指定的border-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 12.border-right-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 13.border-bottom 默认值 看独立属性 [ border-top-width ] 设置或检索对象的底部边框宽度 [ border-top-style ] 设置或检索对象的底部边框样式 [ border-top-color ] 设置或检索对象的底部边框颜色 14.border-bottom-width 默认值 medium &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 15.border-bottom-style 默认值 none none 无轮廓 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓，两条单线与其间隔的和等于指定的border-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 16.border-bottom-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 17.border-left 默认值 看独立属性 [ border-top-width ] 设置或检索对象的左边边框宽度 [ border-top-style ] 设置或检索对象的左边边框样式 [ border-top-color ] 设置或检索对象的左边边框颜色 18.border-left-width 默认值 medium &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 19.border-left-style 默认值 none none 无轮廓 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓，两条单线与其间隔的和等于指定的border-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 20.border-left-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 21.border-image 默认值 none(border-image-source),100%(border-image-slice),1(border-image-width),0(border-image-outset),stretch(border-image-repeat) none 无背景图案 &lt;url&gt; 使用绝对或相对地址指定图像 &lt;number&gt; 用浮点数指定宽度，不允许负值 &lt;percentage&gt; 用百分比指定宽度，不允许负值 &lt;length&gt; 用长度值指定宽度，不允许负值 stretch 指定用拉伸方式来填充边框背景图 repeat 指定用平铺方式来填充边框背景图，当图片碰到边界时，如果超过则被截断 round 指定用平铺方式来填充边框背景图，图片会根据边框的尺寸动态调整图片的大小直至正好可以铺满整个边框 22.border-radius 默认值 0 &lt;length&gt; 用长度值设置对象的圆角半径长度，不允许负值 &lt;percentage&gt; 用百分比设置对象的圆角半径长度，不允许负值 23.border-top-left-radius 默认值 0 &lt;length&gt; 用长度值设置对象的左上角圆角半径长度，不允许负值 &lt;percentage&gt; 用百分比设置对象的左上角圆角半径长度，不允许负值 24.border-top-right-radius 默认值 0 &lt;length&gt; 用长度值设置对象的右上角圆角半径长度，不允许负值 &lt;percentage&gt; 用百分比设置对象的右上角圆角半径长度，不允许负值 25.border-bottom-right-radius 默认值 0 &lt;length&gt; 用长度值设置对象的右下角圆角半径长度，不允许负值 &lt;percentage&gt; 用百分比设置对象的右下角圆角半径长度，不允许负值 26.border-bottom-left-radius 默认值 0 &lt;length&gt; 用长度值设置对象的左下角圆角半径长度，不允许负值 &lt;percentage&gt; 用百分比设置对象的左下角圆角半径长度，不允许负值 27.box-shadow 默认值 none none 无阴影 &lt;length…&gt; 第一个长度值用来设置对象的阴影水平偏移值，可负；第二个长度值用来设置对象的阴影垂直偏移值，可负；若提供第三个长度值，用来设置对象的阴影模糊值，不允许为负；若提供第四个长度值，用来设置对象的阴影外延值，不允许为负 &lt;color&gt; 设置对象的阴影的颜色 inset 设置对象的阴影类型为内阴影；该值为空时，则对象的阴影类型为外阴影 28.box-reflect 默认值 none none 无倒影 &lt;direction&gt; above 指定倒影在对象的上边 below 指定倒影在对象的下边 left 指定倒影在对象的左边 right 指定倒影在对象的右边 &lt;offset&gt; &lt;length&gt; 用长度值来定义倒影与对象之间的间隔，可负 &lt;percentage&gt; 用百分比来定义倒影与对象之间的间隔，可负 &lt;mask-box-image&gt; none 无遮罩图像 &lt;url&gt; 使用绝对或相对地址指定遮罩图像 &lt;linear-gradient&gt; 使用线性渐变创建遮罩图像 &lt;radial-gradient&gt; 使用径向(放射性)渐变创建遮罩图像 &lt;repeating-linear-gradient&gt; 使用重复的线性渐变创建背遮罩像 &lt;repeating-radial-gradient&gt; 使用重复的径向(放射性)渐变创建遮罩图像 八、背景1.background 默认值 看独立属性 background-color 指定对象的背景颜色 background-image 指定对象的背景图像，可以是真实图片路径或使用渐变创建的“背景图像” background-repeat 指定对象的背景图像如何铺排填充 background-attachment 指定对象的背景图像是随对象内容滚动还是固定的 background-position 指定对象的背景图像位置 background-origin 指定对象的背景图像显示的原点 background-clip 指定对象的背景图像向外裁剪的区域 background-size 指定对象的背景图像的尺寸大小 2.background-color 默认值 transparent &lt;color&gt; 指定颜色 3.background-image 默认值 none none 无背景图 &lt;url&gt; 使用绝对或相对地址指定背景图像 &lt;linear-gradient&gt; 使用线性渐变创建背景图像 &lt;radial-gradient&gt; 使用径向(放射性)渐变创建背景图像 &lt;repeating-linear-gradient&gt; 使用重复的线性渐变创建背景图像 &lt;repeating-radial-gradient&gt; 使用重复的径向(放射性)渐变创建背景图像 4.background-repeat 默认值 repeat repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向上平铺 repeat 背景图像在横向和纵向平铺 no-repeat 背景图像不平铺 round 背景图像自动缩放直到适应且填充满整个容器 space 背景图像以相同的间距平铺且填充满整个容器或某个方向 5.background-attachment 默认值 scroll fixed 背景图像相对于窗体固定 scroll 背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动 local 背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容 6.background-position 默认值 0% &lt;percentage&gt; 用百分比指定背景图像填充的位置，可负 &lt;length&gt; 用长度值指定背景图像填充的位置，可负 center 背景图像横向和纵向居中 left 背景图像在横向上填充从左边开始 right 背景图像在横向上填充从右边开始 top 背景图像在纵向上填充从顶部开始 bottom 背景图像在纵向上填充从底部开始 7.background-origin 默认值 padding-box padding-box 从padding区域（含padding）开始显示背景图像 border-box 从border区域（含border）开始显示背景图像 content-box 从content区域开始显示背景图像 8.background-clip 默认值 border-box padding-box 从padding区域（不含padding）开始向外裁剪背景 border-box 从border区域（不含border）开始向外裁剪背景 content-box 从content区域开始向外裁剪背景 text 从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果 9.background-size 默认值 auto &lt;length&gt; 用长度值指定背景图像大小，不允许负值 &lt;percentage&gt; 用百分比指定背景图像大小，不允许负值 auto 背景图像的真实大小 cover 将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器 contain 将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内 10.multiple-background background-image 指定对象的背景图像，可以是真实图片路径或使用渐变创建的“背景图像” background-repeat 指定对象的背景图像如何铺排填充 background-attachment 指定对象的背景图像是随对象内容滚动还是固定的 background-position 指定对象的背景图像位置 background-origin 指定对象的背景图像显示的原点 background-clip 指定对象的背景图像向外裁剪的区域 background-size 指定对象的背景图像的尺寸大小 九、颜色1.color &lt;color&gt; 指定颜色 2.opacity 默认值 1 &lt;number&gt; 使用浮点数指定对象的不透明度。值被约束在[0.0-1.0]范围内，如果超过了这个范围，其计算结果将截取到与之最相近的值 十、字体1.font 默认值 看独立属性 &lt;font-style&gt; 指定文本字体样式 &lt;font-variant&gt; 指定文本是否为小型的大写字母 &lt;font-weight&gt; 指定文本字体的粗细 &lt;font-size&gt; 指定文本字体尺寸 &lt;line-height&gt; 指定文本字体的行高 &lt;font-family&gt; 指定文本使用某个字体或字体序列 caption 使用有标题的系统控件的文本字体（如按钮，菜单等） icon 使用图标标签的字体 menu 使用菜单的字体 message-box 使用信息对话框的文本字体 small-caption 使用小控件的字体 status-bar 使用窗口状态栏的字体 2.font-style 默认值 normal normal 指定文本字体样式为正常的字体 italic 指定文本字体样式为斜体，对于没有斜体变量的特殊字体，将应用oblique oblique 指定文本字体样式为倾斜的字体 3.font-variant 默认值 normal normal 正常的字体 small-caps 小型的大写字母字体 4.font-weight 默认值 normal normal 正常的字体，相当于number为400 bold 粗体，相当于number为700 bolder 特粗体，也相当于strong和b对象的作用 lighter 细体 &lt;integer&gt; 用数字表示文本字体粗细。取值范围：100 5.font-size 默认值 medium &lt;absolute-size&gt; 根据对象字体进行调节，可选参数值：xx-small &lt;relative-size&gt; 对于父对像中字体尺寸进行相对调节，使用成比例的em单位计算，可选参数值：smaller &lt;length&gt; 用长度值指定文字大小，不允许负值 &lt;percentage&gt; 用百分比指定文字大小，其百分比取值是基于父对象中字体的尺寸，不允许负值 6.font-family 默认值 由浏览器确定 &lt;family-name&gt; = arial georgia &lt;generic-family&gt; = cursive fantasy 7.font-stretch 默认值 normal ultra-condensed 比正常文字宽度窄4个基数 extra-condensed 比正常文字宽度窄3个基数 condensed 比正常文字宽度窄2个基数 semi-condensed 比正常文字宽度窄1个基数 normal 正常文字宽度 semi-expanded 比正常文字宽度宽1个基数 expanded 比正常文字宽度宽2个基数 extra-expanded 比正常文字宽度宽3个基数 ultra-expanded 比正常文字宽度宽4个基数 十一、文本1.text-indent 默认值 0 &lt;length&gt; 用长度值指定文本的缩进，可负 &lt;percentage&gt; 用百分比指定文本的缩进，可负 2.text-overflow 默认值 clip clip 当对象内文本溢出时不显示省略标记（…），而是将溢出的部分裁切掉 ellipsis 当对象内文本溢出时显示省略标记（…） 3.text-align 默认值 start left 内容左对齐 center 内容居中对齐 right 内容右对齐 justify 内容两端对齐，写本文档时仅Firefox能看到正确效果 start 内容对齐开始边界 end 内容对齐结束边界 4.text-transform 默认值 none none 无转换 capitalize 将每个单词的第一个字母转换成大写 uppercase 转换成大写 lowercase 转换成小写 inherit 规定应该从父元素继承text-transform属性的值 5.text-decoration 默认值 看独立属性 [text-decoration-line] 指定文本装饰的种类 [text-decoration-style] 指定文本装饰的样式 [text-decoration-color] 指定文本装饰的颜色 blink 指定文字的装饰是闪烁 6.text-decoration-line 默认值 none none 指定文字无装饰 underline 指定文字的装饰是下划线 overline 指定文字的装饰是上划线 line-through 指定文字的装饰是贯穿线 7.text-decoration-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 8.text-decoration-style 默认值 solid solid 实线 double 双线 dotted 点状线条 dashed 虚线 wavy 波浪线 9.text-shadow 默认值 none none 无阴影 &lt;length&gt; 第一个长度值用来设置对象的阴影水平偏移值，可负；第二个长度值用来设置对象的阴影垂直偏移值，可负；若提供第三个长度值，用来设置对象的阴影模糊值，不允许负值 &lt;color&gt; 设置对象的阴影的颜色 10.text-fill-color &lt;color&gt; 指定文字的填充颜色 11.text-stroke 默认值 看独立属性 [text-stroke-width] 设置或检索对象中的文字的描边厚度 [text-stroke-color] 设置或检索对象中的文字的描边颜色 12.text-stroke-width 默认值 0 &lt;length&gt; 用长度值指定描边厚度，不允许负值 13.text-stroke-color 默认值 采用文本颜色 &lt;color&gt; 指定文字的描边颜色 14.letter-spacing 默认值 normal normal 默认间隔 &lt;length&gt; 用长度值指定间隔，可负 15.word-spacing 默认值 normal normal 默认间隔 &lt;length&gt; 用长度值指定间隔，可负 16.vertical-align 默认值 baseline baseline 将支持valign特性的对象的内容与基线对齐 sub 垂直对齐文本的下标 super 垂直对齐文本的上标 top 将支持valign特性的对象的内容与对象顶端对齐 text-top 将支持valign特性的对象的文本与对象顶端对齐 middle 将支持valign特性的对象的内容与对象中部对齐 bottom 将支持valign特性的对象的文本与对象底端对齐 text-bottom 将支持valign特性的对象的文本与对象顶端对齐 &lt;percentage&gt; 用百分比指定由基线算起的偏移量，可负，基线对于百分数来说就是0% &lt;length&gt; 用长度值指定由基线算起的偏移量，可负，基线对于数值来说为0 17.word-warp 默认值 normal normal 允许内容顶开或溢出指定的容器边界 break-word 内容将在边界内换行，如果需要，单词内部允许断行 18.white-space 默认值 normal pre 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行 nowrap 强制在同一行内显示所有文本，直到文本结束或者遭遇br对象 pre-wrap 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行 pre-line 保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行 normal 默认处理方式 19.direction 默认值 ltr ltr 文本流从左到右 rtl 文本流从右到左 20.unicode-bidi 默认值 normal normal 对象不打开附加的嵌入层，对于内联要素，隐式重排序跨对象边界进行工作 embed 对象打开附加的嵌入层，direction属性的值指定嵌入层，在对象内部进行隐式重排序 bidi-override 严格按照direction属性的值重排序。忽略隐式双向运算规则 21.line-height 默认值 normal normal 允许内容顶开或溢出指定的容器边界 &lt;length&gt; 用长度值指定行高。可以为负值 &lt;percentage&gt; 用百分比指定行高，其百分比取值是基于字体的高度尺寸。可以为负值 &lt;number&gt; 用乘积因子指定行高。可以为负值 22.tab-size 默认值 8 &lt;integer&gt; 用整数值指定制表符的长度，不允许负值 &lt;length&gt; 用长度值指定制表符的长度，不允许负值 十二、列表1.list-style 默认值 看独立属性 [list-style-image] 设置或检索作为对象的列表项标记的图像 [list-style-position] 设置或检索作为对象的列表项标记如何根据文本排列 [list-style-type] 设置或检索对象的列表项所使用的预设标记 2.list-style-image 默认值 none none 不指定图像 &lt;url&gt; 使用绝对或相对地址指定列表项标记图像 3.list-style-position 默认值 outside outside 列表项目标记放置在文本以外，且环绕文本不根据标记对齐 inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐 4.list-style-type 默认值 disc disc 实心圆 circle 空心圆 square 实心方块 decimal 阿拉伯数字 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写英文字母 upper-alpha 大写英文字母 none 不使用项目符号 armenian 传统的亚美尼亚数字 cjk-ideographic 浅白的表意数字 georgian 传统的乔治数字 lower-greek 基本的希腊小写字母 hebrew 传统的希伯莱数字 hiragana 日文平假名字符 hiragana-iroha 日文平假名序号 katakana 日文片假名字符 katakana-iroha 日文片假名序号 lower-latin 小写拉丁字母 upper-latin 大写拉丁字母 十三、表格1.table-layout 默认值 auto auto 默认的自动算法。布局将基于各单元格的内容，表格在每一单元格读取计算之后才会显示出来。速度很慢 fixed 固定布局的算法。在这算法中，水平布局是仅仅基于表格的宽度，表格边框的宽度，单元格间距，列的宽度，而和表格内容无关。也就是说，内容可能被裁切 2.border-collapse 默认值 separate separate 边框独立 collapse 相邻边被合并 3.border-spacing 默认值 0 &lt;length&gt; 用长度值来定义行和单元格的边框在横向和纵向上的间距，不允许负值 4.caption-side 默认值 top top 指定caption在表格上边 bottom 指定caption在表格下边 5.empty-cells 默认值 show hide 指定当表格的单元格无内容时，隐藏该单元格的边框 show 指定当表格的单元格无内容时，显示该单元格的边框 十四、内容1.content 默认值 normal normal 默认值，表现与none值相同 none 不生成任何值 &lt;attr&gt; 插入标签属性值 &lt;url&gt; 使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源） &lt;string&gt; 插入字符串 counter(name) 使用已命名的计数器 counter(name,list-style-type) 使用已命名的计数器并遵从指定的list-style-type属性 counters(name,string) 使用所有已命名的计数器 counters(name,string,list-style-type) 使用所有已命名的计数器并遵从指定的list-style-type属性 no-close-quote 并不插入quotes属性的后标记，但增加其嵌套级别 no-open-quote 并不插入quotes属性的前标记，但减少其嵌套级别 close-quote 插入quotes属性的后标记 open-quote 插入quotes属性的前标记 2.counter-increment 默认值 none none 阻止计数器增加 &lt;identifier&gt; identifier定义一个或多个将被增加的selector，id，或者class &lt;integer&gt; 定义计算器每次增加的数值，可以为负值，默认值是1 3.counter-reset 默认值 none none 阻止计数器复位 &lt;identifier&gt; identifier定义一个或多个将被复位的selector，id，或者class &lt;integer&gt; 定义被复位的数值，可以为负值，默认值是0 4.quotes 默认值 none none content属性的open-quote和close-quote值将不会生成任何标记 &lt;string&gt; 定义content属性的open-quote和close-quote值的标记，2个为一组 十五、用户界面1.outline 默认值 看独立属性 [outline-width] 指定轮廓边框的宽度 [outline-style] 指定轮廓边框的样式 [outline-color] 指定轮廓边框的颜色 2.outline-width 默认值 medium &lt;length&gt; 用长度值来定义轮廓的厚度，不允许负值 medium 定义默认宽度的轮廓 thin 定义比默认宽度细的轮廓 thick 定义比默认宽度粗的轮廓 3.outline-style 默认值 none none 无轮廓。与任何指定的outline-width值无关 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓。两条单线与其间隔的和等于指定的outline-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 4.outline-color 默认值 invert &lt;color&gt; 指定颜色 invert 使用背景色的反色该参数值，目前仅在IE及Opera下有效 5.outline-offset &lt;length&gt; 用长度值来定义轮廓偏移，不允许负值 6.nav-index 默认值 auto auto 元素的导航焦点顺序由客户端自动分配 &lt;number&gt; 用浮点数来定义元素的导航焦点顺序。若某元素的该值等于1则意味着该元素最先被导航。当若干个元素的nav-index值相同时，则按照文档的先后顺序进行导航 7.nav-up 默认值 auto auto 默认顺序 &lt;id&gt; 被导航元素的id &lt;target-name&gt; 框架目标页面之间的元素焦点导航 8.nav-right 默认值 auto auto 默认顺序 &lt;id&gt; 被导航元素的id &lt;target-name&gt; 框架目标页面之间的元素焦点导航 9.nav-down 默认值 auto auto 默认顺序 &lt;id&gt; 被导航元素的id &lt;target-name&gt; 框架目标页面之间的元素焦点导航 10.nav-left 默认值 auto auto 默认顺序 &lt;id&gt; 被导航元素的id &lt;target-name&gt; 框架目标页面之间的元素焦点导航 11.cursor 默认值 auto 其他值 auto 12.zoom 默认值 normal normal 使用对象的实际尺寸 &lt;number&gt; 用浮点数来定义缩放比例，不允许负值 &lt;percentage&gt; 用百分比来定义缩放比例，不允许负值 13.box-sizing 默认值 content-box content-box padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )此属性表现为标准模式下的盒模型 border-box padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )此属性表现为怪异模式下的盒模型 14.resize 默认值 none none 不允许用户调整元素大小 both 用户可以调节元素的宽度和高度 horizontal 用户可以调节元素的宽度 vertical 用户可以调节元素的高度 15.ime-mode 默认值 auto auto 不影响IME的状态 normal 正常的IME状态 active 指定所有使用ime输入的字符，即激活本地语言输入法。用户仍可以撤销激活ime inactive 指定所有不使用ime输入的字符，即激活非本地语言。用户仍可以撤销激活ime disabled 完全禁用ime。对于有焦点的控件(如输入框)，用户不可以激活ime 十六、多栏1.columns 默认值 看独立属性 [column-width] 设置或检索对象每列的宽度 [column-count] 设置或检索对象的列数 2.column-width 默认值 auto &lt;length&gt; 用长度值来定义列宽。不允许负值 auto 根据column-count自定分配宽度 3.column-count 默认值 auto &lt;integer&gt; 用整数值来定义列数，不允许负值 auto 根据column-width自定分配宽度 4.column-gap 默认值 normal &lt;length&gt; 用长度值来定义列与列之间的间隙，不允许负值 normal 与font-size大小相同。假设该对象的font-size为16px，则normal值为16px，类推 5.column-rule 默认值 看独立属性 [column-rule-width] 设置或检索对象的列与列之间的边框厚度 [column-rule-style] 设置或检索对象的列与列之间的边框样式 [column-rule-color] 设置或检索对象的列与列之间的边框颜色 6.column-rule-width 默认值 medium &lt;length&gt; 用长度值来定义边框的厚度，不允许负值 medium 定义默认厚度的边框 thin 定义比默认厚度细的边框 thick 定义比默认厚度粗的边框 7.column-rule-style 默认值 none none 无轮廓。column-rule-color与column-rule-width将被忽略 hidden 隐藏边框 dotted 点状轮廓 dashed 虚线轮廓 solid 实线轮廓 double 双线轮廓。两条单线与其间隔的和等于指定的column-rule-width值 groove 3D凹槽轮廓 ridge 3D凸槽轮廓 inset 3D凹边轮廓 outset 3D凸边轮廓 8.column-rule-color 默认值 采用文本颜色 &lt;color&gt; 指定颜色 9.column-span 默认值 none none 不跨列 all 横跨所有列 10.column-fill 默认值 auto auto 列高度自适应内容 balance 所有列的高度以其中最高的一列统一 11.column-break-before 默认值 auto auto 既不强迫也不禁止在元素之前断行并产生新列 always 总是在元素之前断行并产生新列 avoid 避免在元素之前断行并产生新列 12.column-break-after 默认值 auto auto 既不强迫也不禁止在元素之后断行并产生新列 always 总是在元素之后断行并产生新列 avoid 避免在元素之后断行并产生新列 13.column-break-inside 默认值 auto auto 既不强迫也不禁止在元素内部断行并产生新列 avoid 避免在元素内部断行并产生新列 十七、2D变换1.transform 默认值 none none 无转换 matrix(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;) 以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，相当于直接应用一个[a,b,c,d,e,f]变换矩阵 translate(&lt;length&gt;[, &lt;length&gt;]) 指定对象的2D translation（2D平移）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 translateX(&lt;length&gt;) 指定对象X轴（水平方向）的平移 translateY(&lt;length&gt;) 指定对象Y轴（垂直方向）的平移 rotate(&lt;angle&gt;) 指定对象的2D rotation（2D旋转），需先有transform-origin属性的定义 scale(&lt;number&gt;[, &lt;number&gt;]) 指定对象的2D scale（2D缩放）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认取第一个参数的值 scaleX(&lt;number&gt;) 指定对象X轴的（水平方向）缩放 scaleY(&lt;number&gt;) 指定对象Y轴的（垂直方向）缩放 skew(&lt;angle&gt; [, &lt;angle&gt;]) 指定对象skew transformation（斜切扭曲）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 skewX(&lt;angle&gt;) 指定对象X轴的（水平方向）扭曲 skewY(&lt;angle&gt;) 指定对象Y轴的（垂直方向）扭曲 2.transform-origin 默认值 50% 50%，效果等同于center center &lt;percentage&gt; 用百分比指定坐标值。可以为负值 &lt;length&gt; 用长度值指定坐标值。可以为负值 left 指定原点的横坐标为left center 指定原点的横坐标为center right 指定原点的横坐标为right top 指定原点的纵坐标为top center 指定原点的纵坐标为center bottom 指定原点的纵坐标为bottom 十八、过渡1.transition 默认值 看独立属性 [transition-property] 检索或设置对象中的参与过渡的属性 [transition-duration] 检索或设置对象过渡的持续时间 [transition-timing-function] 检索或设置对象中过渡的动画类型 [transition-delay] 检索或设置对象延迟过渡的时间 2.transition-property 默认值 all all 所有可以进行过渡的css属性 none 不指定过渡的css属性 &lt;property&gt; 指定要进行过渡的css属性 3.transition-duration 默认值 0 &lt;time&gt; 指定对象过渡的持续时间 4.transition-timing-function 默认值 ease linear 线性过渡，等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease 平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in 由慢到快，等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out 由快到慢，等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out 由慢到快再到慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier(, , , ) 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 5.transition-delay 默认值 0 &lt;time&gt; 指定对象过渡的延迟时间 十九、动画1.animation 默认值 看独立属性 [animation-name] 检索或设置对象所应用的动画名称 [animation-duration] 检索或设置对象动画的持续时间 [animation-timing-function] 检索或设置对象动画的过渡类型 [animation-delay] 检索或设置对象动画延迟的时间 [animation-iteration-count] 检索或设置对象动画的循环次数 [animation-direction] 检索或设置对象动画在循环中是否反向运动 [animation-play-state] 检索或设置对象动画的状态 2.animation-name 默认值 none none 不引用任何动画名称 &lt;identifier&gt; 定义一个或多个动画名称(identifier标识) 3.animation-duration 默认值 0 time 指定对象动画的持续时间 4.animation-timing-function 默认值 ease linear 线性过渡，等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease 平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in 由慢到快，等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out 由快到慢，等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out 由慢到快再到慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier(, , , ) 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 5.animation-delay 默认值 0 &lt;time&gt; 指定对象动画延迟的时间 6.animation-iteration-count 默认值 1 infinite 无限循环 &lt;number&gt; 指定对象动画的具体循环次数 7.animation-direction 默认值 normal normal 正常方向 alternate 正常与反向交替 8.animation-play-state 默认值 running running 运动 paused 暂停 9.animation-fill-mode 默认值 none none 默认值。不设置对象动画之外的状态 forwards 设置对象状态为动画结束时的状态 backwards 设置对象状态为动画开始时的状态 both 设置对象状态为动画结束或开始的状态 二十、打印1.page 默认值 auto auto 参照当前的默认页面 &lt;identifier&gt; 指定@page规则下的页面类型定义 2.page-break-before 默认值 auto auto 如果需要，在对象之前插入页分割符 always 始终在对象之前插入页分割符 avoid 避免在对象前面插入页分割符 left 在对象前面插入页分割符直到它到达一个空白的左页边 right 在对象前面插入页分割符直到它到达一个空白的右页边 3.page-break-after 默认值 auto auto 如果需要，在对象之后插入页分割符 always 始终在对象之后插入页分割符 avoid 避免在对象后面插入页分割符 left 在对象后面插入页分割符直到它到达一个空白的左页边 right 在对象后面插入页分割符直到它到达一个空白的右页边 4.page-break-inside 默认值 auto auto 如果需要，在当前对象内部插入页分割符 avoid 避免在当前对象内部插入页分割符 二十一、媒体查询1.width &lt;length&gt; 用长度值来定义宽度。不允许负值 2.height &lt;length&gt; 用长度值来定义高度。不允许负值 3.device-width &lt;length&gt; 用长度值来定义宽度。不允许负值 4.device-height &lt;length&gt; 用长度值来定义高度。不允许负值 5.orientation portrait 指定输出设备中的页面可见区域高度大于或等于宽度 landscape 除portrait值情况外，都是landscape 6.aspect-ratio &lt;ratio&gt; 指定比率 7.device-aspect-ratio &lt;ratio&gt; 指定比率 8.color &lt;integer&gt; 用用整数值来定义彩色原件数。不允许负值 9.color-index &lt;integer&gt; 用用整数值来定义彩色查询表中的条目数。不允许负值 10.monochrome &lt;integer&gt; 用整数值来定义宽度。不允许负值 11.scan progressive 连续扫描 interlace 交织扫描 12.grid &lt;integer&gt; 用整数值来定义是否使用栅格或点阵。只有1和0才是有效值，1代表是，0代表否 二十二、IE1.scrollbar-3dlight-color 默认值 threedlightshadow &lt;color&gt; 指定颜色 2.scrollbar-darkshadow-color 默认值 threeddarkshadow &lt;color&gt; 指定颜色 3.scrollbar-highlight-color 默认值 threedhighlight &lt;color&gt; 指定颜色 4.scrollbar-shadow-color 默认值 threedshadow &lt;color&gt; 指定颜色 5.scrollbar-arrow-color 默认值 buttontext &lt;color&gt; 指定颜色 6.scrollbar-face-color 默认值 threedface &lt;color&gt; 指定颜色 7.scrollbar-track-color 默认值 transparent &lt;color&gt; 指定颜色 8.scrollbar-base-color 默认值 transparent &lt;color&gt; 指定颜色 9.filter &lt;filter&gt; 要使用的滤镜效果。多个滤镜之间用空格隔开 10.behavior &lt;url&gt; 使用绝对或相对地址指定DHTML行为组件（.htc） url(#objID) 用二进制实现DHTML行为，#objID为object对象指定的id特性 url(#default#behaviorName) E的默认行为。由behaviorName指定 二十三、Firefox1.border-colors &lt;color&gt; 指定颜色 2.border-top-colors &lt;color&gt; 指定颜色 3.border-right-colors &lt;color&gt; 指定颜色 4.border-bottom-colors &lt;color&gt; 指定颜色 5.border-left-colors &lt;color&gt; 指定颜色 二十四、webkit1.text-fill-color &lt;color&gt; 指定颜色 2.text-stroke [text-stroke-width] 设置或检索对象中的文字的描边厚度 [text-stroke-color] 设置或检索对象中的文字的描边颜色 3.text-stroke-width &lt;length&gt; 用长度值指定描边厚度，不允许负值 4.text-stroke-color &lt;color&gt; 指定文字的描边颜色 5.text-reflect 默认值 none none 无倒影 above 指定倒影在对象的上边 below 指定倒影在对象的下边 left 指定倒影在对象的左边 right 指定倒影在对象的右边 &lt;length&gt; 用长度值来定义倒影与对象之间的间隔，可负 &lt;percentage&gt; 用百分比来定义倒影与对象之间的间隔，可负 none 无遮罩图像 &lt;url&gt; 使用绝对或相对地址指定遮罩图像 &lt;linear-gradient&gt; 使用线性渐变创建遮罩图像 &lt;radial-gradient&gt; 使用径向(放射性)渐变创建遮罩图像 &lt;repeating-linear-gradient&gt; 使用重复的线性渐变创建背遮罩像 &lt;repeating-radial-gradient&gt; 使用重复的径向(放射性)渐变创建遮罩图像 ​","path":"2022/04/01/css-shu-xing-su-cha-biao/","date":"04-01","excerpt":"","tags":[{"name":"CSS","slug":"CSS","permalink":"https://jia_k3.gitee.io/blog/tags/CSS/"}]},{"title":"《系统分析与设计》课程笔记","text":"​ 一、概述1.基本概念1.1系统：从抽象意义上讲，系统是一组为实现共同目标而相互关联、相互作用的部件。 1.2系统的三层含义： （1）系统是由若干个部件组成的（可以根据系统大小划分为子系统） （2）系统的部件间是相互关联、相互作用的 （3）系统有一个实现目标（该目标是系统功能的综合表现） 1.3信息系统：是一种专门类型的系统，主要用于对信息进行采集、输入、处理、输出、存储、传播以及对信息进行管理。 1.4信息系统的三层含义： （1）信息系统功能：信息输入、信息输出、信息处理、信息存储、信息传播、信息管理 （2）信息系统是一种人造系统 （3）信息系统是一种自动系统 2.信息系统的分类2.1信息系统的分类： 2.1.1应用于科学计算的信息系统——偏重于纯粹的数值计算 2.1.2应用于企业管理的信息系统——偏重于非数值信息处理 2.2信息系统组成：硬件、软件、数据、过程和人 2.2.1系统：一个能够产生特定结果的相关构件的集合 2.2.2信息系统：以信息作为输入\\输出对象，以计算机软、硬件为核心的系统 2.2.3现代信息系统：以Internet为基础的信息系统 2.3硬件：由信息系统的物理层的各项组成 2.4数据：数据是信息系统生成有用信息的原材料 2.5过程：定义用户、经理、职员所执行的要达到指定结果的任务和企业功能 2.6人：同信息系统打交道的所有人员 2.7企业信息系统主要类型：决策支持系统、执行信息系统、通信办公系统、事务处理系统、管理信息系统 2.8实习或工作中常见信息系统类型： 2.8.1产品类系统：游戏软件、金山WPS、杀毒软件系统 2.8.2项目类系统：电子商务平台、嵌入式系统、管理信息系统、ERP系统 3.系统开发角色分工及任务3.1一个软件产品或者软件工程，参与角色通常包括：高级经理（战略部署、风险控制、资源提供）、产品经理或项目经理（制定计划、协调资源、关注和控制进度、控制客户期望值）、开发经理（确定架构、开发工具，组织编码实现）、系统分析员（需求分析师、架构设计师、功能设计师）、测试经理（制订测试方案，组织测试）、程序员（编码实现、单元测试）、测试人员（按测试方案测试）、业务顾问（甲方派出，负责业务咨询和确认）、实施人员（系统安装、割接、维护） 3.2系统分析员任务：了解客户的需求、建立分析模型、了解系统环境与平台、建立设计模型、编写分析与设计文档 3.3系统分析员产出系统分析说明书和系统设计说明 4.系统开发方法介绍4.1宏观上（从过程管理角度）： （1）开发模型：瀑布、演化、螺旋、增量等 （2）过程管理：RUP（统一软件开发过程）、RAD（快速应用程序开发）、MSF（微软解决方案框架）、JAD（联合应用软件开发）、Agile系列方法（XP、SCRUM等） 4.2微观上（从系统分析、设计、实现角度）：结构化开发方法、面向对象开发方法、基于UML的面向对象开发方法 4.3系统开发方法比较： （1）结构化开发方法：优点（思维自然，符合人们思考问题的方式；总体可控性强；适合偏重数学计算方面的项目）；缺点（不容易描述客观世界的需求；耦合性相对高） （2）面向对象开发方法：优点（符合自然世界的状态，描述自然，思维简单；适合复杂的事务处理、大量信息处理类的项目；耦合性容易降低，容易复用）；缺点（OO模型表达系统需求分析和设计不够充分） （3）基于UML的面向对象开发方法：优点（统一、标准；容易交流；建模工具较多；适合大型信息系统开发）；缺点（模型不容易掌握） 4.4系统分析员的工作职责：参与进行可行性研究；参与制定软件项目开发计划；系统分析（需求获取和描述、需求分析与建模、方案评估及选择）；系统设计（系统架构设计、系统概要设计、系统详细设计、数据库设计、用户界面设计） ​ 二、软件需求与需求获取1.软件需求的定义1.1软件需求： （1）为用户解决问题以达到特定目标所需的能力 （2）系统或系统构件要满足的合同、标准、规范或其他正式文档所需具备的能力 （3）以一种清晰、简洁、一致且无二义性的方式，描述用户对目标软件系统在功能、行为、性能、设计约束等方面的期望，是在开发过程中对未来系统的约束 2.需求的分类2.1需求分类：业务需求、用户需求、功能需求、非功能需求、业务规则、数据定义、约束条件、外部接口需求 2.2业务需求（愿景需求）：客户对于系统的高层次目标要求，定义了项目的远景和范畴（业务、客户、特性、价值、优先级） 2.3用户需求：从用户角度描述的系统功能需求与非功能需求，通常只设计系统的外部行为而不涉及内部特性 2.4功能需求：系统应该提供的功能或服务，通常涉及用户或外部系统与该系统之间的交互，不考虑系统内部的实现细节（描述了系统所展示的可观察的行为） 2.5非功能需求：从各个角度对系统的约束和限制，反映了客户对软件系统质量和性能的额外要求，包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性 2.6业务规则：对某些功能的可执行性或内部执行逻辑的一些限定条件 2.7数据定义：当客户描述一个数据项或一个复杂的业务数据结构的格式、允许值或缺省值时，他们正在进行数据定义 2.8约束条件：系统设计和实现必须满足的限制条件，对其进行权衡或调整是相当困难的，甚至是不可能的 2.9外部接口需求：描述系统与其所处的外部环境之间如何进行交互 2.10产生不合格需求的原因：无足够用户参与、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的规格说明、忽略了用户分类、不准确的计划、 3.需求获取方法3.1需求获取的基本步骤： （1）：了解相关背景和领域/行业的知识，确定产品所期望的用户类 （2）：与客户企业或组织的高层人员进行交流，了解实际用户任务和目标以及这些任务所支持的业务需求 （3）：与客户企业或组织的底层人员进行交流，获取每个用户类的详细的用户需求 （4）：整理需求纪要，发现新问题，并重复1-3步 （5）：需求分类和组织，以区别功能需求、非功能需求、约束条件、业务规则、外部接口需求、建议解决方法和附加信息 （6）：优先排序和冲突解决 （7）：得到最终需求清单，并与客户做最终签字确认 3.2收集现有书面资料：收集现有报表、表格和过程描述；收集现有的工作流程图；分发和收集需求调查表；面对面访谈；需求研讨会；现场观察\\体验；研究供应商的解决方案或现有系统；头脑风暴； 3.3用户面谈注意事项： 3.3.1需求分析者个人的偏见、事先的理解、以往的经验积累是导致面谈失败的最重要原因 3.3.2在面谈时，忘掉一切以往所作的事情，通过问题启发，倾听对方的陈述 3.3.3不要把自己放在“专家”的位置上 3.3.4最开始的问题不能太难 3.3.5不能在提问之前就已经表示不赞同 3.3.6谈话之前有意识的准备一些备用问题 3.3.7一般以开放性问题开始谈话，发现问题；以选择性问题引导；以封闭式问题确认事实；以探究式问题发现真实想法 3.3.8访谈问题分类：上下文无关的问题（不涉及具体的解决方案），解决方案相关的问题 3.3.9面谈之前：确立目的，确定要包括的相关用户，确定参加会议的项目小组成员，建立要讨论的问题和要点列表，复查有关文档和资料，确立时间和地点，通知所有参加者有关会议的目的、时间和地点 3.3.10面谈之中：事先准备一系列上下文无关的问题，并将其记录下来以便面谈时参考；面谈前，了解一下要面谈的客户公司的背景资料，不要选择自己能回答的问题而浪费时间；面谈过程中，参考事先准备的面谈模板，以保证提出的问题是正确的，将答案记录到纸面上，并指出和记录下未回答条目和未解决问题；面谈之后，分析总结面谈记录 3.3.11面谈之后：复查笔记的准确性、完整性和可理解性；把所收集的信息转化为适当的模型和文档；确定需要进一步澄清的问题域；向参加会议的每一个人发出此次面谈的minutes（会议纪要） 3.3.12优点：人们很愿意谈论自己的工作，并且总是很喜欢接受访谈 3.3.13缺点：大多数人都采用专业术语和“行话”，而太多的专业术语让需求工程师难以理解，往往造成很多误解；有些需求对用户来说太普通了，以至于他们不自觉地认为这些需求太基本，不值得去提；但它们对需求工程师来说却不是显而易见的；这往往会造成某些需求被忽略 3.4头脑风暴注意事项： 3.4.1一般以8-12人最佳 3.4.2明确分工：1名主持人、2名记录员 3.4.3成功要点：自由畅谈，延迟或禁止批判，禁止批评、自我批评、自谦，追求数量 3.4.4会后：修剪、分组、排序 3.4.5适用场合：产品型系统，需要具有创新性特征，尚未投放市场，无明确的客户 三、需求建模1.模型和建模1.1模型的作用：建立模型的过程能帮助分析员澄清和改良设计；系统往往很复杂，模型能很好表示各部分之间的关系；模型便于项目组成员之间交流；模型有助于和系统用户之间进行交流并 促进理解；建立的模型可以作为以后的维护和升级时的文档 1.2模型的类型：数学模型（描述系统技术方面的一系列数学公式）、描述模型（描述系统某些方面的叙述性的备忘录、报表、列表、文字等）、图形模型（描述系统的图表或系统某些方面的示意性表示） 1.3用于分析和设计的模型： 1.3.1分析阶段创建的模型：事件列表、事物列表、结构化方法（系统流程图、决策树\\决策表、实体关系图、数据流图、数据字典、伪代码）、基于UML的OO方法（用例图、用例场景描述、分析类图、活动图、状态图、时序图\\协作图） 1.3.2设计阶段创建的模型：体系结构图、界面布局图、（系统结构图、程序流程图）、（设计类图、时序图、包图、组件图、网络图、部署图） 2.事件和系统需求2.1事件：发生在某一特定的时间和地点、可描述并且系统应该记录下来的事情 2.2事件和系统需求的关系：事件发生时需要系统做出响应，能列出所有这样的事件就可以搞清楚用户对系统的需求；信息系统的所有处理过程都是由事件驱动\\触发的；当定义系统需求时将所有事件罗列出来并加以分析是非常有意义的 2.3事件分类：外部事件（系统之间发生的事件，通常是由外部实体或系统参与者触发的）、临时事件（由于到达某一时刻所发生的故事）、状态事件（当系统内部发生了需要处理的情况时所引发的事件） 2.4区分事件和随事件发生的一部分交互行为：导致 影响系统的一个事件 的一系列行为，不能都算作“事件” 2.5跟踪事务处理生命周期可以得到一系列事件：导致许多事件的某一特定客户的“事务”处理序列，都算作“事件” 2.6事件定义：特别细节的事件在系统分析阶段不予考虑，它们是“事件”，但在设计阶段之前可以忽略 2.7系统需求建模：事件列表（描述性模型） ​ 3.事物和系统需求3.1事物：在传统的开发方法中，事物就是构成系统存储信息的相关数据；在面向对象的开发方法中，事物就是在系统中相互交互的对象 3.2事件和事物的区别与联系： 3.2.1事件：发生在瞬间，有一定的随机性 3.2.2事物：客观存在，不以主观意志为转移 3.2.3联系：事件的发生可以改变事物的状态或产生新的事物 3.3事物的类型：实物、角色、组织部门、设备、偶发事件（活动、交互）、地点\\位置 3.4建立事物列表的过程： 3.4.1收集可能得到的名词：谈话、事件表、其他需求获取过程 3.4.2将名词列表精简并确认 3.5事物间的关系：某些事物间自然发生的联系 3.6基数（重数）：发生在事物间关联的数目 3.7事物的属性：属性（有关事物的一条特定信息）、标示符（关键字）（能唯一标志事物的一个属性）、复合属性（包含了许多相关属性的属性） 3.8数据实体：在传统的系统开发方法中，事物被称为数据实体 3.9对象将数据和处理数据的方法封装成一个单元 4.实物-关系图(ERD)​ 4.1分析员在建模的过程中，常常对ERD进行细化的工作就是处理多对多的关系 4.2由于关系数据库中不能直接实现多对多的关系，因此必须建立一个单独的表，来消除多对多的关系 4.3关联实体 – 解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字 5.类图5.1面向对象的方法给事物建立的模型即为“类图” 5.2泛化/具体层次图：把类按照从最概括的父类到最具体的子类的顺序进行排列的层次图，有时也被称作继承层次图 5.3整体/局部层次类：按照类之间的关联组件将类进行结构化分解的层次图 5.4抽象类：一种不能被实例化的类，仅为了使其子类能够继承他的属性与方法；具体类：能够被实例化的类；关联类：一种表示两种不同类之间多对多的关系的类 6.用户故事与用例建模：6.1在敏捷开发中，需求表述为一组“用户故事”；在传统的OO分析方法中，需求被表述为一组“用例” 6.2两者都是对需求的描述形式 6.2区别在于大小不同、具体形式不同。对初学者来说，可以将二者看作等价模型，在实践中汇集二者的优点 6.3用户故事：对软件用户（或所有者）有价值的功能性的简明的书面描述 6.4从用户角度来描述用户渴望得到的软件功能：角色、目标/活动、商业价值 6.5三个组成部分：卡片（一般在小卡片上写着故事的简短描述、工作量估算）、交谈（用户故事背后的细节来源于和客户或者产品负责人的交流沟通）、确认（验收确认） 6.6好的用户故事应该具备的特征：独立、可讨论、有价值、工作量可估计、小、可测试、可验收 6.7用例：表示系统所提供的服务或可执行的某种行为（站在用户角度定义软件系统的外部特性） 6.8用例的四大特征：行为序列（一个用例由一组可产生某些特定结果的不可再分的行为构成），系统执行（系统为外部角色提供服务），可观测到的、有价值的结果，特定的角色 6.9用例模型构成元素：参与者（小人）、用例（椭圆）、通讯关联（箭头） 6.10用例方法的优点：系统被看作是一个黑箱，并不关心系统内部是如何完成它所提供的功能的 6.11用例建模的基本过程：识别并描述参与者；识别用例，并给出简要描述；识别参与者与角色之间的通讯关联；给出每一个用例的详细描述；细化用例模型 6.12特殊的参与者：系统时钟（应用于系统自检做操作） 6.13事件流：常规流和备选流（描述用例执行过程中异常的或偶尔发生的一些情况） 6.14注意问题：用例的粒度；用例是actor与系统的交互；actor与系统的区分 四、系统分析1.结构化方法与面向对象方法1.1结构化方法：复杂世界转换为复杂处理过程；设计一系列功能以解决若干问题；寻找适当的方法存储数据 1.2面向对象方法：任何系统都是由能够完成一组相关任务的对象构成；如果对象依赖于一个不属于不属于它负责的任务，那么就需要访问负责此任务的另一个对象（调用其他对象的方法）；一个对象不能直接操作另一个对象内部的数据，它也不能使其它对象直接访问自己的数据；所有的交流都必须通过方法调用 1.3结构化开发方法：思想方法（自顶向下、问题分解、分而治之、由分到和）；表达模型（分析模型：系统流程图、数据流图、ERD、数据字典；设计模型：系统结构图、程序流程图、ERD）；分析与设计线索（面向过程：过程驱动；面向数据：数据驱动）；优点：思维自然，符合人们思考问题的方式，总体可控性强，适合偏重数学计算方面的项目；缺点：不容易描述客观世界的需求，耦合性相对高 1.4面向对象开发方法：思想方法（从客观世界的具体事物出发构建系统；自底向上，先考虑对象，再考虑行为）；表达模型（类层次结构图：对象的属性、行为、继承、消息连接）；优点：符合自然世界的状态，描述自然，思维简单，适合复杂的事务处理、大量信息处理类的项目，耦合性容易降低，容易复用；缺点：OO模型表达系统需求分析和设计不够充分 1.5基于UML的面向对象开发方法：思想方法（开发一整套系统分析与设计模型及描述方法，从形式上和概念上统一描述软件系统）；表达模型（UML图）；优点：统一标准、容易交流、建模工具较多、适合大型信息系统；缺点：模型不容易掌握 2.结构化的系统分析方法2.1结构化分析方法（SA）：将待解决的问题看作一个系统，从而用系统科学的思想方法来分析和解决问题 2.2核心思想：自顶向下的分解 2.3结构化分析：帮助开发人员定义系统需要做什么，系统需要存储和使用那些数据，系统需要什么样的输入和输出以及如何把这些功能结合在一起来完成任务 3.数据流图（DFD）3.1数据流图：用处理、外部实体、数据流以及数据存储来表示系统需求的图表 3.2DFD的特点：图形元素少且符号简单易懂；较充分表达系统的主要需求：输入、输出、处理和数据存储；最终用户、管理人员和系统开发人员只需要稍加培训即可读懂DFD图，方便交流 3.3DFD数据流图的符号说明： ​ 3.4DFD图可以描述高层次的具有高度概括的系统处理，也可以描述低层次的具有更详细分解的系统处理 3.5抽象层次：把系统分解成一个逐步细化的分层集合的建模技术（关联DFD\\0层DFD\\1层DFD） 3.6关联DFD图：在单个处理符号中概括系统内所有处理活动的DFD（在表达系统边界时用处很大；当一个系统响应事件较多时，常常将系统分成多个子系统，并未每个子系统创建一张关联图；数据存储不画在关联图中是因为它本身被认为是系统内部的内容） 3.7DFD片段：用一个单一处理符号表示系统响应一个系统的DFD（在DFD片段中，展示了处理、外部实体和内部数据存储之间的交互细节；每个DFD片段仅显示要响应该事件的相关的那些数据存储；一个DFD片段是为事件表中的每一个事件创建的） 3.8DFD的0层图：将一个系统或子系统的所有DFD片段组合到一个单个的DFD图中，这样的DFD图称为事件分离的系统模型/0层图 3.9DFD的层次：分解“处理”，形成1、2、、、层DFD图 3.10高质量的DFD：可读性强、内容一致、能够准确描述系统需求 3.11措施：最小化复杂度（就是使每幅DFD图尽量简单易懂，避免信息超量，分层，DFD图的7+-2规则，接口最小化），保持数据流一致性（分解处理与原处理数据流内容一致，有数据流入必须有数据流出，反之成立） 3.12构造DFD图的7+-2规则：单个DFD图中不应有超过7+-2个处理，单个DFD中不应超过7+-2个数据流进出同一个处理/数据存储 3.13DFD的质量评估： 3.13.1黑洞：带有输入数据的但并不用其产生输出数据的处理或数据存储 3.13.2奇迹：没有足够数据元素作为输入或产生来源的一个处理或数据存储 3.13.3典型错误： ​ 3.14DFD模型总结：在关联图中不画数据存储；数据流不反映处理顺序，显示数据通过系统的流程，所以处理可以并行工作；“处理/数据存储”既要有输入，又有输出（输入不完全用来产生输出–黑洞；输出不完全依赖于输入–奇迹） 3.15可使用结构化语言来描述处理： ​ 3.16决策表：“处理”逻辑的一种表格形式的表示方法，其中包括决策变量、决策变量值，行为或公式；决策树：用树形结构组织起来的线条对“处理”逻辑进行图形化的描述 4.数据字典（DD）4.1数据字典是数据分析的描述模型，包括数据项定义（定义特定数据项的组成和意义），数据结构定义（定义有数据项组成的表达数据的基本数据），数据流描述（描述数据流的数据构成，并指明其来源或去向），数据存储描述（描述保存在存储介质上的数据文件或数据库表的格式和内容） 4.2广义的数据字典也可以包含对处理的描述 4.3数据项：数据的基本单位（数据项名、数据项说明、数据类型、长度、取值范围、语义定义、与其他数据项的关联） 4.4数据结构：由数据项组成，它给出了数据基本结构单位（数据结构名、数据结构说明、数据结构组成、数据结构约束） 4.5数据流定义：数据结构在系统中的流通路径（数据流名、数据流说明、数据流来源、数据流去向、数据流组成、平均流量、高峰流量） 4.6数据存储：数据结构保存或停留之处，数据文件或数据库表（数据存储名、数据存储说明、输入的数据流、输出的数据流、数据存储组成、数据量、存取频度、存取方式） 4.7数据处理（广义DD）：给出处理的流程和说明信息（数据处理名，数据处理说明，输入数据，输出数据，处理过程简要描述） 5.数据分析（ERD\\IDEF1X）5.1实体关系图-ERD： 5.1.1对DFD中的数据存储的分析非常重要，单独进ERD建模 5.1.2数据存储需求包括数据实体、数据实体的属性以及它们之间的关系 5.1.3分析员在数据建模的过程中，常常对ERD进行细化的工作，即处理多对多的关系以及细化属性说明 5.1.4由于关系数据库中不能直接实现多对多的关系，因此必须建立一个单独的表，来消除多对多的关系 5.15关联实体 – 解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字 5.2类IDEF1X图：含有*..*关系的ERD 6.面向对象的分析6.1步骤：分析业务领域，找出问题解决方案，发现对象，分析对象的内部构成和外部关系，建立软件系统的对象模型 6.2特点：着重分析业务领域和系统责任，建立独立于实现的OOA模型，暂时忽略与系统实现相关的问题 6.3主要使用5种图描述完整的系统需求：用例图、类图、时序图、协作图、状态图 6.4面向对象的分析建模由三类模型构成：功能模型（从用户的角度获取功能需求，由用例模型表示），静态结构模型（分析对象模型：描述系统的概念实体，由类图表示），动态行为模型（描述对象之间的交互行为，由时序图和协作图表示） 6.5面向对象的系统分析：面向对象的分析（OOA）-&gt;OOD-&gt;OOP-&gt;Testing 6.6面向对象分析的过程：业务领域分析-&gt;发现和定义对象和类-&gt;识别对象的外部联系-&gt;建立系统的静态结构模型-&gt;建立系统的动态行为模型 6.6.1业务领域分析：分析应用领域的业务范围、业务规律和业务处理工程，确定系统的责任、范围和边界，确定系统的需求，注重确定交互的内容、步骤和顺序 6.6.2识别对象的外部联系：对象和类是现实世界中的事物的抽象，它们之间的联系也要从分析现实世界事物的各种真实的联系中获得 6.6.3建立系统的静态结构模型：绘制类图、对象图、系统与子系统结构图等，编制相应的说明文档 6.6.4建立系统的动态行为模型：绘制活动图、交互图、状态图等，编制相应的说明文档 6.7建立静态结构模型：从用例描述入手，识别分析类 6.7.1分析类直接与应用逻辑相关，而不关注与技术实现的问题 6.7.2分析类的类型：实体类（系统存储和管理的持久性信息）、边界类（参与者与系统之间的交互）、控制类（系统在运行过程中的业务控制逻辑） 6.7.3三种分析类之间是多对多关系 6.7.4边界类应关注于参与者与用例之间交互的信息或者响应的事件，不要描述窗口组件等界面的组成元素 6.7.5当用例比较复杂时，特别是参与分支事件流的情况下，一个用例可以有多个控制类 6.7.6角色(actor)不一定是实体类 6.8描述分析类的属性： 6.8.1常识、基本构成、问题域、系统责任、对象需要系统保存的信息、服务功能、状态、表示整体与部分结构和实例连接 6.8.2对UI类型的边界类：输入、反馈、临时数据 6.8.3对API类型的边界类：传递与接收的数据 6.8.4控制类的属性：从UI接收的数据、临时数据、实体类、发送给UI的数据 6.8.5实体类的属性：基本属性、状态属性、关联属性（确定连接结构）、派生属性（计算其他属性得到） 6.9定义分析类的操作： 6.9.1动词分析、操作数据、执行计算、请求状态、监视事件 6.9.2边界类的操作：验证输入、用户在UI上进行的操作、临时处理控制类、提供其他系统用的API 6.9.3控制类的操作：临时处理边界类数据、调用实体类、临时处理实体类数据 6.9.4实体类的操作：属性操作、状态更新、业务操作 6.10建立动态行为模型：（时序图\\顺序图、协作图） 6.10.1时序图：将用户与分析类结合在一起，实现将用例的行为分配到所识别的分析类中（强调消息时间顺序的交互图） 6.10.2时序图将交互关系表示为一个二维图：纵轴是时间图，时间沿竖线向下延伸；横轴代表了在协作中各独立的对象 6.10.3消息：可以激发某个操作、唤起信号或导致目标对象的创建或撤销（箭头表示调用指向对象的操作） ​ 6.10.4激活表示该对象被占用以完成某个任务，去激活指的是对象处于空闲状态、在等待消息 6.10.5如果对象位于时序图的顶端，说明在交互开始之前该对象已经存在；若对象是在交互的过程中创建，它应该位于图的中间部分；如果要撤销一个对象，只需要在其生命线终止点放置一个X即可，该点通常是对删除或取消消息的回应 五、系统设计1.结构化的系统设计1.1结构化的系统设计主要考虑：模块的层次化、模块之间的接口、数据库设计、用户界面设计 1.2自动化系统边界划分：将数据流图划分为手工处理部分和系统能自动完成的部分；程序的处理过程可以在系统边界内部或外部；数据流可以在系统边界内部或外部；穿过系统界线的系统的输入和输出；在最终的系统中，数据流将成为用户界面中的表单、报表、供其他系统使用的数据文件 1.2.1划分对象是DFD数据流图 1.2.2划分结果要分辨自动化系统边界与程序边界，其中自动化系统边界将整个DFD图划分为几个大部分，程序边界将自动化系统划分为几个程序 1.3结构图： 1.3.1定义：以模块为基础、以模块间的调用为关联所构成的图称为模块结构图，简称结构图 1.3.2作用：通过层次的方法来描述系统每部分的功能和子功能，展示计算机程序模块间的联系 1.3.3结构图符号： ​ 1.4结构图的创建方法：（从DFD片段到结构图的过程） 1.4.1确定主要的信息流 1.4.2找出能代表输入和输出间最基本变化的过程 1.4.3重画数据流图并把输入放在最左边，输出放在右边 1.4.4初步建立一个结构图草图 1.4.5加入其他模块实现功能：数据输入、数据处理、数据输出 1.4.6使用结构化语言或决策树添加模块间逻辑 1.4.7进一步求精 1.4.8转换分析方法：“处理”对输入到输出的转换(I-P-O)，结构图包括输入子树、计算子树和输出子树，用数据流图片段作为输入 1.4.9事务分析方法：含有“处理”分支的情况；某“处理”对输入数据流进行分析，根据分析结果选择不同的“处理” 1.5DFD-&gt;系统结构图的基本模式 1.5.1简单变换型：-a-&gt;(A)-b-&gt;(B)-c-&gt;(C)-d-&gt; 不考虑扇入扇出度： ​ 考虑扇出度&lt;=3： ​ 1.5.2复杂变换型： ​ 不考虑扇出度： ​ 考虑扇出度&lt;=3： ​ 1.5.3事务型： ​ 考虑扇出度&lt;=3： ​ 1.5.4事务型与变换型混合： 步骤：化简（将事务型与复杂变换型独立为一个模块）-&gt;将化简后的DFD图转换成结构图-&gt;拓展事务处理和复杂变换模块-&gt;整体拼合-&gt;降低复杂度处理 ​ 2.面向对象设计2.1概述： 2.1.1与传统的结构化方法的分析阶段与设计阶段清楚分开相比，面向对象的设计各阶段均采用统一的“对象”概念，各阶段之间区分不明显 2.1.2基本元素：设计类（对应OOA分析类）-&gt;包-&gt;子系统-&gt;完整系统 2.1.3面向对象设计的两个阶段：系统设计（概要设计，解决问题的途径，系统结构与风格）；对象设计（详细设计，在系统所需的应用对象与可复用的商业构件之间建立关联） 2.2系统设计：设计系统的体系结构，识别设计元素，部署子系统，定义数据的存储策略，检查系统设计（检查正确性、一致性、完整性、可行性） 2.3包的设计：把在语义上接近且倾向于一起变化的类组织在一起形成“包”；包因其中的类有可能有依赖和泛化关系；UML中的包为广义概念，不同于Java包的狭义概念； 2.4对象设计：细化需求分析和系统设计阶段产生的模型，确定新的设计对象，消除问题域与实现域之间的差距 2.4.1步骤：创建初始设计类，细化属性，细化操作，定义状态，细化关系 六、数据库设计1.数据库系统及关系数据库简介1.1数据库系统=数据库+数据库管理系统 1.2关系数据库管理系统将数据存储成表和关系的结构 1.2.1元组：表中的行，习惯称为“记录” 1.2.2域：表中的列，习惯称为“属性” 1.2.3关键属性：每个表中必须包含能唯一标识“记录”的属性或属性组（主键PK，外键FK） 1.3数据库设计的根本任务：获取未来系统需要存储的数据实体；分析数据实体的内涵，以及数据实体之间的关系；设计物理ERD，即用于数据库系统实现的数据表结构的蓝图 1.4数据库设计的基本过程：概念ERD设计（主要用于需求分析过程，仅需给出数据实体以及基本关系），逻辑ERD设计（明确定义每个实体中的属性，识别实体之间的关系基数，并引入关联实体，但不关注物理实现细节），物理ERD设计（定义Table属性的细节以及增加用于表达Table之间关系的新属性） ​ 2.数据库逻辑模型设计2.1步骤：识别“自然”数据实体，为数据实体命名，给出实体的属性，识别实体之间的关联关系及关联重数，建立关联实体（非自然）来消除M:N重关系，实体规范化，评价质量并做必要的改进 2.2复杂ERD分组技巧：可以根据系统功能分组；如果组之间存在相互关联的实体出现，则可以将其画多次，分别在不同的局部ERD中出现 3.ERD模型及质量评价3.1ERD图的设计结果没有标准答案，不唯一 3.2好的ERD图标准：结构清晰，关联简洁，实体个数适中，属性分配合理，没有低级冗余 3.3数据库的规范化： 3.3.1通过最小化数据冗余来确保数据库模型的质量 3.3.2范式(NF)分类： 1NF没有重复的属性或属性组 2NF是1NF且每个非主属性均函数依赖于主属性（主键） 3NF是2NF且非主属性间均不存在函数依赖 3.3.3满足3NF的数据库设计可以做到，但未必是最好的数据库：为了提高运行效率，必须降低凡是标准，适当保留冗余数据；具体：在逻辑模型设计时遵守3NF，降低范式标准的工作放到物理数据模型设计时考虑 4.物理数据库设计及建立4.1步骤：为每个ERD实体创建一个二维表；根据ERD中的实体属性，在对应的Table中定义对应的字段，并给出适当的数据类型的取值范围；定义每个Table的主键；针对1:M关联关系的子表添加外键；定义完整性约束 4.2定义完整性约束：域的完整性（字段的取值范围），参照完整性（PK、FK、表级触发器），用户定义完整性（定义业务规则，用存储过程和触发器来实现） 5.物理数据库提高效率的技巧5.1降低范式、增加冗余；少用触发器、多用存储过程 5.2体外运算：当计算非常复杂、记录数巨大时，以文件系统方式用高级语言计算处理完成之后 5.3水平/垂直分割表： 5.3.1水平分割：记录太多，以PK的某个值为界线将该表的记录水平分隔为两个表 5.3.2垂直分割：将原来的字段分为二组，分别建立二个1:1的表 5.4对数据库管理系统进行系统优化，即优化各种系统参数 5.5在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法 6.分布式数据库的不同的体系结构模型6.1单数据库服务器体系结构 6.2带备份的数据库服务器体系结构 6.3将数据库模式划分为多个客户访问子集 6.4分区数据库服务器体系结构 6.5联合数据库服务体系结构 7.OO实体类图映射到ERD7.1本质：把每一个类、类之间的关系分别映射到一张表或多张关系型数据库的表中 7.2对象关系映射(ORM)：通过使用描述对象和数据库之间映射的元数据，将OO系统中的对象自动持久化到关系数据库中 7.3将对象映射到关系数据库： 7.3.1两个类1:1关联关系：建立一个表，增加PK属性，复制2个类中所有属性；建立1:1关系的2个表，每个表增加PK，分别复制属性，2个表的PK建立关联，建立参照完整性，任何一个表作为主表均可 7.3.2两个类1:*关联关系：建立1:*关系的2个表，每个表增加PK与属性，表2增加FK并与表1PK属性关联 7.3.3两个类*:*关联关系：建立3个表，第3个表为关联表，分别增加PK，表1、表2复制属性，关联表中增加2个FK属性分别与表1、表2中的PK关联，关联表可以增加其他属性 7.3.4三个类循环*:*关联关系： 情况1：3个表紧密关联，任何2个类的关联行为不能缺少第3个类的参与：建立对应的3个表，建立1个关联表，创建3个FK 情况2：3个表仅仅两两相关联：创建3个关联表，每对关联处理方式同7.3.3 7.3.5组合/聚合关联关系：可以理解为1:1或1:*关系 7.3.6继承关系：分别建立父类和子类的3张数据表，形成1:*的类型；分别建立子类的2张数据表，父类并到子类的表中；只建立父类的1张数据表，子类并到父类的表中（三个方法的性能逐次降低） 七、用户界面设计1.用户界面设计的基本概念1.1人机系统模型 ​ 1.2广义的人机界面：在人机系统模型中，人与机器、设备之间存在一个相互作用的“面”，称为人机界面 1.3狭义的人机界面：狭义的人机界面是特指计算机系统中的人机界面，又称为人机接口、用户界面 1.4用户界面的内容：软件用户界面一般包括：界面元素的样式、大小、布局；界面的美观效果；操作序列或功能的隐喻；交互信息 1.5用户界面设计：运用认知心理学、人机工程学、语言学等基础知识对用户界面完成结构设计、交互设计和视觉设计，从而使软件达到易学、易用、美观、高效的目的 1.6用户界面设计的基本过程：研究用户，分析软件的需求；用户界面结构设计（低保真原型）；用户界面的交互设计（高保真原型）；用户界面设计方案评审；迭代修改 1.7美术设计师（关注界面的美观、修饰），UI设计师（关注界面的可用性和用户体验），软件设计师（关注软件界面的实现） 1.8用户界面设计理念：以用户为中心、方便用户、易用高效 1.9用户界面设计标准：可学性（简单易学，用户很快开始工作），效率性，记忆性，容错性，满意度 2.用户界面形式及设计原则2.1用户界面分类： 2.1.1按照计算机发展的历程分：CUI(字符用户界面)-&gt;GUI(图形用户界面)-&gt;MUI(多通道用户界面) 2.1.2从应用软件功能角度分类：操作系统用户界面，文字处理软件用户界面，工业控制系统用户界面，管理信息系统用户界面，网页用户界面，移动工具用户界面，游戏软件用户界面 2.2用户界面风格：一致性风格，个性化风格，传统式风格，古典式风格，现代派风格，高科技风格，卡通式风格，插画式风格 2.3形式与原则： 2.3.1用户界面形式：命令语言界面，菜单界面，数据输入界面，直接操控和WIMP界面，提示、帮助和出错界面 2.3.2用户界面设计总原则：一致性原则，提供信息提示与反馈，合理利用空间、保持界面简洁，合理利用颜色与显示效果，实现内容与形式的统一，恰当使用图形和形象比喻，用户出错宽容性，尽量提供快捷方式，尽量允许操作可逆性，尽量减少用户的记忆性要求，合理的系统响应和低的系统成本，良好的联机帮助 2.4命令语言界面设计 2.4.1优点：功能强大，灵活性好，效率高，占用屏幕空间少 2.4.2缺点：难以学习和记忆，需要一定的键盘输入技巧，出错可能性大 2.4.3命令语言的结构：关键词，关键词+参数，基于语法的语言，基于自然语言 2.4.5命令缩写有以下几种做法：简单截取，去除元音，取第一个字母和最后一个字母，短语中每个词的首字母，着重于发音 2.4.6命令语言界面设计原则：命令词要简单、易记，命令一致性和普及性，命令词和参数应清晰并符合语法习惯，避免不必要的复杂性，允许命令串的重现和修改 2.5菜单界面设计 2.5.1特点：计算机系统驱动，适用于结构化系统，每一菜单项都可以对应于一个子程序功能或下一级菜单，减轻用户学习培训、记忆负担，简化操作，占用一定的屏幕空间和显示时间 2.5.2菜单界面的设计原则：菜单合理分类；菜单标题及菜单项命名一致、简明、有意义；合理组织菜单界面的结构与层次（广而浅）；菜单项的安排应有利于提高菜单选取速度，隔离使用频次高但相邻相似项致使操作的菜单项；保持各级菜单显示格式和操作方式的一致性；为菜单项提供多于一种的选择途径，以及为菜单选择提供捷径；对菜单选择和点取设定反馈标记；设计良好的联机帮助 2.6数据输入界面设计 2.6.1数据输入方式：问答式对话数据输入，菜单选择输入，填表输入，直接操纵输入界面，关键词数据输入，条形码、光学字符识别(OCR)，声音数据输入 2.6.2交互式数据输入界面设计原则：数据输入的一致性，使用户输入减至最少，为用户提供信息反馈，用户输入的灵活性，提供错误监测和修改机构 2.6.3集中数据项布局原则：接近性原则，相似性原则，完整性和闭合性原则 2.6.4显控协调布局原则：重要性原则，操作频率原则，功能分组原则，操作次序原则 2.7直接操纵和WIMP界面设计(WIMP-Windows,Icons,Menus,Pointers/Windows,Icons,Mouse,Pull-down menu) 2.7.1特点：以物理动作或标记按钮代替复杂的语法，用指点和选择代替键盘输入，操作结果立刻可见，具有高度的交互性，支持逆向操作 2.7.2窗口分类：滚动式窗口，开关式窗口，分列式窗口，瓦片式窗口，重叠式窗口，弹出式窗口 2.8提示、帮助和出错界面设计 2.8.1出错处理分析：输入错误（感知误导，记忆特性，响应时间过快或慢），计算错误 2.8.2出错处理的设计原则：错误预防原则（尽量避免相似的命令名，建立一致性的原则和模式，有助于减少学习和错误，提供上下文和状态信息，减少用户的记忆负担，降低对人从事活动的技能要求，使用大屏幕和清晰可视的反馈，减少键盘输入），错误恢复原则（提供恢复功能，在程序运行中提供撤销功能，对重要的有破坏性的命令提供确认措施，以避免破坏性操作） 2.8.3帮助处理系统的设计原则：帮助系统的类型（联机用户手册，练级培训，联机演示），帮助处理设计的基本原则（完整性：有帮助说明、一致性：术语一致、上下文相关、可理解性、可维护性、方便性） 3.WIMP用户界面设计3.1组成：窗口设计，菜单设计，填表输入界面设计，操作控制元素设计，声音输出界面设计，图标设计，个性化界面设计，UnDo/ReDo设计 3.2窗口设计：标题、图标，可缩放，可最大化、最小化，可移动，有滚动条，边框风格，光标风格，背景图案 3.3菜单设计：下拉式菜单，弹出式，线性，快捷方式，动态菜单（灰显，隐藏，位置可变，内容可变），菜单项图标 3.4填表输入界面设计：提示，输入与编辑，选择，帮助功能（全局完整帮助，F1局部帮助，Hint(隐式)帮助） 3.5图标设计：用已经设计好的*.ICO文件，读入已有的图片进行再编辑或修改，抓取屏幕局部图像再编辑或修改，纯像素画设计 3.6UnDo/ReDo设计：环形栈 4.网页界面设计4.1网页界面的构成要素：文本、图形（以小图作为链接按钮，可使网页更加美观）、页面版式、色彩、多媒体 4.2网页界面的特性：主体经济型（网页已经通过网络渗透到经济发展中），手段先进性，对象广泛性，内容丰富性，形式多样性，操作交互性 4.3网页界面的主要形式：信息查询类，大众媒体类，宣传窗口类，电子商务类，交流平台类，网络社区类 4.4文字编排的规律：对比，统一与协调（近似），平衡，节奏与韵律，视觉诱导（线诱导，图形引导） 4.5版式设计的目的就是要合理布局和设计网页版面，高效地传递视觉信息，充分吸引浏览者 4.6版式设计的要求：符合人的视觉习惯，避免使浏览者产生疲劳感，强化页面的主从关系，安排合理的视觉流程 4.6.1视线移动规律：沿水平方向运动更不易疲劳，视线变化习惯于左到右、上到下、顺时针，不水平也不垂直时包含在45度夹角中 4.6.2视域分布：上部、左侧更为瞩目，最佳视域为左上部与中上部 4.6.3滚动图片从右向左，线状布局应水平方向宽些，导航栏最好放在左侧或上部要重点突出的内容最好放在左上部 4.6.4页宽不宜过长，文字对比不可以过于严重，跟踪动效会令人生厌 4.7网页界面色彩搭配 ​ 4.8网页设计原则：主题不可多于3个，网站的标准色彩不超过3种，网站的目录结构3不要（目录层次不深于3层，不使用过长或中文的目录名，不要将所有文件都存放在根目录下），网站的链接层次结构不要超过3层，首页3条禁忌（无自我介绍，无欢迎光临，无建设中），主页长度限制在3屏以内，表格嵌套层次在3层左右，不要使用过多的字体（3种以内） 4.9提高下载速度的考虑：合理压缩图片，分割图片缩短浏览者的心理等待时间，（除彩色图片和高清彩图外）尽量使用GIF格式图片，网页图片多时使用缩略图+超链接的形式 5.缺省设计问题5.1缺省或缺省值可能用到的场合：文本编辑框；输入选择框（列表框，组合框，单选框，多选框）；功能按钮（焦点） 5.2缺省或缺省值设计的目的：减少用户输入数据量，提高系统使用效率 5.3采用原则：考虑使用的效率，即从统计效果看，每次输入平均输入量（含清除缺省值的输入量）&lt;无缺省值情况下的平均输入量 5.4缺省或缺省值设计方法： 5.4.1用户操作设定缺省值（根据前面录入的信息，也可以考虑做成强制性输入） 5.4.2经验值作为缺省值（依据生活经验得到） 5.4.3统计方法确定出现几率大的值作为缺省值 5.4.4安全需要设置缺省值（如拦截提示中的取消） 5.4.5最近使用值作为缺省值（考虑前面录入的信息） 5.4.6输入数据的上下文关联缺省值 5.4.7当前状态值可作为缺省值（外界状态） 5.4.8逻辑强制关系互为缺省值 5.4.9正常操作序列选项作为缺省值（下一步按钮） 5.4.10树状隶属关系约束选项列表 5.4.11智能焦点（自动移动鼠标到当前缺省焦点上） 6.输入验证设计问题6.1输入验证设计可能用到的场合：文本编辑框，功能菜单或按钮 6.2输入验证设计的目的：在可能的情况下，保证输入数据的有效性、合理性，减少错误，提高效率、保证安全 6.3输入验证的内容及方法：数据位数验证，字符集验证，范围验证，合理性验证，数据格式验证，安全性验证，异常性验证 6.4提高用户使用安心程度：选择性确认，操作中断允许，回滚，Undo/Redo 7.系统响应及信息反馈问题7.1系统响应的目标：及时且适时；信息反馈的目标：反馈信息具体、准确，人性化反馈 7.2系统响应的内容及方法：立即确认用户的输入，提供忙状态提示，任务进度指示器，优先反馈重要信息，处理任务分解、化整为零 7.3进度指示最好是精确的，但常用估计并逐步逼近准确值的方法 7.4进度条中进度与任务完成量之间的匹配关系：虚拟进度（只起到提示忙的作用），非精确进度（近似估计），动态调整的显示进度，进度显示的任务粒度（功能模块、定量任务），时间方式，百分比形式，工作任务动态显示，趣味进度 7.5反馈信息要求：反馈信息明确，建设性指导原则与积极的基调，以用户为中心的措辞，用非拟人化的设计 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/03/31/xi-tong-fen-xi-yu-she-ji-ke-cheng-bi-ji/","date":"03-31","excerpt":"","tags":[{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"}]},{"title":"HTML速查列表","text":"​ 1.HTML基本文档&lt;! DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;可见文本&lt;/body&gt; &lt;/html&gt; 2.基本标签&lt;h1&gt;最大的标题&lt;/h1&gt; &lt;h2&gt;...&lt;/h2&gt; &lt;h3&gt;...&lt;/h3&gt; &lt;h4&gt;...&lt;/h4&gt; &lt;h5&gt;...&lt;/h5&gt; &lt;h6&gt;最小的标题&lt;/h6&gt; &lt;p&gt;段落&lt;/p&gt; &lt;br&gt;换行 &lt;hr&gt;水平线 &lt;!-- 注释 --&gt; 3.文本格式化&lt;b&gt;粗体文本&lt;/b&gt; &lt;code&gt;计算机代码&lt;/code&gt; &lt;em&gt;强调文本&lt;/em&gt; &lt;i&gt;斜体文本&lt;/i&gt; &lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt; &lt;small&gt;更小的文本&lt;/small&gt; &lt;strong&gt;重要的文本&lt;/strong&gt; &lt;abbr&gt; （缩写） &lt;address&gt; （联系信息） &lt;bdo&gt; （文字方向） &lt;blockquote&gt; （从另一个源引用的部分） &lt;cite&gt; （工作的名称） &lt;del&gt; （删除的文本） &lt;ins&gt; （插入的文本） &lt;sub&gt; （下标文本） &lt;sup&gt; （上标文本） 4.链接普通的链接：&lt;a href=\"链接地址\"&gt;链接文本&lt;/a&gt; 图像链接： &lt;a href=\"https://jia_k3.gitee.io/blog/\"&gt;&lt;img src=\"URL\" alt=\"替换文本\"&gt;&lt;/a&gt; 邮件链接： &lt;a href=\"mailto:webmaster@example.com\"&gt;发送e-mail&lt;/a&gt; 书签： &lt;a id=\"tips\"&gt; 提示部分&lt;/a&gt; &lt;a href=\"#tips\"&gt;跳到提示部分&lt;/a&gt; 5.图片&lt;img src=\"URL\" alt=\"替换文本\" height=\"42\" width=\"42\"&gt; 6.样式\\区块&lt;style type=\"text/css\"&gt; h1 &amp;#123;color:red;&amp;#125; p &amp;#123;color:blue;&amp;#125; &lt;/style&gt; &lt;div&gt;文档中的块级元素&lt;/div&gt; &lt;span&gt;文档中的内联元素&lt;/span&gt; 7.无序列表&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;/ul&gt; 8.有序列表&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt; &lt;/ol&gt; 9.定义列表&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt; &lt;/dl&gt; 10.表格&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 11.框架&lt;iframe src=\"demo_iframe.htm\"&gt;&lt;/iframe&gt; 12.表单&lt;form action=\"demo_form.php\" method=\"post/get\"&gt; &lt;input type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\"&gt; &lt;input type=\"password\"&gt; &lt;input type=\"checkbox\" checked=\"checked\"&gt; &lt;input type=\"radio\" checked=\"checked\"&gt; &lt;input type=\"submit\" value=\"Send\"&gt; &lt;input type=\"reset\"&gt; &lt;input type=\"hidden\"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected=\"selected\"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt; &lt;textarea name=\"comment\" rows=\"60\" cols=\"20\"&gt; &lt;/textarea&gt; &lt;/form&gt; ​","path":"2022/03/31/html-su-cha-lie-biao/","date":"03-31","excerpt":"","tags":[{"name":"HTML","slug":"HTML","permalink":"https://jia_k3.gitee.io/blog/tags/HTML/"}]},{"title":"starUML破解","text":"​ 1.下载starUML并安装​​​​​​​​​​​​StarUMLhttps://staruml.io/ 2.下载反编译工具asar 命令行：cnpm install -g asar 3.找到starUML安装目录（从桌面上快捷方式打开文件所在位置） 4.打开文件夹resources找到app.asar文件（里面包含有判断license的代码） 5.将app.asar剪切到其他文件夹（可以桌面上新建一个文件夹，放置app.asar） 6.命令行cd到桌面新建的文件夹（或者其他放置着app.asar文件的文件夹） 命令行：cd C:\\Users\\player\\Desktop\\新建文件夹 7.反编译app.asar 命令行：asar extract app.asar xxx asar:反编译工具 extract:反编译命令 app.asar:反编译对象 xxx:文件夹名称，随便填 有可能报错 operation not permitted，所以需要将app.asar剪切到其他文件夹，避开防止“快速打开”的代码 8.在反编译文件夹搜索找到license-manager.js文件打开 9.找到checkLicenseValidity函数，其中有setStatus(this, false)语句，将其中false改为true，并且将与这个语句并列的其他语句删除，根据现在版本只需要删除UnregisteredDialog.showDialog()语句 10.打开命令行并cd到app.asar放置的文件夹 命令行：cd C:\\Users\\player\\Desktop\\新建文件夹 11.编译更新app.asar 命令行：asar pack xxx app.asar pack:编译更新 xxx:反编译文件夹 12.将新的app.asar文件剪切粘贴到app.asar的源文件夹(resources) 13.打开starUML，Help-&gt;Enter License Key…，提示You already have a valid license. 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/03/23/staruml-po-jie/","date":"03-23","excerpt":"","tags":[{"name":"反编译","slug":"反编译","permalink":"https://jia_k3.gitee.io/blog/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"starUML","slug":"starUML","permalink":"https://jia_k3.gitee.io/blog/tags/starUML/"}]},{"title":"Unity应用单件模式","text":"​ 一、基础概念引用另一篇博客： 1.单件常用来管理共享的资源，例如数据库连接或者线程池 2.单件模式：确保一个类只有一个实例，并提供一个全局访问点 2.1提供对实例的全局访问点，需要实例时，向类查询，它会返回单个实例 2.2可以应用延迟实例化的方式创建单件（类的基本组成：静态私有自身变量，私有构造方法，共有静态获取函数）（getInstance获取函数返回此变量，若为null还需要调用构造函数） 2.3“急切”实例化方式：直接在类的定义中声明唯一变量，getInstance不需要判断唯一变量是否实例化，直接输出唯一变量的结构 3.如果将类的所有组成都定义为静态，以类作为一个单件，可能导致混乱（与初始化次序相关的bug） 4.若使用单件模式的同时使用类加载器，需要自行指定加载器，并指定同一个类加载器 5.全局变量有可能因指向许多小对象来造成命名空间污染 二、联系Unity应用1.实现控制器(controller)与管理器(manager) 2.编写代码 2.1延迟实例化 //延迟实例化方法 public class Manager { private static Manager instance; public static Manager GetInstance() { if(instance == null) { instance = new Manager(); } return instance; } //私有构造函数，仅仅可以在类内调用 private Manager() { //实例化其他成员变量 } } 2.2立即实例化（适用于急切地需要创建单件，或者多次创建使用单件） //“急切”实例化方法 public class Manager { private static Manager instance = new Manager(); public static Manager GetInstance() { return instance; } //私有构造函数，仅仅可以在类内调用 private Manager() { //实例化其他成员变量 } } 3.联系Unity 3.1关于切换场景时物体销毁阶段，根据情况设置是否要销毁脚本附加的物体 3.2在脚本Awake阶段要判断单件是否存在，避免因为切换场景导致单件（同时存在多个）失效 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/03/16/unity-ying-yong-dan-jian-mo-shi/","date":"03-16","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"}]},{"title":"Python蟒书第一部分读书笔记——基础知识","text":"​ 1.起步1.1如果系统安装了Python 2，很有可能是为了支持系统需要的一些旧程序，应保留。 1.2Python自带一个在终端窗口中运行的解释器，让我们无须保存并运行整个程序就能尝试运行Python代码片段。 1.3本书正文推荐Sublime Text作为Python编译器。 1.4打开终端窗口后输入python可以打开Python终端会话，可以按Ctrl+Z、回车或者执行exit()来关闭终端会话 1.5从终端运行Python程序：python chengxu.py 2.变量和简单数据类型2.1每个变量都指向一个值——与该变量相关联的信息。 2.2在程序中可随时修改变量的值，而Python将始终记录变量的最新值。 2.3变量命名要遵循Python命名规范，大小写敏感（大写字母在变量名中有特殊含义）。 2.4编程语言要求严格，但并不关心拼写是否正确。 2.5变量是可以赋给值的标签，也可以说变量指向特定的值。 2.6在Python中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号。这种灵活性让我们能够在字符串中包含引号和撇号。 2.7方法是Python可对数据执行的操作。 2.8存储数据时，方法lower()很有用。因为很多时候，我们无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储，以后需要显示这些信息时，再将其转换为最合适的大小写方式。 2.9(f字符串)要在字符串中插入变量的值，可在前引号前加上字母f，再将要插入的变量放在花括号内。例如： #Python3.6 aaa = \"AAA\" bbb = \"BBB\" name = f\"&amp;#123;aaa&amp;#125;&amp;#123;bbb&amp;#125;\" #Python3.5或更早 name = \"&amp;#123;&amp;#125;&amp;#123;&amp;#125;\".format(aaa,bbb) 2.10 在编程中，空白泛指任何非打印字符，如空格、制表符(\\t)、换行符(\\n). 2.11空白很重要，因为我们经常需要比较两个字符串是否相同，要确保字符串字符串两端无空白，可以使用Python自带函数。 name = \" aaa \" #删除末尾空白\" aaa\" name = name.rstrip() #删除删除开头空白\"aaa \" name = name.lstrip() #删除两端空白\"aaa\" name = name.strip() 2.12编写程序时，编辑器的语法高亮功能可帮助你快速找出某些语法错误。 2.13对于整数，可以执行+、-、*、/、**(乘方运算)。 2.14对于浮点数运算，结果包含的小数位数可能是不确定的。 2.15将任意两个数相除时，结果总是浮点数。 2.16书写很大的数字时，可使用下划线将其中的数字分组。（只适用于Python3.6和更高版本） 2.17Python允许在一行代码中给多个变量赋值。 x, y, z = 0, 1, 2 2.18Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值应保持不变。 2.19注释 #单行注释 ''' 多行 注释 ''' \"\"\" 多 行 注 释 \"\"\" 2.20在Python终端会话中执行import this，可以看到Python编程的指导原则。 3.列表简介3.1在Python中，用方括号([])表示列表，并用逗号分隔其中的元素。如果让Python将列表打印出来，Python将打印列表的内部表示，包括方括号。 3.2要访问列表元素，可指出列表的名称，再指出元素的索引，并将后者放在方括号内。索引从0开始，Python允许通过索引-1访问最后一个元素，-n访问倒数第n个元素。 3.3要修改列表元素，可指定列表名称，可指定列表名和要修改的元素的索引，再指定该元素的新值。 3.4方法append()将元素附加到列表末尾，方法insert()可在列表的任何位置添加新元素。 3.5使用del可以删除任意位置处的列表元素，条件是知道其索引：del names[1] 3.6方法pop()删除列表末尾的元素，并让我们能够接着使用它。names.pop()返回最后的元素并删除。names.pop(n)返回第n+1个元素并删除。 3.7方法remove()允许根据值删除元素。 3.8方法sort()可以对列表永久性排序，要求按字母排序（反序需要向sort()方法传递参数reverse=True），并且列表中所有值都是小写的。 3.9函数sorted()可以对列表临时排序，不影响原始排列顺序。使用方式：sorted(列表) 3.10决定排序顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，比较复杂。 3.11方法reverse()可以永久性修改元素的排列顺序为倒排顺序。 3.12方法len()可以快速得知列表的长度。 4.操作列表4.1for循环遍历整个列表 #打印出所有name for name in names: print(name) 4.2使用单数和复数式名称，可帮助我们判断代码处理的是单个列表元素还是整个列表。 4.3通过缩进判断代码应在for循环中运行还是for循环外执行。 4.4函数range()可以让我们能够轻松地生成一系列数。 for value in range(1, 5) print(value) ''' 差一行为 打印结果： 1 2 3 4 ''' ''' range(1, 5, 2) 指定步长为2，每次加2 ''' 4.5可以使用函数list()将range()的结果直接转换为列表。 4.6有多个专门用于处理数字列表的Python函数：min()\\max()\\sum() 4.7列表解析：首先指定一个描述性的列表名，然后指定一个左方括号，并定义一个表达式，用于生成要存储到列表中的值，接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。 names = [name**2 for name in range(1,11)] 4.8要创建切片，可指定要使用的第一个元素和最后一个元素的索引，由于差一行为，Python在达到第二个索引之前的元素后停止。 #0\\1\\2元素切片 print(names[0:3]) ''' 可以通过names[2:]获取从第3个元素到最后一个元素的切片 names[:3]获取从第一个元素到第三个元素的切片 names[-3:]获取倒数3个元素的切片 可以指定步长 ''' 4.9复制列表 my_names = names[:] ''' my_names = names行不通 只是将my_names关联到names 而names[:]创建了一个副本 ''' 4.10 Python将不能修改的值称为不可变的，而不可变的列表被称为元组。定义元组使用圆括号()并非方括号。 4.11严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。若要定义一个只含一个元素的元组，必须在这个元素后面加上逗号。 my_t = (3,) 4.12虽然不能修改元组的元素，但可以给存储元组的变量赋值。 4.13学习根据Python改进提案PEP来设置代码格式。 5.if语句5.1and(并且)检查多个条件，or(或者)、in(包含)、not in(不包含) 5.2例子： if age &lt; 4: print(\"cost 1\") elif age &lt;8: print(\"cost 2\") else print(\"cost 3\") 5.3在条件测试的格式设置方面，PEP 8提供的唯一建议是，在诸如==、&gt;=、和&lt;=等比较运算符两边各添加一个空格。 6.字典6.1在Python中，字典是一系列键值对。与键相关联的值可以是数、字符串、列表乃至字典。事实上、可将任何Python对象用作字典中的值。 6.2字典用放在花括号({})中的一系列键值对表示。 6.2键和值之间用冒号分隔，而键值对之间用逗号分隔。 student = &amp;#123;'name': 'aaa', 'score': 5&amp;#125; 6.3要获取与键相关联的值，可依次指定字典名和放在方括号内的键。 student['score'] 6.4添加一个键值对方式： student['number']=20 6.5修改键值对： student['score']=9 6.6删除键值对： del student['score'] 6.7由类似对象组成的字典： favorite_game = &amp;#123; 'a': 'cs', 'b': 'cf', &amp;#125; ''' 最后一个键值对后添加逗号方便后续添加 格式如上 ''' 6.8就字典而言，可使用方法get()在指定的键不存在时返回一个默认值。 #参数一：指定键；参数二：默认值(不添加默认是None) student.get('score','No score') 6.9 要编写遍历字典的for循环，可声明两个变量，用于存储键值对中的键和值。方法items()返回一个键值对列表。 for k, v in student.items(): 6.10遍历字典中的所有键，使用方法keys()返回一个包含所有键的列表。遍历字典时，默认遍历所有的键。 for key in student.keys(): #等同于for key in student: 6.11遍历字典中的所有值，使用方法value()。 6.12集合(set)可以自动剔除重复项。 for language in set(student.value()) 6.13有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。 7.用户输入和while循环7.1函数input()让程序暂停运行，等待用户输入一些文本，获取用户输入后，Python将其赋给一个变量，以方便使用。 7.2函数input()接受一个参数——要向用户显示的提示或说明。 7.3函数int()将数的字符串表示转换成了数值表示。 7.4for循环用于针对集合中的每个元素都执行一个代码块，而while循环则不断运行，直到指定的条件不满足为止。 7.5要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结构如何，可使用break语句。 7.6要返回循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。 7.7如果程序陷入无限循环，可按Ctrl+C，也可关闭显示程序输出的终端窗口。 7.8使用while循环处理列表和字典，可以完成以下操作：在列表之间移动元素，删除为特定值的所有列表元素，使用用户输入来填充字典。 8.函数8.1函数是带名字的代码块，用于完成具体的工作。 8.2定义函数： def greet_user(): '''显示简单的问候语''' print(\"Hello!\") ''' def表示定义 三对引号处文本被称为文档字符串的注释 Python使用文档字符串来生成有关程序中函数的文档 ''' 8.3设置参数规则与其他语言相同，可通过位置实参和关键字实参来传递参数。 8.4通过return来设置返回值 8.5通过设置形参默认值达到让实参变成可选的目的。 8.6函数输入值为列表时，可以通过传入列表副本(切片)的方式禁止函数修改列表。 8.7传递任意数量实参的函数定义： def make_score(*score_std) ''' 形参中*使Python建立一个名为score_std的空元组， 并将收到的所有值都封装到这个元组中。 ''' 8.8使用任意数量的关键字实参： def score(**score_std): ''' 函数内容 ''' scores = score(a=5, b=6) 8.9 将函数存储在模块中，通过import语句导入模块： import student student.score() ''' 导入student.py，调用其中的score函数 ''' 8.10导入模块中的特定函数： from student import score score() 8.11使用as给函数指定别名，针对函数名字长、重复等问题： from student import score as std_s 8.12也可以用as给模块指定别名。 8.13导入模块中的函数后，调用函数可以直接调用，但针对大型模块，最好不要全部导入。 from school import * std_name() #不需要school.std_name() 8.14import语句要放在代码开头 8.15编写函数时，应给函数指定描述性名称，且只在其中使用小写字母和下划线。每个函数都应该包含简要地阐述其功能的注释，该注释应跟在函数定义后面，并采用文档字符串格式。 9.类9.1在Python中，首字母大写的名称指的是类。 class Car: def _init_(self, name): self.name = name self.type = \"AE86\" 9.2方法_init_()在Python创建新实例时自动调用。 9.3类中方法定义时，self参数必不可少，必须位于其他形参前面。self是一个指向实例本身的引用，让实例能够访问类中的属性和方法。 9.4属性：函数内定义的变量中，以self为前缀的变量可供类中所有方法使用，可以通过类的任何实例来访问。 9.5创建实例、访问属性、调用方法与其他语言类似。 9.6继承实现：(规则类似其他语言) class Ecar(Car): def _init(self, name): super()._init(name) 9.7 导入类，类似导入函数。 9.8Python标准库是一组模板。 9.9类名应采用驼峰命名法，将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模板名都采用小写格式，并且在单词之间加上下划线。 10.文件和异常10.1读取文件： with open(\"abc.txt\") as file_object： contexts = file_object.read() ''' with关键字表示在不再需要访问文件后将其关闭，不需要再寻找合适时间调用close() open()返回一个表示文件的对象，将该对象赋给file_object Python在当前执行的文件所在目录中查找指定文件 ''' 10.2 注意read()运行到文件末尾时将返回一个空字符串(表现形式为一个空行)。 10.3显示文件路径时，Windows系统使用反斜杠(\\)而不是斜杠(/)，但在代码中依然可以使用斜杠。 10.4文件路径与其他语言规律相同。 10.5逐行读取： with open(\"a.txt\") as file_object: for line in file_object: print(line) 10.6创建一个包含文件各行内容的列表： lines = file_object.readlines() 10.7写入文件： with open(\"a.txt\",'w') as file_object: file_object.write(\"name\") ''' 读取模式：r；写入模式：w；附加模式：a；读写模式：r+ 默认读取模式 ''' 10.8Python使用称为异常的特殊对象来管理程序执行期间发生的错误。每当发生错误时，Python都会创建一个异常对象，若我们编写了处理该异常的代码，程序将继续运行，反之停止运行并显示traceback。 10.9使用try-except代码块来处理异常： try: print(5/0) except ZeroDivisionError: print(\"You can't divide by zero!\") else: print(\"Succeed\") #依赖try代码成功运行的代码放在else代码块中 10.10pass语句用于让Python在代码块中什么都不要做。 10.11JSON存储数据： import json json.dump(a, b) c = json.load(f) ''' a代表数据，b代表文件对象 c获取数据存储 f代表文件对象 ''' 11.测试代码11.1Python标准库中的模板unittest提供了代码测试工具。 11.2单元测试用于核实函数的某个方面没有问题。测试用例是一组单元测试，它们一道核实函数在各种情形下的行为都符合要求。 11.3测试代码： import unittest from student import score class StdTestCase(unittest.TextCase): def test_score(): #针对函数的内容 self.assertEqual() if _name_ == '_main_': unittest.main() ''' self.assertEqual()是断言方法 测试函数必须以test开头 最后两行保证测试只在以本文件作为主运送文件时执行 ''' 11.4常用断言方法： 方法 用途 assertEqual(a,b) 核实a==b assertNotEqual(a,b) 核实a!=b assertTrue(x) 核实x为True assertFalse(x) 核实x为False assertIn(item,list) 核实item在list中 assertNotIn(item,list) 核实item不再list中 11.5测试类先实现setup()(如果有定义)再执行其他test函数。 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/02/27/python-mang-shu-di-yi-bu-fen-du-shu-bi-ji-ji-chu-zhi-shi/","date":"02-27","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://jia_k3.gitee.io/blog/tags/Python/"}]},{"title":"Unity实现2D弹球小游戏过程分析","text":"​ 一、游戏截图及源码1.游戏截图与项目对象构成​ ​ 2.重要脚本代码2.1createBox.cs创建小球，控制射向速度，设置小球移动过程游戏加速 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class creatBox : MonoBehaviour { public Text text_ball_num; public int enemy_num; public GameObject m_prefab; public int ball_number; public string create_tag; private int num; private Vector2 v; private Rigidbody2D rb; private float Sw, Sh, Swm; private int touchCount; private LineRenderer aimLine; private Touch touch; private int key = 1; private void Start() { Sw = Screen.width; Sh = Screen.height; Swm = Sw / 2f; text_ball_num.text = \"number:\" + ball_number; num = ball_number; PlayerPrefs.SetInt(\"Key\", 1); PlayerPrefs.SetInt(\"Num\", 0); aimLine = GetComponent(); } private void Update() { ball_number = (PlayerPrefs.GetInt(\"Score\") / 5) + 10; text_ball_num.text = \"Ball Number:\"+ball_number.ToString(); if(PlayerPrefs.GetInt(\"Key\")==0) { if(Input.GetMouseButton(0)) { Time.timeScale = 2; } else { Time.timeScale = 1; } } if(PlayerPrefs.GetInt(\"Key\")==1) { aimandshoot(); } if(PlayerPrefs.GetInt(\"Key\")==2) { GameObject[] enemy = GameObject.FindGameObjectsWithTag(\"Enemy\"); for(int i=0;i","path":"2022/02/24/unity-shi-xian-2d-dan-qiu-xiao-you-xi-guo-cheng-fen-xi/","date":"02-24","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"}]},{"title":"修勾相处手册","text":"1.如何判断小狗狗性格（结合网络内容，真伪未知）： 1.1将小狗背部向下，手按在小狗胸腔与肚子之间的区域（小小力），如果不挣扎，说明小狗温柔，容易相处；如果挣扎，表示有点硬气；如果挣扎的同时想咬人，说明比较凶，不太好相处 1.2将小狗环抱怀中，若小狗狗安稳躺在怀里，说明小狗狗适应陌生环境能力强；反之不强 1.3手抓小狗狗脖颈处皮肉将小狗狗提起来，若小狗狗沉默不语，说明不是特别怕痛；反之有点怕 2.如何判断小狗狗未来体质（结合mom经验）： 2.1大（小）体型型：嘴槽大（小），耳朵大（小） 2.2抗病能力好坏：按照1.3将小狗狗提起来（手感好，需要经验，毛硬皮实） 3.如何快速和小狗狗搞好关系：（除了喂食以外） 3.1从头上到背部顺着抚摸安抚 3.2用手抓着小狗狗两个前爪，提起前爪让小狗狗与自己有对视的机会，根据小狗狗态度玩耍 4.如何让断奶小狗狗吃自己找的东西： 4.1用奶过渡，在奶里加拌其他想要喂食的食物，慢慢改变小狗狗的食物接受范围 4.2一开始用其他奶喂食小狗狗不吃的话，（向小狗狗嘴边抹上要喂食的奶）将盛有奶的容器放置到小狗狗面前，用手按着小狗狗的头，使它的嘴沾上一些奶 4.3饿一段时间喂食：(","path":"2022/02/13/xiu-gou-xiang-chu-shou-ce/","date":"02-13","excerpt":"","tags":[{"name":"生活","slug":"生活","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"《Head First设计模式》读书笔记","text":"​ 一、设计模式入门与策略模式1.使用模式最好的方式是：“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。” 2.软件开发的一个不变真理：改变 3.第一个设计原则：分离需要变化的代码和不需要变化的代码，将前者独立封装，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的代码部分=&gt;代码变化引起的不经意后果减少，系统变得更具有弹性 4. 3中提到的概念几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分” 5.第二个设计原则：针对接口编程，而不是针对实现编程。 5.1解释：这里我对“编程”的理解是广义设计程序与写代码的结合；“针对A编程”的理解：以A做背景（前提）的编程；“针对接口编程”的理解：在使用超类型(supertype)的结构下设计程序 5.2我们利用接口(interface、行为类)代表每个行为，而行为的每个实现(interface的子类、实现类)都将实现其中的一个接口 5.3两者区别举例：前者：针对同类不同对象根据不同子类区分功能；后者：在功能实现过程中识别不同对象（例如if-else）应该使用的功能 ​ 6.原则与模式可以应用在软件开发周期的任何阶段 7.将行为独立为一个类后，在原来的具体类里该行为也应由一个方法变为对象+方法 8.在运行过程中想要改变行为时，只要调用行为对应对象的setter方法即可达到改变行为的目的 9.第三个设计原则：多用组合，少用继承。“有一个”可能比“是一个”更好 10.使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在运行时动态地改变行为，但是组合的行为对象要符合正确的接口标准（算法族：一组行为=&gt;一族算法） 11.第一个设计模式：策略模式，定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 12.使用模式和他人沟通时，可以使用更少的词汇做更充分的沟通，谈论软件系统时保持在设计层次，不要压低到对象与类这些琐碎的实现细节上面 13.模式不只是利用OO设计原则，隐含经验整理成了一群“设计模式” 14.要点摘抄： 14.1知道OO基础，并不足以让你设计出良好的OO系统 14.2模式不是被发明，而是被发现 14.3大多数的模式和原则，都着眼于软件变化的主题 14.4模式让开发人员之间有共享的语言，能够最大化沟通的价值 二、观察者模式1.实例比喻：报纸出版者（主题Subject）+报纸订阅者（观察者Observer）=观察者模式 2.观察者与主题两种角色可以重叠，例如一个观察者作为主题，在得知它对应的主题信息更新后通知它对应的观察者信息 3.观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新 4.实现观察者模式的方法不只有一种，但是以包含Subject与Observer接口的类设计的做法最常见 5.设计原则：为了交互对象之间的松耦合设计而努力 5.1两个对象之间松耦合：依然可以交互，但是不太清除彼此的细节 5.2观察者模式提供了一种对象设计，让主题和观察者之间松耦合 5.3由于两者并非紧耦合，我们可以独立地复用主题或观察者 5.4改变主题或观察者其中一方，并不会影响另一方，只要它们之间的接口仍被遵守，我们就可以自由地改变它们 5.5松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降到了最低 5.6“耦合”的理解：耦合不是简单的调用，而是依据调用代码内容做更改后的调用。例如：直接调用a.aa()是松耦合；“若a是A，调用a.aa()，否则如何”这样是紧耦合。或者说不根据彼此代码而作适应性编程就是松耦合 6.Java内置的Observer模式不只支持主题推数据给观察者，还支持观察者从主题拉数据 6.1.java.util.Observable中的Obserable是一个类，违反针对接口编程的原则；类中setChanged()被保护，要更改函数必须继承，违反多用组合的原则 6.2若设计中可以扩展java.util.Observable，则Java自带的API可以符合需求，否则需要自己设计一整套观察者模式的代码 6.3在JDK中，并非只有在java.util中才能找到观察者模式，在JavaBeans和Swing中也存在观察者模式 7.要点摘抄： 7.1使用此模式时，你可从被观察者处推或拉数据，推的方式被认为更“正确” 7.2有多个观察者时，不可以依赖特定的通知次序 7.3要注意java.util.Observable实现上所带来的一些问题 三、装饰者模式1.最重要的设计原则之一：类应该对扩展开放，对修改关闭 1.1开放的：扩展行为，添加行为代码 1.2关闭的：不允许修改现有的、正确的代码 1.3这样的设计具有弹性，可以应对改变，可以接受新的功能来应对改变的需求 2.不需要使设计的每个部分都遵循开放-关闭原则（每个地方都采用开放-关闭原则是一种浪费，遵循此原则通常需要引入新的抽象层次、增加代码复杂度），只需要将注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则 3.装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的代替方案 3.1关键点：装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的 3.2装饰者和被装饰对象有相同的超类型 3.3既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）场合，可以用装饰过的对象代替它（迭代装饰） ​ 4.装饰者继承抽象父类是为了有正确的类型，而不是继承它的行为。行为来自于装饰者和基础组件或与其他装饰者间的组合关系 5.通常装饰者模式是采用抽象类，但在Java中可以使用接口 6.装饰者通常是用其他类似于工厂或生成器这样的模式创建的，它们会被封装得很好，不会因其更多对象而犯错 7.Java中使用装饰者模式的例子：Java I/O(java.io) 8.装饰者模式的弊端：有时候会在设计中加入大量的小类，偶尔会导致别人不容易了解我的设计方式，干扰依赖特定类型的代码，增加代码复杂度 9.要点摘抄： 9.1组合和委托可用于在运行时动态地加上新的行为 9.2装饰者类反映出被装饰的组件类型 9.3可以用无数个装饰者包装一个组件 9.4装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型 四、工厂模式1.代码绑着具体类会导致代码更脆弱，更缺乏弹性=&gt;new时相当于针对实现编程，要优化实例化具体类的代码 2.简单工厂，不是一个设计模式，而是一种编程习惯，有人为人误认为是“工程模式” 2.1组成元素：客户(store)、工厂(factory)、产品 2.2客户选择产品类型，工厂创建产品，客户从工厂获取 3.利用静态方法定义一个简单的工厂，但有无法继承改变的缺点（静态方法无法被重写） 4.所有的工厂模式都用来封装对象的创建，工厂方法模式通过让子类决定该创建的对象是什么，来达到将该对象创建的过程封装的目的 5.工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类（与简单工厂相比，失去中间类：factory，由抽象工厂类选择产品种类，它的子类决定生产方式并生产） 5.1“子类决定”中“决定”并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个，选择了使用哪一种子类，自然就决定了实际创建的产品是什么 5.2抽象的工厂类提供了一个创建对象的方法的接口，也称为“工厂方法” 5.3在抽象的工厂类中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法并创建产品 5.4工厂方法用来处理对象的创建，并将这样的行为封装在子类中=&gt;客户程序中关于超类的代码与子类对象创建代码解耦 ​ 6.若只有一个具体创建者，工厂方法模式帮助我们将产品的实现从使用中解耦，由于创建者与产品不是紧耦合关系，增加或改变产品不会影响创建者 7.工厂方法和创建者并不一定是抽象的 8.设计原则：（依赖倒置原则）要依赖抽象，不要依赖具体类 8.1“依赖”含义：直接实例化一个对象就是依赖它的具体类，对于实例化的对象的具体实现的任何改变都会影响到主体（依赖前面对象的对象） 8.2此原则说明：不能让高层组件依赖底层组件，而且高底层都应依赖抽象（创建对象类应为抽象类） 8.3“高层”组件：由其他底层组件定义其行为的类 9.应用工厂方法后，高层组件与底层组件都依赖抽象（产品抽象类） 10.遵循依赖倒置原则的指导方针： 10.1变量不可以持有具体类的引用（不使用new，工厂模式中使用create，而真正的实例化过程分配到了声明变量的超类的子类，使变量不持有具体类的引用） 10.2不要让类派生自具体类（若派生自具体类就会依赖具体类） 10.3不要覆盖基类中已经实现的方法（若可以覆盖则基类不合格） 10.4上述方针不是不可违反，要根据自己的理解，如：可以随便实例化不可能改变的对象，对于可能改变的对象应用工厂 11.抽象工程模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 11.1允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么 11.2客户从具体的产品中被解耦 11.3抽象工厂的方法经常以工厂方法的方式实现（超类声明抽象，子类覆盖实现） ​ 12.工厂方法与抽象工厂： 12.1两者都用来（通过子类）创建对象，将创建封装，使应用程序解耦，降低其对特定实现的依赖 12.2工厂方法使用继承（继承一个工厂方法解决） 12.3抽象工厂使用组合（继承多个类似工厂方法组合产品解决） 12.4工厂方法将客户从具体类型中解耦，每次声明客户对象使用超类，实现用子类实现解耦 12.5抽象工厂声明客户同工厂方法，但是可以将相关产品结合作为最终产品 12.6抽象工厂用来创建整个产品家族，工厂方法用来创建单个产品 13.要点摘抄： 13.1所有的工厂都是用来封装对象的创建 13.2所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合 13.3工厂帮助我们针对抽象编程，而不是针对具体类编程 五、单件模式1.单件常用来管理共享的资源，例如数据库连接或者线程池 2.单件模式：确保一个类只有一个实例，并提供一个全局访问点 2.1提供对实例的全局访问点，需要实例时，向类查询，它会返回单个实例 2.2可以应用延迟实例化的方式创建单件（类的基本组成：静态私有自身变量，私有构造方法，共有静态获取函数）（getInstance获取函数返回此变量，若为null还需要调用构造函数） 2.3“急切”实例化方式：直接在类的定义中声明唯一变量，getInstance不需要判断唯一变量是否实例化，直接输出唯一变量的结构 2.4改善多线程：&lt;1&gt;采用延迟实例化时，getInstance不关键可以直接用synchronized修饰此函数，但是需要程序接受getInstance造成的额外负担；&lt;2&gt;采用急切策略时，适用于应用程序总是创建并使用单件实例，或者在创建和运行时负担不繁重；&lt;3&gt;双重检查加锁，在getInstance中减少使用同步（判断实例未创建时使用同步synchronized），减少getInstance的时间耗费。 3.如果将类的所有组成都定义为静态，以类作为一个单件，可能导致混乱（与初始化次序相关的bug） 4.若使用单件模式的同时使用类加载器，需要自行指定加载器，并指定同一个类加载器 5.垃圾收集器不会吃掉单件 6.通常适合使用单件模式的机会不多 7.全局变量有可能因指向许多小对象来造成命名空间污染 8.要点摘抄： 8.1如果不是采用第五版的Java 2，双重检查加锁实现会失效 8.2如果使用JVM 1.2或之前的版本，必须建立单件注册表，以免垃圾收集器将单件回收 六、命令模式1.命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作 1.1在ConcreteCommand中需要有具体接收者（行动者）的对象 1.2命令模式使请求调用者和请求接收者之间解耦 ​ 2.一个命令对象通过在特定接收者上绑定一组动作来封装一个请求 2.1命令对象将动作和接收者包进对象中，这个对象只留下一个公开的接口execute() 2.2“绑定”指通过单一职责使所有有关行为封装进指定接收者对象里，再将这些动作封装进公开的那个接口里 3.如果在返回对象时，不想返回null，可以考虑空对象（方法空） 4.宏命令：创建命令组对象，将组内execute组合调用 5.实现多层次撤销：应用堆栈记录 6.命令模式的更多用途：队列请求（将命令对象添加进工作队列）、日志请求（序列化记录动作） 7.要点摘抄： 7.1命令模式将发出请求的对象和执行请求的对象解耦 7.2在被解耦的两者之间通过命令对象进行沟通，命令对象封装了接收者和一个或一组动作 7.3命令可以支持撤销，实现undo() 七、适配器与外观模式1.适配器用来将一种接口转换成另一种接口，以符合客户的期望 2.适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间 2.1可以让客户从实现的接口解耦 2.2被适配者的任何子类都可以搭配者适配器使用 2.3对象适配器（利用组合的方式将请求传递给被适配者） ​ 2.4类适配器（需要多重继承，Java不可用） ​ 3.类适配器可以覆盖被适配器的行为，有效率；对象适配器有弹性 4.外观模式在提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用 5.外观模式允许你将客户实现从任何子系统中解耦 6.适配器模式与外观模式的区别不在于“包装”了几个类，而在于意图：前者要改变接口来适应，后者来提供子系统的简化接口 7.外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用 7.1外观模式允许我们让客户和子系统之间避免紧耦合 7.2意图是提供一个简单的接口，让一个子系统更易于使用 ​ 8.设计原则：（“最少知识”原则）只和你的密友谈话（其他称呼：墨忒耳法则） 8.1减少对象之间的交互 8.2不要让太多的类耦合在一起 9.“最少知识”原则使用方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法： 9.1自己的方法 9.2被当做方法的参数而传递进来的对象 9.3此方法所创建或实例化的任何对象 9.4对象的任何组件 9.5例子： ​ 10.要点摘抄： 10.1可以为一个子系统实现一个以上的外观 10.2适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；外观将一群对象“包装”起来以简化其接口 八、模板方法模式1.模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现 2.模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 2.1模板就是一个方法，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现 2.2确保了算法的结构保持不变，同时由子类提供部分实现 ​ 3.模板方法被声明为final，以免子类改变算法顺序 4.可以有“默认不做事的方法”，称这种方法为“hook”钩子，子类可以视情况要不要覆盖他们来实现选择的功能 5.钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现，它的存在可以让子类有能力对算法的不同点进行挂钩 6.当子类必须提供算法中某个方法或步骤的实现时，就使用抽象方法；如果算法的这个部分可选，用钩子。 7.钩子可以让子类实现算法中可选的部分，或者让子类能够有机会对模板方法中某些即将发生的步骤作出反应。 8.设计原则：（好莱坞原则）别调用（打电话给）我们，我们会调用（打电话给）你 8.1好莱坞原则可以防止“依赖腐败”（依赖设计混乱） 8.2在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件 8.3并不是低层组件禁止调用高层组件中的方法，而是要避免让高层和低层组件之间有明显的环状依赖 9.要点摘抄： 9.1你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的 9.2策略模式和模板方法模式都封装算法，前者用组合，后者用继承 9.3工厂方法是模板方法的一种特殊版本 九、迭代器与组合模式1.迭代器模式依赖于一个名为迭代器(Iterator)的接口 2.集合(collection)指一群对象，也称聚合(aggregate) 3.在多线程程序中要小心使用迭代器 4.迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示 4.1添加createIterator()方法创建迭代器，自创或用java.util.Iterator（Java里有的类支持迭代器）来实现Iterator接口 4.2这个模式提供了一种方法，可以顺序访问一个聚集对象中的元素，而又不用知道内部是如何表示的 4.3如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码和这些聚合搭配使用 4.4迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象，简化聚合对象 ​ 5. 我们上面实现的是外部的迭代器，客户通过调用next取得下一个元素；内部的迭代器自行在元素之间游走，但需要将操作传入迭代器，让迭代器控制遍历的过程 6.设计原则：（单一责任）一个类应该只有一个引起变化的原因 7.内聚，用来度量一个类或模板紧密地达到单一目的或责任的术语 7.1当一个模块或一个类被设计成只支持一组相关的功能时，说明它具有高内聚 7.2当被设计成支持一组不相关的功能时，说明它具有低内聚 8.Java 5包含for/in语句，语法：for(Object obj: collection){}这可以让你在一个集合或者一个数组中遍历，而且不需要显式创建迭代器 9.组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合 9.1组合对象可能包含其他组合对象和个别对象，个别对象只是个别对象 9.2使用组合模式，大多情况下，我们可以忽略对象组合和个别对象之间的差别 ​ 10. 所有组件都必须实现Component接口，但由于角色不同，有些方法不适用时最好抛出异常 11.组合迭代器(CompositeIterator)的工作是遍历组件内所有的个别对象，用到堆栈与递归 12.空迭代器(NullIterator)的hasNext()永远返回false，用来取代返回null的情况避免判断是否为null 13.要点摘抄： 13.1迭代器将遍历聚合的工作封装进一个对象中 13.2组合模式允许客户对个别对象以及组合对象一视同仁 13.3组合结构内的任何对象称为组件，组件可以是组合，也可以是叶节点 13.4在实现组合模式时，有许多设计上的折衷。要根据需要平衡透明性（用户可分辨对象种类）和安全性（对错的对象做错的事情、无意义的操作） 十、状态模式1.状态模式通过改变对象内部的状态来帮助对象控制自己的行为 2.状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类 2.1状态模式将状态封装成为独立的类，并将动作委托到代表当前状态的对象 2.2使用组合通过简单引用不同的状态对象来造成类改变的假象 ​ 3. 策略模式与状态模式区别：（意图）状态模式中客户对Context改变了解不多甚至浑然不觉，而且支持组合不同的对象来改变行为；策略模式中客户通常指定Context所要组合的策略对象 4.一般来讲，当状态转换是固定的时候，就适合放在Context中；当转换是更动态的时候，通常就会放在状态类中。后者缺点是状态类之间产生依赖 5.在状态模式中客户不会与状态直接交互 6.要点摘抄： 6.1和程序状态机(PSM)不同，状态模式用类代表状态 6.2Context会将行为委托给当前状态对象 6.3状态类可以被多个Context实例共享 十一、代理模式1.代理要做的：控制和管理访问 2.在开始编码之前，要先收集需求 3.远程对象：活在不同的Java虚拟机(JVM)堆中 4.本地代表：一种可以由本地方法调用的对象，其行为会转发到远程对象中 5.客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆中的“代理”对象上的方法，再由代理处理所有网络通信的底层细节 6.Java RMI提供了客户辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法 6.1RMI称呼：RMI将客户辅助对象称为stub（桩），服务辅助对象称为skeleton（骨架） 6.2客户堆：客户对象+客户辅助对象；服务器堆：服务对象+服务辅助对象 7.制作远程服务步骤： 7.1制作远程接口 ​ 7.2制作远程的实现 ​ 7.3利用rmic产生的stub和skeleton（运行rmic工具时，自动处理） ​ 7.4启动RMI registry ​ 7.5开始远程服务 ​ 8. 客户取得stub对象 ​ ​ ​ ​ 9.对于RMI，程序员最常犯的三个错误： 9.1忘记在启动远程服务之前先启动rmiregistry 9.2忘记让变量和返回值的类型成为可序列化的类型 9.3忘记给客户提供stub类 10.使平常类变成服务（可接受远程调用） 10.1提供远程接口，该口提供了一组可以远程调用的方法 10.2确定接口的所有返回类型都是可序列化的 10.3在一个具体类中，实现此接口 11.代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问 11.1使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象 11.2代理控制访问的方式：远程代理控制访问远程对象；虚拟代理控制访问创建开销大的资源；保护代理基于权限控制对资源的访问 ​ 12.远程代理与虚拟代理： 12.1远程代理可以作为另一个JVM上对象的本地代表，利用网络交互 12.2虚拟代理（创造开销大的对象的代表）扮演对象的替身，将请求直接委托给对象 13.虚拟代理用法：显示CD封面，等待加载时间，虚拟代理可以代理Icon管理背景加载，加载未完成显示加载文字，加载完成显示委托给图片 14.可以向用户提供一个工厂来让客户使用代理 15.动态代理：实际的代理类在运行时创建的Java技术 16.使用Java API的java.lang.reflect包实现保护代理（一种根据访问权限决定客户可否访问对象的代理）的类图： ​ 17.其他代理： 17.1防火墙代理：控制网络资源的访问，保护主题免于“坏客户”的侵害 17.2智能引用代理：当主题被引用时，进行额外的动作 17.3缓存代理：为开销大的运算结果提供暂时存储；允许多个客户共享结果，以减少计算或网络延迟 17.4同步代理：在多线程的形况下为主题提供安全的访问 17.5复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。也称外观控制 17.6写入时复制代理：控制对象的复制，方法是延迟对象的复制，知道客户真的需要为止 18.要点摘抄： 18.1远程代理管理客户和远程对象之间的交互 18.2虚拟代理控制访问实例化开销大的对象 18.3保护代理基于调用者控制对对象方法的访问 18.4Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器 十二、复合模式1.模式通常被一起使用，并被组合在同一个设计解决方案中 2.复合模式在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题 3.MVC（模型-视图-控制器）组成： 3.1控制器：取得用户的输入并解读其对模型的意思 3.2视图：用来呈现模型，通常直接从模型中取得它需要显示的状态与数据 3.3模型：持有所有的数据、状态和程序逻辑 3.4观察者模式：模型被视图与控制器观察 3.5策略模式：视图委托控制器来处理用户动作 3.6组合模式：视图的完成 4.控制器可以变成模型的观察者 5.控制器把控制逻辑从视图中分离，让模型和视图之间解耦 6.Model 2：MVC与Web的适配，使MVC符合浏览器/服务器模型（Servlet+JSP=&gt;MVC的分离效果） ​ 7.控制器不会实现应用逻辑，应用逻辑在模型中实现 8.要点摘抄： 8.1控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为 8.2在Model 2中，控制器实现成Servlet，而JSP/HTML实现视图 十三、与设计模式相处1.模式：在某情景下，针对某问题的某种解决方案 2.模式类目描述某个模式的意图、动机、可能应用该模式的地方、解决方案的设计以及使用后果 3.模式的描述： ​ 4.三次规则：只有在真实的世界中被应用三次以上，才能算是一个模式 5.常见模式分类方法： 5.1根据模式的目标分成三个不同类目：创建型、行为型和结构型 5.2模式所处理的是类或是对象 6.快速开始用模式思考的指南： 6.1保持简单，不要为了用模式而用 6.2设计模式不是每次都完美无缺的 6.3要知道什么时候需要模式 6.4重构的时间就是模式的时间 6.5拿掉不需要的，不要害怕将一个设计模式从你的设计中删除 6.6如果现在不需要就不要做 7.反模式：告诉你如何采用一个不好的解决方案解决一个问题 ​ 十四、其他模式​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​","path":"2022/01/27/head-first-she-ji-mo-shi-du-shu-bi-ji/","date":"01-27","excerpt":"","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://jia_k3.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《近世代数》笔记","text":"一、基本概念1.二元运算的定义1.1设S为集合，映射f:S*S-&gt;S称为S上的一个二元运算，简称二元运算 1.2S中任何两个元素都可以进行运算，且运算的结果唯一 1.3S中任意两个元素的运算结果都属于S，即S对该运算封闭 1.4表示二元运算的方法：解析公式和运算表 2.运算规律2.1设*为非空集合S上的二元运算 2.1.1若任意x,y,z属于S有(x*y)*z=x*(y*z)，则称运算*在S上满足结合律 2.1.2若任意x,y属于S有x*y=y*x，则称运算*在S上满足交换律 2.2设。和*为非空集合S上两个不同的二元运算 2.2.1若任意x,y,z属于S有z。(x*y)=(z。x)*(z。y)则称运算。对运算*满足左分配律 2.2.2若任意x,y,z属于S有(x*y)。z=(x。z)*(y。z)则称运算。对运算*满足右分配律 2.2.3若任意x,y,z属于S有z。(x*y)=(z。x)*(z。y)且(x*y)。z=(x。z)*(y。z)则称运算。对运算*满足分配律 2.3设*为非空集合S上二元运算，若任意x,y,z属于S，若x*y=x*z，且x不是零元，则y=z；若y*x=z*x，且x不是零元，则y=z，则称*运算满足消去律 2.4二元运算的性质 2.4.1设。为非空集合S 上的二元运算 ， 若运算。满足结合律 ，则任意ai属于S，i=1, 2, … , n ，n 个元素a1,a2, … , an 的乘积( 关于运算。的运算结果a1。a2。。。。an )仅与这n个元素及其顺序有关而唯一决定 2.4.2 设。为非空集合S 上的二元运算，若运算。满足结合律和交换律，则任意ai属于S，i=1, 2, … , n，n个元素a1, a2, … , an的乘积a1。a2 。… 。an仅与这n个元素有关而与其顺序无关 2.4.3设。和*为非空集合S上两个不同的二元运算，若运算*满足结合律，运算。对运算*满足（左右）分配律，则任意a,ai属于S，i=1,2,…,n，有a。(a1*a2*a3*…*an)=(a。a1)*(a。a2)*…(a。an)；(a1*a2*…*an)。a=(a1。a)*(a2。a)*…*(an。a)，分配律的重要性在于能够让两种代数运算间有一种联系 3.特异元素3.1单位元也叫幺元 3.1.1定义：设*为S上的二元运算 3.1.1.1若存在e存在S，使得对任意x属于S都有e*x=x，称e是S中关于*运算的左单位元 3.1.1.2若存在e存在S，使得对任意x属于S都有x*e=x，称e是S中关于*运算的右单位元 3.1.1.3若e记为左单位元又为右单位元，则e为S上关于*运算的单位元 3.1.2单位元唯一性定理：若S分别含有左右单位元时，左右单位元相同且为S上唯一的单位元 3.2零元 3.2.1定义：设*为S上的二元运算 3.2.1.1若存在e存在S，使得对任意x属于S都有e*x=e，称e是S中关于*运算的左零元 3.2.1.2若存在e存在S，使得对任意x属于S都有x*e=e，称e是S中关于*运算的右零元 3.2.1.3若e记为左零元又为右零元，则e为S上关于*运算的单位元 3.2.2零元唯一性定理：若S分别含有左右零元时，左右零元相同且为S上唯一的零元 3.2.3|S|&gt;=2，单位元与零元不同；|S|=1，这个元素既是单位元也是零元 3.3可逆元素和逆元 3.3.1定义：设*为S上的二元运算 3.3.1.1若存在x存在S，使得对任意y属于S都有x*y=e，称x是y的左逆元 3.3.1.2若存在x存在S，使得对任意y属于S都有y*x=e，称x是y的右逆元 3.3.1.3若x记为y的左逆元又为右逆元，则x为y的逆元，y为可逆元素 3.3.2逆元唯一性定理：若y有左右逆元时，左右逆元相同且为y唯一的逆元 4.代数系统的定义4.1非空集合S和S上k个一元或二元运算*1,*2,…,*k组成的系统称为一个代数系统，记做(S,*1,*2,…,*k) 4.2子代数：设(S,*1,*2,…,*k)是代数系统，B是S的非空子集，如果B对*1,*2,…,*k都是封闭的，且B和S含有相同的代数常数，则称(B,*1,*2,…,*k)是S的子代数系统 4.3最大的子代数就是S本身 4.4最小的子代数：如果令S中所有代数常数构成的集合是B，且B对S中所有的运算都是封闭的，则B就构成了S的最小的子代数 4.5最大和最小的子代数称为S的平凡的子代数 4.6若B是S的真子集，则B构成的子代数称为S的真子代数 5.代数系统的同构与同态5.1同态定义：设(A,%)和(B,*)是两个代数系统，f:A-&gt;B，且任意x,y属于A有f(x%y)=f(x)*f(y)，则称f是A到B的同态映射，简称同态 5.2同态分类： 5.2.1f为单射，则称为单同态 5.2.2f为满射，则称为满同态，这时称B为A的同态像，记作A~B 5.2.3f为双射，则称为同构，也称代数系统A同构于B，记作A~=B 5.2.4若A=B，则称作自同态 5.3满同态映射保持运算的规律 ​ 5.4满同态映射保持特异元素 ​ 二、半群1.半群的定义1.1半群定义1：设*是非空集合S上的一个二元代数运算，称为乘法。如果任意a,b,c属于S，有(a*b)*c=a*(b*c)，则称集合S关于乘法*作成一个半群，并记为(S,*) 1.2半群定义2：设(S,*)是一个代数系统，如果运算*满足结合律，则称(S,*)为一个半群 1.3可换半群（交换半群）：如果半群(S,*)中的二元运算满足交换律，则称(S,*)为可换半群 1.4若S为有限集（无限集），称半群(S,*)为有限半群（无限半群） 1.5一般，对任意一个正整数n，必有一个恰好含有n个元素的半群（模n剩余类） 1.6单位元并不是半群的固有性质，没有单位元的半群中有可能有多个左（右）单位元 1.7如果半群(S,*)既有左单位元又有右单位元，则左单位元与右单位元相等，从而有单位元且单位元唯一 1.8有单位元的半群称为独异点或称为幺半群或含幺半群 2.子半群2.1子半群定义1：设(S,*)是一个半群，B是S的一个非空子集。如果B对运算*封闭，则称(B,*)是(S,*)的一个子半群，并简称B是S的子半群 2.2子半群定义2：设(S,*)是一个半群，B是S的一个非空子集。如果任意a,b属于B，都有a*b属于B，则称(B,*)是(S,*)的一个子半群，并简称B是S的子半群 2.3子半群的判别：半群(S,*)的非空子集B是子半群当且仅当B*B包含于B 2.4子半群性质：设(S,*)是一个半群，A是S的一个非空子集，则S的一切包含A的子半群的交集Q也是S的子半群，Q称为由A生成的子半群，记作(A) 2.5半群的理想：若SA包含于A，半群(S,*)的一个非空子集A称为S的一个左理想；若A既是S的左理想又是S的右理想，称A是S的理想 2.6生成的理想：半群(S,*)的非空子集A生成的左（右）理想为半群(S,*)的所有包含A的左（右）理想的交；S的包含A的一切理想的交称为由A生成的理想 2.7设A是半群(S,*)的一个非空子集，(V为集合的并运算)则 2.7.1由A生成的左理想为AVSA 2.7.2由A生成的右理想为AVAS 2.7.3由A生成的理想是AVSAVASVSAS 2.8循环半群：如果这个半群是由其中的某个元素生成的，由元素a生成的循环半群记为(a) 2.9循环半群必是可换半群 3.半群的同态与同构3.1同态定义：设(S1,%)和(S2,*)是两个半群，如果存在一个从S1到S2的映射f，使得对任意x,y属于S1有f(x%y)=f(x)*f(y) 3.2f单射–单同态；f满射–满同态；f双射–同构 3.3设(S1,%)为一个半群，(S2,*)是一个代数系统。若存在一个从S1到S2的满同态（映射）f，则(S2,*)是一个半群 3.4设f是半群(S1,%)到半群(S2,*)的同态，g是半群(S2,*)到半群(S3,.)的同态，则gf是半群(S1,%)到半群(S3,.)的同态 3.5设(S,%)和(T,*)是两个半群，f是S到T的同态。半群(S/Ef,.)称为商半群，其中Ef为等价关系，S/Ef为等价关系对集合的划分得到的商集。令r:S-&gt;S/Ef，任意a属于S，r(a)=[a]，则称为r为S到S/Ef的自然同态，可证明r为S到S/Ef的一个满射 三、幺半群1.幺半群的定义1.1幺半群定义： 1.1.1设(S,*)是半群，若e属于S是关于*运算的单位元，则称(S,*)是幺半群，也叫独异点，也记作(S,*,e) 1.1.2有单位元的半群(S,*)称为幺半群或独异点 1.1.3如果幺半群中二元运算满足交换律，则称其为交换幺半群或可换幺半群 1.2把S的基数称为幺半群(S,*,e)的阶，一般地，对任何一个正整数n，必有一个恰好含有n个元素地幺半群（模n剩余类） 1.3幺半群地单位元必有逆元，其他元不一定有逆元 1.4有限半群(S,*)为一个幺半群当且仅当存在s,t属于S使得sS=S,St=S 1.5有限半群(S,*)为一个群当且仅当任意s属于S有sS=S，且存在t属于S使得St=S 2.子幺半群2.1子幺半群的定义：设(S,*,e)是一个幺半群，B是S的一个子集。如果任意a,b属于B，都有a*b属于B，且e属于B，则称B是S的子幺半群（含单位元的子半群） 2.2子幺半群的判别：幺半群(S,*)的子集B是子幺半群当且仅当e属于B且B*B包含于B 2.3子幺半群的性质： 2.3.1一个幺半群的任意多个子幺半群的交集仍是该幺半群的子幺半群 2.3.2设(S,*,e)是一个幺半群，A是S的一个非空子集，则S的一切包含A的子幺半群的交集Q也是S的子幺半群 2.4生成子幺半群：设A是幺半群(S,*)的一个非空子集，由S的包含A的所有子幺半群的交称为由A生成的子幺半群，记为(A) 2.5幺半群的理想 2.5.1理想的定义：若SA包含于A，则幺半群(S,*,e)的一个非空子集A称为S的一个左理想；如A既是S的左理想又是S的右理想，则称A是S的理想 2.5.2生成的理想的定义：幺半群(S,*,e)的非空子集A生成的左（右）理想为半群(S,*)的所有包含A的左（右）理想的交；S的包含A的一切理想的交称为由A生成的理想 2.5.3设A是幺半群(S,*,e)的一个非空子集，则 2.5.3.1由A生成的左理想是SA 2.5.3.2由A生成的右理想是AS 2.5.3.3由A生成的理想是SAS 2.6循环幺半群：由其中的某个元素生成的幺半群，必是可换幺半群 3.幺半群的同态与同构3.1同态的定义：设(S1,%,e1)和(S2,*,e2)是两个幺半群，如果存在一个从S1到S2的映射f，使得任意x,y属于S1，有f(x%y)=f(x)*f(y)，f(e1)=e2，则称f为S1到S2的一个同态（映射），而称幺半群S1与S2同态 3.2f单射-&gt;单同态;f满射-&gt;满同态;f双射-&gt;同构 3.3幺半群的Cayley定理： 3.3.1设S是一个非空集合，一个从S到S的映射称为S的一个变换。一个从S到S的满射、单射或双射称为S的一个满射变换、单射变换或一一变换 3.3.2幺半群的Cayley定理：任何幺半群(S,%,e)同构于某个变换幺半群(L(S),*,Is) 3.4幺半群同态的性质： 3.4.1设(S1,%,e1)是一个幺半群，(S2,*)是一个代数系统。如果存在一个从S1到S2的满射f，使得任意x,y属于S1有f(x%y)=f(x)*f(y)，则(S2,*)是一个幺半群 3.4.2设(S1,%,e1)和(S2,*,e2)是两个幺半群。如果S1到S2的有一个同态f，则S1的可逆元a的像f(a)也可逆且f(a)-=f(a-) 3.5商幺半群根据商半群可类似定义商幺半群 3.6幺半群的同态基本定理： ​ 四、群1.群的定义1.1定义1：设(G,*,e)是幺半群，若G中的每个元素都有逆元，则称(G,*,e)是群，记作(G,*)，有时简记为G 1.2定义2：设G是一个非空集合，*是G上的二元代数运算，称为乘法。如果下列三个条件成立，则称G关于乘法*作成一个群 1.2.1乘法*满足结合律 1.2.2G关于乘法*有一个左单位元（若为右单位元，则1.2.3里为右逆元）e，即任意a属于G，存在元e属于G，使得e*a=a 1.2.3对于G的每个元素，关于乘法*有一个左逆元，即任意a属于G，存在元b属于G，使得b*a=e，e为1.2.2中单位元 1.3定义3：设G是一个非空集合，*是G上的二元代数运算，称为乘法。如果下列两个条件成立，则称G关于乘法*作成一个群 1.3.1乘法*满足结合律 1.3.2任意a,b属于G，方程a*x=b和y*a=b在G中有解 2.群的基本性质2.1设(G,*)为群，则任意a属于G，a的左逆元也是a的右逆元 2.2设(G,*)为群，则G的左单位元e也是右单位元 2.3设(G,*)为群，则任意a,b属于G，方程a*x=b和y*a=b在G中的解唯一 2.4群(G,*)中的乘法满足消去律，即任意a,b,c属于G有： 2.4.1若a*b=a*c，则b=c(左消去律) 2.4.2若b*a=c*a，则b=c(右消去律) 2.5设(G,*)为群，则 2.5.1任意a属于G，(a-)-=a 2.5.2任意a,b属于G，(a*b)-=b-*a- 2.6线性空间 ​ ​ 3.群的术语3.1若G是有限集，称群(G,*)是有限群。G的基数称为群G的阶，有限群G的阶记作|G| 3.2若G是无限集，称群(G,*)是无限群 3.3若群(G,*)中的二元运算满足交换律，则称(G,*)为交换律或阿贝尔(Abel)群 3.4实例 ​ 3.5群中元素的幂 3.5.1设G是群，a属于G，n属于Z，则a的n次幂为（群中元素可以定义负整数次幂）： ​ 3.5.2设G为群，则G中的幂运算满足： 3.5.2.1任意a属于G，a^n*a^m=a^(n+m)，n,m属于Z 3.5.2.2任意a属于G，(a^n)^m=a^(n*m)，n,m属于Z 3.5.2.3若G为交换群，则(a*b)^n=a^n*b^n 3.6元素的阶 3.6.1定义：设G是群，a属于G，使得等式a^k=e成立的最小正整数k称为a的阶，记作|a|=k，称a为k阶元。若不存在这样的正整数k，则称a为无限阶元 3.6.2G为群，a属于G且|a|=r，设k是整数，则 3.6.2.1a^k=e当且仅当r|k 3.6.2.2|a-|=|a| 4.有限群的定义及性质4.1有限群的定义1：设G是一个非空有限集合，*是G上的二元代数，称为乘法。若下列两个条件成立，则称G关于乘法*作成一个有限群 4.1.1乘法*满足结合律 4.1.2乘法*满足消去律 4.2有限群的定义2：设G是一个非空有限集合，*是G上的二元代数运算，称为乘法。若下列两个条件成立，则称G关于乘法*作成一个有限群 4.2.1乘法*满足集合律 4.2.2任意a,b存在G，方程a*x=b和y*a=b在G中有解 4.3有限群的性质： 4.3.1有限群的每个元素的阶均为有限且不超过群的阶 4.3.2偶数阶群必含2阶元 5.子群的定义5.1子群就是群的子代数 5.2子群的定义1：设G是群，H是G的非空子集，如果H关于G中的运算封闭且H与G含有相同的代数常数，则称H为G的子群，记作H&lt;=G 5.3子群的定义2：设G是群，H是G的非空子集 5.3.1如果H关于G中的运算封闭且构成群，则称H是G的子群，记作H&lt;=G 5.3.2若H为G的子群，且H为G的真子集，则称H为G的真子群，记作H&lt;G 5.4平凡子群：群本身以及只包含单位元的群 6.子群的性质6.1设G是群，H&lt;=G，则 6.1.1H的单位元必是G单位元 6.1.2H的元素a在H中的逆元也是a在G中的逆元 6.2设G是群，H,K是G的子群，则 6.2.1HNK也是G的子群=&gt;G任意多个子群的交集还是G的子群 6.2.2HUK是G的子群当且仅当H包含于K或K包含于H 6.2.3任一群不能是其两个真子群的并集 6.3一个群可以是其三个真子群的并集 7.子群的判别7.0根据子群的定义可以推导其判别方法 7.1设G为群，H是G的非空子集，则H是G的子群当且仅当 7.1.1任意a,b属于H有a*b属于H 7.1.2任意a属于H有a-属于H 7.2设G为群，H是G的非空子集。H是G的子群当且仅当任意a,b属于H有a*(b-)属于H 7.3设G为群，H是G的非空有限子集，则H是G的子群当且仅当任意a,b属于H有a*b属于H 8.生成子群8.1群的中心 ​ 8.2群的生成子群的定义1：设G为群，M是G的非空子集，G的所有包含M的子群的交集称为由M生成的子群，记为(M) 8.3生成子群的定义2：设G为群，a属于G，令H={a^k|k属于Z}，则H是G的子群，称为由a生成的子群，记作(a) 8.4实例：Klein四元群G={e,a,b,c}的所有生成子群是：(e)={e},(a)={e,a},(b)={e,b},(c)={e,c} 9.变换群的定义9.1变换的定义：设S是一个非空集合，一个从S到S的映射称为S的一个变换。一个从S到S的满射、单射或双射称为S的一个满射变换、单射变换或一一变换 9.2对称群的定义（变换的集合、映射的集合）：设S是一个非空集合，从S到S的所有一一变换之集记为Sym(S)，则称Sym(S)对变换的合成*构成一个群，称为S上的对称群，记作(Sym(S),*) 9.3变换群的定义1：群(Sym(S),*)的任一子群称为S上的一个变换群。 9.4变换群的定义2：一个非空集合S的若干个一一变换关于变换的合成*作成的一个群称为S的一个变换群 10.群的同构定义10.0设(G1,%)和(G2,*)是两个群。如果存在一个双射f:G1-&gt;G2，且任意x,y属于G1有f(x%y)=f(x)*f(y)，则称群G1与G2同构，记为G1~=G2.称f是G1到G2的一个同构（映射） 11.群的Cayley定理11.1群的Cayley定理：任意一个群都同构于某个变换群 11.2设(G,*)是一个群。若存在一个双射f:G-&gt;G，且对任意x,y属于G有f(x*y)=f(x)*f(y)，则称f是G的一个自同构（映射） 11.3设(G,*)是一个群。G的所有自同构之集A(G)对映射的合成运算构成一个群，称为G的自同构群 11.4设(G,*)是一个群。a是G的一个固定元素，任意x属于G，f(x)=a*x*(a-)，则f是G的一个自同构（映射）。称f是由a确定的G的一个内自同构。G的其他自同构称为外自同构。 11.5设(G,*)是一个群。G的所有内自同构之集是G的自同构群得一个子群，称为内自同构群 11.6补充： 11.6.1非一一变换关于变换合成所作成得群是存在得 11.6.2设M是任一非空集合，G是由M的若干个变换作成的群。可证明：G是M上的一个变换群当且仅当M上的恒等变换Im属于G 11.6.3设M是任一非空集合，G是由M的若干个变换作成的群。可证明：G是M上的一个变换群当且仅当由M上的单射f属于G 11.6.4设M是任一非空集合，G是由M的若干个变换作成的群。可证明：G是M上的一个变换群当且仅当由M上的满射f属于G 12.置换的定义12.0设S是一个非空有限集合。一个从S到S的双射称为S的一个置换。若|S|=n，则一个从S到S的双射称为S的一个n元置换 13.置换的表示13.0表示形式： ​ 13.1设f,g是n元置换，f和g的合成f*g也是n元置换，称为f与g的乘积，记作f*g ​ 13.2循环置换的形式 13.2.1k-循环置换 ​ 13.2.2n元恒等置换 ​ 13.2.3n元置换的性质 ​ 13.2.4没有共同数字的循环置换 ​ ​ 13.3对换的形式 13.3.1每个置换都能分解成若干个对换的乘积 13.3.2如果把置换分解成若干个对换的乘积，则对换的个数的奇偶性是不变的 13.3.3如果n元置换f可以表示成奇数个对换之积，则称f为奇置换，否则称为偶置换 13.3.4n元奇置换和n元偶置换的个数相等，各有n!/2个 13.3.5循环置换的分解 ​ 14.置换群的定义14.1定义1：设S是一个n元集合，从S到S的所有置换之集记为Sn，则把Sn对置换的合成*构成一个群，称为S上的n次对称群或n元对称群，记作(Sn,*)。群(Sn,*)的任一子群称为S上的一个n元置换群 1.4.2一个非空有限集合S的若干个置换关于置换的合成*作成的一个群称为S的一个置换群 15.置换群的Cayley定理15.1任意一个有限群都同构于某个置换群 15.2设An是所有的n元偶置换作成一个集合，则An关于置换的合成作成一个群，称为n元交错群或n元交代群。显然An是Sn的一个子群 16.循环群的定义16.1定义1：设G是群，如果G是由其中的某个元素a生成的，则称G是循环群，记作G=(a)，称a为G的生成元 16.2定义2：设G是群，若存在a属于G使得G={a^k|k属于Z}，则称G是循环群，记作G=(a)，称a为G的生成元 16.3性质： 16.3.1如果循环群G是由a生成的，则任意b属于G，存在一个整数m使得b=a^m 16.3.2循环群必是交换群 17.循环群的结构17.0设G=(a)是循环群，根据生成元a的阶 17.1若a是n阶元，则G={a^0=e,a^1,a^2,…,a^(n-1)}，那么|G|=n，称G为n阶循环群 17.2若a是无限阶元，则G={a^0=e,a^(+/-1),a^(+/-2)…}，称G为无限循环群 18.循环群的数量18.1设(G1,%)和(G2,*)是两个群。如果存在一个双射f:G1-&gt;G2，且任意x,y属于G1有f(x%y)=f(x)*f(y)，则称群G1与G2同构，记为G1~=G2。而称f是G1到G2的一个同构（映射） 18.2n阶循环群同构于Zn（剩余类）关于剩余类加法的类 18.3无限循环群同构于Z关于整数加法的类 19.循环群的生成元19.1设G=(a)是循环群 19.1.1若G是无限循环群，则G只有两个生成元，即a与a- 19.1.2若G是n阶循环群，则G含有Q(n)个生成元。对于任何小于n且与n互质的数r属于{0,1,…,n-1},a^r是G的生成元。其中Q(n)称为欧拉函数：小于或等于n且与n互质的正整数的个数 20.循环群的子群20.1设G=(a)是循环群，则 20.1.1循环群G的子群仍是循环群 20.1.2若G=(a)是无限循环群，则G的子群除{e}以外都是无限循环群(a^m)，m=1,2,… 20.1.3若G=(a)是n阶循环群，则G的每个子群的阶整除群的阶n。对n的每个正因子d，G有且只有一个d阶子群。G的全部子群为(a^m)，m|n 20.2实例 ​ 21.子群的陪集21.1设H是群G的子群，a属于G。 21.1.1令aH={ah|h属于H}，称aH是子群H在G中的左陪集，称a为aH的代表元素 21.1.2令Ha={ha|h属于H}，称Ha是子群H在G中的右陪集，称a为Ha的代表元素 21.2左陪集的基本性质 21.2.1设H是群G的子群，则 21.2.1.1eH=H 21.2.1.2任意a属于G，有a属于aH 21.2.2设H是群G的子群，则任意a,b属于G有(a属于bH)&lt;=&gt;(b属于aH)&lt;=&gt;((a-)b属于H)&lt;=&gt;(aH=bH) 21.2.3设H是群G的子群，则 21.2.3.1任意a属于G，aH!=O(O为空集) 21.2.3.2任意a,b属于G，aH=bH或aHNbH=O(O为空集) 21.2.3.3UaH=G 21.2.4设H是群G的子群，则H的所有左陪集构成的集族是G的一个划分 21.2.5设H是群G的子群，则任意a,b属于G，|aH|=|bH|=|H|=|Ha|=|Hb| 21.2.6设H是群G的子群，令Sl为H的所有左陪集构成的集族，Sr为H的所有右陪集构成的集族，则|Sl|=|Sr| 22.Lagrange定理22.1定义：设G是有限群，H是G的子群，则|G|=|H|*[G:H]，其中[G:H]是H在G中的不同左陪集（或右陪集）个数，称为H在G中的指数 22.2推论1：设G是n阶群，则任意a属于G，|a|是n的因子，且有a^n=e 22.3推论2：对阶为素数的群G，必存在a属于G使得G=(a)（阶为素数的群都是循环群） 23.Lagrange定理的应用23.1如果群G只含1阶和2阶元，则G是Abel群 23.26阶群中必含有3阶元 23.3阶小于6的群都是Abel群 23.4若G是一个有限交换群，则Lagrange定理的逆成立 五、群的同态基本定理1.正规子群与商群1.1正规子群的定义：设H是群G的子群。如果任意a属于G有aH=Ha，则称H是群G的正规子群或不变子群，记作H▲G 1.2商群的定义：群G的正规子群H的所有左陪集构成的集合对群子集乘法形成一个群称为G对H的商群，记为G/H 1.3正规子群的判别定理：设H是群G的一个子群，则 1.3.1H是群G的正规子群&lt;=&gt;任意a属于G有aH(a-)=H 1.3.2H是群G的正规子群&lt;=&gt;任意a属于G有aH(a-)包含于H 1.3.3H是群G的正规子群&lt;=&gt;任意a属于G，h属于G有ah(a-)属于H 2.群的同态定义2.1定义：设(G1,%)和(G2,*)是两个群。如果存在一个从G1到G2的映射f，使得任意x,y属于G1有f(x%y)=f(x)*f(y)，则称f是G1到G2的一个同态（映射），而称群G1与G2同态。f满射–满同态；f单射–单同态 2.2性质： 2.2.1设(G1,%)的(G2,*)是两个群。f是从G1到G2的同态，则 2.2.1.1f(e1)=e2 2.2.1.2任意x属于G1有(f(x))-=f(x-) 2.2.2设(G1,%)是一个群，(G2,*)是一个代数系统。若存在一个从G1到G2的满射f，使得任意x,y属于G1有f(x%y)=f(x)*f(y)，则(G2,*)是一个群 2.2.3设(G1,%)和(G2,*)是两个群。f是从G1到G2的满同态，则G2的单位元e2的完全原象f-(e2)={x|x属于G1，f(x)=e2}是G1的一个正规子群 2.3设(G1,%)和(G2,*)是两个群。f是从G1到G2的满同态，e2是G2的单位元，则G1的正规子群f-(e2)称为同态f的核，记为Ker f。f(G1)称为f下G1的同态象 2.4群的同态性质：设(G1,%)和(G2,*)是两个群，f是从G1到G2的满同态，则 2.4.1如果H1是G1的子群，则f(H1)是G2的子群 2.4.2如果N1是G1的正规子群，则f(N1)是G2的正规子群 2.4.3如果H2是G2的子群，则f-(H2)是G1的子群 2.4.4如果N2是G2的正规子群，则f-(N2)是G1的正规子群 2.5自然同态：设N是G的正规子群，则G~G/N。若f是G到G/N的自然同态，则Ker f=N ​ 3.群的同态基本定理3.1设(G1,%)和(G2,*)是两个群。f是从G1到G2的满同态，E=Ker f，则G1/E~=G2 3.2群(G1,%)到群(G2,*)的任一满同态f均可分解成一个自然同态g与一个同构h的合成，即f=hg并且h是唯一的 3.3群的同态基本定理的应用 ​ 六、环1.环的定义与性质1.1定义：设(R,+,*)是代数系统，+和*是二元运算。若满足以下条件，则称(R,+,*)是一个环 1.1.1(R,+)构成交换群 1.1.2(R,*)构成半群 1.1.3*运算关于+运算满足左、右分配律 1.2通常称+运算为环中的加法，*运算为环中的乘法，环中加法单位元记作0，并称为R的零元（素），乘法单位元（若存在）记作1，对任何元素x，称x的加法逆元为负元，记为-x，若x存在乘法逆元，则称之为逆元，记为x- 1.3若R是有限非空集合，称环(R,+,*)是有限环 1.4设(R,+,*)是环 1.4.1若环中乘法*适合交换律，则称R是交换环或可换环 1.4.2若环中乘法*存在单位元，则称R是含幺环 1.4.3若环含有唯一左（右）单位元e，则e为环的单位元（相对*）（构造re!=0,re-r+e为左单位元矛盾） 1.5运算性质：设(R,+,*)是环，则 1.5.1任意a存在于R，a0=0a=0 1.5.2任意a,b属于R，(-a)b=a(-b)=-ab 1.5.3任意a,b,c属于R，a(b-c)=ab-ac,(b-c)a=ba-ca 1.5.4(na)b=a(nb)=n(ab) 1.6零因子定义：设(R,+,*)是环，a属于R，a!=0。若存在一个元b属于R，b!=0，使得ab=0，则称a是R的一个左零因子。如果a既是R的左零因子，又是R的右零因子，则称a是R的零因子。若R有左零因子，则R必有右零因子 1.7特殊环 1.7.1无零因子环：环R是无零因子环当且仅当在R中乘法满足消去律 ​ 1.7.2整环、除环（体）、域。至少有一个非零元的无零因子有限环是体 1.7.3环(R,+,*)是体的充分必要条件是R\\{0}!=O且任意a,b属于R\\{0}，方程ax=b(xa=b)在R中有解 ​ 1.7.4域中除法及其性质 ​ 2.无零因子环的特征2.1在一个无零因子环中，每个非零元素对加法的阶均相同 2.2体和域中每个非零元素对加法的阶均相同 2.3无零因子环R中非零元素对加法的阶称为该环的特征数，简称特征，记为ChR 2.4若无零因子环R的特征数为正整数p，则p为素数 2.5整环、体和域的特征数或是无穷大，或是一个素数 3.子环、理想子环与商环3.1环(R,+,*)的一个非空子集S若对R中的加法和乘法也作成一个环，则称S为R的一个子环 3.2环(R,+,*)的一个非空子集S若对R中的加法和乘法封闭且也作成一个环，则称S为R的一个子环 3.3平凡子环：{0}和R本身也是R的子环 3.4子环的判定： ​ 3.5子体（域）的定义及其判定 ​ 3.6环与子环包含单位元没有必然联系 3.7理想的概念（构造商环）： ​ 3.8真理想：若I是环R的理想，且I是R的真子集，I称为R的真理想 3.9理想判定定理：设R是环，I是R的非空子集，I是R的理想的充要条件 3.9.1任意a,b属于I，a-b属于I 3.9.2任意r属于R，a属于I，ra属于I，ar属于I 3.10设R是环，A是R的非空子集。R中包含A的一切理想的交称为由A生成的理想，记作(A)。若A={a}，则(A)简记为(a)，并称(a)为R的主理想 3.11任一非零环R至少有两个理想：{0}和R 3.12任一环R的零理想（子环）{0}是主理想 3.13若环R有单位元1，则R是主理想，且R=(1) 3.14生成理想 ​ ​ 3.15体和域只有两个理想，即零理想和它自身 4.环的同态基本定理4.1环的同态定义 ​ 4.2环的同态基本性质 ​ ​ ​ ​ 5.极大理想5.1极大理想的定义1：若H是R的真理想，且R不存在真理想N使得H为N的真子集，则环R的理想H称为R的极大理想 5.2极大理想的定义2：如果除了R同H自己以外，没有包含H的理想，则环R的一个不等于R的理想H称为R的极大理想 5.3极大理想的定义3：若N是R的理想，且H为N的真子集，则N=R（即R没有包含H且不等于H的真理想），则环R的真理想H称为R的极大理想 5.4一个域的理想只有零理想{0}和它自身，反过来，一个只有这两个理想的环不一定是域 5.5若含幺交换环R除了零理想{0}和它自身以外没有其他的理想，则R一定是域 5.6设R是一个有单位元的可换环，H是R的理想。R/H是域当且仅当H是R的极大理想 5.7若P不为素数，则Zp肯定不是域 5.8关于整环相关问题 ​ ​ ​ 七、格1.格的定义及性质1.1格的定义1：设(L,《)是偏序集，如果任意x,y属于L，{x,y}都有上确界和下确界，则称L关于偏序《作成一个格 1.2格的定义2：设(L,《)是偏序集，如果任意x,y属于L，上确界sup{x,y}和下确界inf{x,y}都存在，则称(L,《)为格 1.3求{x,y}上确界和下确界可以看成x,y的二元运算^和V，即： 1.3.1xVy=sup{x,y}（称为x与y的并） 1.3.2x^y=inf{x,y}（称为x与y的交） 1.3.3实例： ​ 1.3.4并非所有偏序集都是格（缺少上确界或下确界） 1.3.5任一全序集必是格 1.3.6子群格：设G为群，令L(G)={H|H为G的子群}，则偏序集(L(G),集合包含运算)称为G的子群格 1.3.6.1H1^H2=H1与H2的交集 1.3.6.2H1VH2=H1与H2的并集的生成子群（两个子群的并集不一定是子集） 1.3.6.3子群格实例 ​ 1.4格的性质：（对偶原理）设f是含有格中元素以及符号=，《，》，^，V的命题，令f*是将f中的《替换成》，》替换成《，V替换为^，^替换成V所得到的命题，则称f*为f的对偶命题 1.5格的对偶原理：设f是含有格中元素以及符号=，《，》，V，^等的命题，若f对一切格为真，则f的对偶命题f*也对一切格为真 1.6根据上确界和下确界定义，设(L，《 )为格，任意x,y,z属于L，则 1.6.1x《 xVy,y《 xVy;x^y《 x,x^y《 y 1.6.2若x《 z，y《 z，则xVy《 z 1.6.3若z《 x，z《 x，则z《 x^y 1.7设(L，《)是格，则运算V和^满足交换律、结合律、幂等律和吸收律 1.7.0吸收律：aV(a^b)=a,a^(aVb)=a（可结合交换律完成一系列等价代换） 1.8设L是格，则任意a,b属于L有a《 b &lt;=&gt; a^b=a &lt;=&gt; aVb=b 1.9设L是格，任意a,b,c,d属于L，若a《 b且c《 b，则a^c《 b^d，aVc《 bVd 1.10设L是格，任意a,b,c处于L，若b《 c，则a^b《 a^c，aVb《 aVc 1.11一般说来，格中的V和^运算不满足分配律 1.12格的定义3：设(S,*,%)是具有两个二元运算的代数系统，若对于*和%运算适合交换律、结合律、吸收律，则可以适当定义S中偏序关系《 ，使得(S,《)构成格，且任意a,b属于S有sup{a,b}=aVb=a%b,inf{a,b}=a^b=a*b 1.13格的定义4：设(S,*,·)是代数系统，*和·是二元运算，如果*和·满足交换律、结合律和吸收律，则(S,*,·)构成格 1.14格的定义分类：代数格：由代数系统定义；偏序格：由偏序集定义 2.子格2.1定义1：设(L,N,V)是格，S是L的非空子集，若S关于L中的运算N和V封闭，则称S是L的子格 2.2定义2：设(L,N,V)是格，S是L的非空子集，若S关于L中的运算N和V仍构成格，则称S是L的子格 3.格的同态与同构3.1​ 3.2​ 4.特殊格4.1有界格 4.1.1设L是格，若L存在最大元素和最小元素，则称L为有界格，一般将有界格记为(L,N,V,0,1) 4.1.2补充定义： 4.1.2.1最大元素：设(L,《 )是一个格，B被L包含，如果存在a属于B使得对B中每个元素x有x《 a，则称a是B中的最小元素 4.1.2.2最小元素：设(L,《 )是一个格，B被L包含，如果存在b属于B使得对B中的每个元素有b《 x，则称b是B中的最小元素 4.1.2.3一般将格中最大元素称为格的单位元，记为1；相反最小元素称为格的零元，记为0 4.1.3性质1：设(L,N,V,0,1)是有界格，则任意a属于L有aN0=0,aV0=a,aN1=a,aV1=1 4.1.4性质2：所有元素N=0，所有元素V=1 4.1.5性质3：对偶时0-&gt;1,1-&gt;0 4.1.6设(L,N,V,0,1)是有界格，a属于L，若存在b属于L使得aNb=0和aVb=1成立，则称b为a的补元 4.2有补格 4.2.1概念：设(L,N,V,0,1)是有界格，若L中所有元素都有补元存在，则称L为有补格 4.3分配格 4.3.1概念：设(L,N,V)是格，若任意a,b,c属于L，有aN(bVc)=(aNb)V(aNc),aV(bNc)=(aVb)N(aVc)则称L为分配格 4.3.2实例 ​ 4.3.3分配格的判别：设L是格，则L是分配格当且仅当L不含有与钻石格或五角格同构的子格 4.3.4推论： 4.3.4.1小于五元的格都是分配格 4.3.4.2任何一条链都是分配格，每个全序集都是分配格 4.3.5性质1：设(L,N,V)是格，若任意a,b,c属于L，有aN(bVc)=(aNb)V(aNc)&lt;=&gt;aV(bNc)=(aVb)N(aVc) 4.3.6性质2：设(L,N,V)是分配格，任意a,b,c属于L，如果aNb=aNc且aVb=aVc，则b=c 4.3.7性质3：设(L,N,V,0,1)是有界分配格，若L中元素a存在补元，则存在唯一补元 4.3.8性质4：任意全序集都是分配格 4.3.9性质5：有界分配格中，一切有补元的集合构成一个子格 4.3.10性质6：有补分配格中，De Morgan律成立，即任意a,b属于B，有(aNb)’=a’Vb’,(aVb)’=a’Nb’ 4.4注意事项 ​ 八、布尔代数1.布尔代数的定义及性质1.1布尔代数定义：如果一个格是有补分配格，则称它为布尔格或布尔代数(L,N,V,’,0,1)，其中’为求补运算 1.1.0例子：设B为任意集合，则B的幂集格(P(B),N,V,~,O,B)构成布尔代数 1.2布尔代数性质1： 1.2.1(B,《 )为偏序集 1.2.2(B,N,V)是一个格 1.2.3(B,N,V)是一个有界格 1.2.4(B,N,V)是一个有补格 1.2.5(B,N,V)是一个分配格 1.3布尔代数性质2：设(B,N,V,’,0,1)是任一布尔代数，则运算V和N适合交换律、结合律、幂等律和吸收律 1.4布尔代数性质3：设(B,N,V,’,0,1)是任一布尔代数，则 1.4.1任意a,b属于B，有aNb=inf{a,b},aVb=sup{a,b};a《 b &lt;=&gt; aNb=a &lt;=&gt; aVb=b;a《 b &lt;=&gt; aNb’=0 &lt;=&gt; b’《 a’ &lt;=&gt; a’Vb=1 1.4.2任意a属于B有0《 a《 1;aN0=0,aV0=a;aN1=a,aV1=1 1.5布尔代数性质4：设(B,N,V,’,0,1)是任一布尔代数，则有 1.5.1任意a,b,c属于B，有aN(bVc)=(aNb)V(aNc),aV(bNc)=(aVb)N(aVc) 1.5.2任意a,b,c属于L，如果aNb=aNc且aVb=aVc，则b=c 1.5.3任意a,b,c属于B，有(aNb)V(bNc)V(cNa)=(aVb)N(bVc)N(cVa)（对偶式成立） 1.6布尔代数性质5：设(B,N,V,’,0,1)是任一布尔代数，则有 1.6.1任意a,b属于B，有aNa’=0,aVa’=1 1.6.20’=1,1’=0 1.6.3De Morgan律成立，即任意a,b属于B，(aNb)’=a’Vb’,(aVb)’=a’Nb’ 1.7布尔代数作为代数系统的定义：设(B,*,·)是一个至少含有两个元素的代数系统，*和·是二元运算，若*和·运算满足交换律、分配律、同一律和补元律，则称(B,*,·)是一个布尔代数 ​ 2.布尔代数与布尔环的等价性2.1(B,@,&amp;)是一个环，@为对称差，&amp;为乘法，a@b=(aNb’)V(a’Nb),a&amp;b=aNb,布尔代数中的0为加法@的单位元，1为乘法&amp;的单位元 2.2性质1：设(R,+,*)是一个环，如果环R中每个元素都是幂等元，即任意a属于R，a*a=a，则环R为交换环，且任意a属于R，a+a=0 2.3性质2：若环R中每个元素都是幂等元，则称环为布尔环 2.4等价性： 2.4.1任一布尔代数都定义了一个有单位元素的布尔环 2.4.2任一有单位元素的布尔环都定义了一个布尔代数 2.4.3（Stone）布尔代数与具有单位元素的布尔环是两种等价的代数结构 3.布尔代数的理想和同态3.1子布尔代数的定义：设(B,N,V,’,0,1)是子布尔代数，S是B的一个非空子集，若满足以下两个条件，则称(S,N,V,’,0,1)是(B,N,V,’,0,1)的子布尔代数 3.1.1 0，1属于S 3.1.2任意a,b属于S，aNb,aVb,a’均属于S（封闭） 3.2子布尔代数的判别：设(B,N,V,’,0,1)是布尔代数，S是B的一个非空子集，则(S,N,V,’,0,1)是(B,N,V,’,0,1)的子布尔代数等价于以下两个条件 3.2.1任意a属于S，a’属于S 3.2.2任意a,b属于S，aNb属于S（或aVb属于S） 3.3子布尔代数的例子：设(S,N,V,’,0,1)是布尔代数，则 3.3.1({0,1},N,V,’,0,1)是(B,N,V,’,0,1)的一个子布尔代数 3.3.2如果a属于B，a!=0，a!=1，则({0,a,a’,1},N,V,’,0,1)是(B,N,V,’,0,1)的一个子布尔代数 3.4布尔环的理想判定：设(B,+,·)是布尔环，S是B的非空子集。S是B的理想的充要条件是 3.4.1任意a,b属于S，a+b属于S 3.4.2任意r属于B，a属于S，r·a属于S 3.5布尔代数理想：设(B,N,V,’,0,1)是布尔代数，S是B的一个非空子集，称S为(B,N,V,’,0,1)的理想 3.5.1V再S中封闭，即任意a,b属于S，aVb属于S 3.5.2任意r属于B，a属于S，rNa属于S 3.6布尔代数的理想：设(B,N,V,’,0,1)是布尔代数，S是B的一个非空子集，若满足下列两个条件，则称S是(B,N,V,’,0,1)的理想 3.6.1V在S中封闭，即任意a,b属于S，aVb属于S 3.6.2任意a属于S，只要r《 a就有r属于S 3.7真理想：若理想S!=B，则称S为真理想 3.7.1若S是真理想，则1不属于S 3.7.2理想不一定是子布尔代数 3.8生成的主理想：设(B,N,V,’,0,1)是布尔代数，a是B的任一元素，则称理想(a)={x|x属于B且x《 a}为由a生成的主理想 3.8.1若R是交换环且含幺环，则(a)={sa|s属于R} 3.9布尔代数的极大理想：布尔代数(B,N,V,’,0,1)的理想I称为极大理想&lt;=&gt;I为真理想且不存在真理想J使I被J包含&lt;=&gt;I为真理想且任意a属于B有a属于I或a’属于I 3.10布尔代数的同态定义 ​ 3.11简化定义 ​ 3.11.1简化定义只需满足2个或以上条件即可定义，但必须满足f(x’)=~f(x) 4.有限布尔代数的表示定理4.1原子的概念1：设(B,N,V,’,0,1)是布尔代数。B中非零元a称为B的一个原子&lt;=&gt;若在B中不存在元素x，x!=0，x!=a，使得0《 x《 a &lt;=&gt;若在B中不存在元素x，x!=0，x!=a，使得0&lt;x&lt;a &lt;=&gt;若任意x属于B有0&lt;x《 a，则x=a &lt;=&gt;若任意x属于B有0《 x《 a，则x=0或x=a 4.2原子的概念2：设(L,《 )是格，且具有最小元0.L中非零元a称为L的一个原子&lt;=&gt;若在L中不存在元素x，x!=0，x!=a，使得0&lt;x&lt;a&lt;=&gt;若任意x属于L，有0&lt;x《 a，则x=a&lt;=&gt;若任意x属于L，有0《 x《 a，则x=0或x=a 4.3原子的性质： 4.3.1设(B,N,V,’,0,1)是布尔代数，B中非零元a是原子&lt;=&gt;任意x属于B，aNx=0或aNx=a 4.3.2布尔代数中任两个原子a于b的交aNb=0 4.3.3设(B,N,V,’,0,1)是有限布尔代数，则B中任一非零元b，必有原子a使a《 b 4.3.4任一至少含有两个元素的有限布尔代数必有原子 4.4有限布尔代数的表示定理：设(B,N,V,’,0,1)是有限布尔代数，A是B的全体原子构成的集合，则B同构于A的布尔代数(P(A),N,U,~,O,A) 4.5对于无限布尔代数4.3.3与4.4不成立 4.6一个无限布尔代数同构于某个集合的幂集的子族构成的布尔代数 4.7补充： ​ ​ ​ 转自笔者CSDN的账号 本笔记除了自己的一些理解外，参考《近世代数》诸多ppt，图片出自ppt和网络，如有侵权，请联系笔者删除。 最后希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/01/11/jin-shi-dai-shu-bi-ji/","date":"01-11","excerpt":"","tags":[{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"}]},{"title":"《Head First Java》读书笔记","text":"一、进入Java的世界（基本概念）1.源文件（.java）–编译—&gt;类文件（.class） 2.命令Java虚拟机（JVM）执行程序 3.语句以分号结束 4.以两条斜线开始的行是注释 5.空格符通常无关紧要 6.（boolean测试）判断True和False不能像C/C++里0和1代替 二、拜访对象村（类与对象）1.对象的思想，理解对象、属性、动作（方法） 2.面向对象的适应性与可扩展性 3.类可以继承自较为抽象的父类 4.创建类时，可能同时会需要创建独立、测试用的类 三、认识变量（primitive主数据类型和引用）1.变量有两种：primitive主数据类型和引用 2.父类 变量名=new 子类（）；可行 3.名称必须以字母、_、$符号开头，不可以用数字开头 4.除第一个字符之外，后面都可以用数字 5.变量命名避开Java的保留字（关键字） 6.primitive主数据类型变量是以字节来代替实际的变量值，但对象引用变量却是以字节来表示取得对象的方法 7.对象本身（堆）并没有被放进变量（栈）中，变量储存引用（遥控器） 8.Java十分注意类型 9.数组一定是个对象 四、对象的行为（方法操作实例变量）1.状态影响行为、行为影响状态；状态：实例变量，行为：方法 2.类所描述的是对象知到什么和执行什么 3.实参是传给方法的值，当它传入方法后就成了形参 4.方法返回值必须与return后的值类型兼容（隐式转换） 5.方法a(int b)传入的b是b的克隆，a(int&amp; b)传入的b是b的引用变量（远程控制） 6.传入与传出方法的值类型可以隐含地放大或是明确地缩小 7.（封装）public的实例变量是暴露的，可以用.存取 8.实例变量永远都会有默认值，局部变量没有默认值（实例变量可以不初始化，局部变量必须初始化） 9.比较变量是否相等： 9.1primitive变量用== 9.2引用变量引用的是否为同一变量用== 9.3引用变量判断变量是否真的相等用equals() 10.相等的意义要视对象的类型而定 11.==用来比对两个变量的字节组合，实质代表的意义则不重要 五、超强力方法（编写程序）1.程序设计从高层的设计开始 2.创建新类：伪码（描述做什么）—测试码—真实码 3.使用Interger.parseInt()来取得String的整数值 4.for(String name:nameArray){} 六、使用Java函数库（认识Java的API）1.函数库（Java API） 2.指明程序代码中所使用到的类的完整名称： 2.1import （包名.类名）java.util.ArrayList; 2.1在程序中打出全名 3.除了java.lang以外，使用到其他包的类都需要指定全名 七、对象村的优质生活（继承与多态）1.继承（extends）概念下的IS-A测试是个单向的关系 2.X IS-A Y隐喻着X可以做出任何Y可以做的事情 3.子类会继承父类所有public类型的实例变量和方法，但不会继承父类所有private类型的变量和方法 4.重载与多态毫无关系 八、深入多态（接口与抽象类）1.接口是一种100%纯抽象的类 2.不能在非抽象类中拥有抽象方法 3.抽象方法的意义是就算无法实现出方法的内容，但还是可以定义出一种子型共同的协议 4.抽象类可以带有抽象和非抽象的方法 5.instance of来判断类 型 6.Java不允许多重继承，可能会导致致命方块的问题 九、对象的前世今生（构造器与垃圾收集器）1.在Java中，程序员会在乎内存中的两个区域：对象的生存空间堆（heap）和方法调用及变量的生存空间（stack） 2.对象都存活与可垃圾回收的堆上 3.局部变量又称栈变量，生命周期只限于方法被放在栈上的这段时间 4.实例变量是被声明在类而不是方法里面，存在于所属的对象中 5.对象引用变量与primitive主数据类型变量都是放在栈上 6.唯一能够调用构造函数的方法就是新建一个类 7.构造函数不会被继承 8.一定要有不需要参数的构造函数 9.如果类有一个以上的构造函数，则参数一定要不一样（类型或顺序不同） 10.构造函数必须与类同名且没有返回类型 11.实例变量有默认值，原始的默认值是0、0.0、false，引用的默认值为null 12.在创建新对象时，所有继承下来的构造函数都会执行（子类构造函数开始执行最先执行父类构造函数，父类的构造函数先执行完后继续执行子类构造函数） 13.在类的构造函数里调用super();来调用父类构造函数，默认自带，自己添加必须在最前面 14.如果对对象的唯一引用死了，对象就会从堆中被踢开 15.有三种方式可以释放对象的引用： 15.1引用永久性的离开它的范围 15.2引用被赋值到其他的对象上 15.3直接将引用设定为null 十、数字很重要 （数字与静态）1.Math方法：最接近全局的方法 2.Math的所有方法都是静态的，所以无需Math的实例，只会用到类本身 3.Math的构造函数被标记为私有的，这代表不能新建Math的对象 4.一个静态的方法代表说“一种不依靠实例变量也就不需要对象的行为” 5.静态的方法不能调用非静态的变量 6.静态变量的功用：被同类的所有实例共享的变量 7.通常，Java虚拟机会加载某个类是因为第一次有人尝试要创建该类的新实例，或是使用该类的静态方法或变量 8.静态项目的初始化有两项保证： 8.1静态变量会在该类的任何对象创建之前就完成初始化 8.2静态变量会在该类的任何静态方法执行之前就初始化 9.静态的final变量是常数，常数变量的名称应该要都是大写字母 10.静态final变量的初始化： 10.1声明时直接赋值 10.2在静态初始化程序中赋值：static{} 11.可以用final关键字来修饰非静态的变量，包括实例变量、局部变量甚至是方法的参数，不管哪一种，都代表它的值不能变动 12.final的方法无法被覆盖，final的类无法被继承 13.如果类只有静态的方法，你可以将构造函数标记为private的以避免被初始化 14.primitive主数据类型的包装类：Boolean\\Character\\Byte\\Short\\Integer\\Long\\Float\\Double 15.从Java5.0版开始加入的autoboxing功能能够自动地将primitive主数据类型转换成包装过的对象 16.包装也有一组使用的静态方法 17.‘+’这个操作数是Java中唯一有重载过的运算符 18.数字的格式化：String.format(); 19.“格式化说明”的格式：%[argument number][flags][width][.precision] type 20.format可取用不同数目排列组合的参数—-可变参数列表 21.”%d&lt;%d”中’&lt;’符号是特殊的指示，用来告诉格式化程序重复利用之前用过的参数 22.静态import的使用—-import静态的类 十一、有风险的行为（异常处理）1.异常是一种Exception类型的对象 2.在编写可能会抛出异常的方法时，它们都必须声明有异常 3.编译器会核对每一件事，除了RuntimeExceptions（被称为不检查异常）之外 4.如果程序调用了有声明会抛出异常的方法，就得要告诉编译器已经注意到这件事 5.如果要处理异常状况，就把调用包在try/catch块中，并将异常处理/恢复程序放在catch块中 6.finally：无论如何都要执行的部分 7.finally块可以让你把所有重要的清理程序代码集中在一起 8.如果try或catch块里有return指令，finally还是会执行 9.异常也是多态的，可以用super来处理所有异常并不代表就应该这么做，为每个需要单独处理的异常编写不同的catch块 10.有多个catch块时要从小排到大，catch块不像重载的方法会被挑出最符合的项目。 11.使用catch块时，Java虚拟机只会从头开始往下找到第一个符合范围的异常处理块 12.将异常duck掉只是在本函数不需要处理，总要有函数处理 十二、看图说故事（图形用户接口）1.frame—-pane—widget 2.frame.setDefaultCloseOperation(JFame.EXIT_ON_CLOSE); 作用：在window关闭时把程序结束掉 3.监听接口是介于监听与事件源间的桥梁 4.要显示window，你得指定尺寸和执行显示动作 frame.setSize(300,200); frame.setVisible(true); 5.要对事件源注册就调用事件源的注册方法，它的方式一定是addListener这种形式 6..gif与.jpeg文件可以直接放在组件上 7.多个按钮执行不同工作使用内部类 button.addActionListener(内部类的对象); 内部类实现public void actionPerformed(ActionEvent event) 8.内部类的实例一定会绑在外部类的实例上 十三、运用Swing（swing）1.在Swing中，几乎所有的组件都能够安置其他的组件 2.布局管理器用来控制所关联组件上携带的其他组件 3.不同的布局管理器有不同的策略：BorderLayout\\FlowLayout\\BoxLayout 4.对于BorderLayout分块优先度：南北—东西—中 5.pack()方法会使window的大小符合内涵组件的大小 6.框架默认时使用BoxLayout布局，面板默认使用FiowLayout布局 7.可以调用setLayout()来改变面板的布局管理器 8.JList应用检测值改变加上if测试，ListSelectionEvent lse——if(!lse.getValueIsAdjusting()){} 十四、保存对象（序列化和文件的输入/输出）1.储存数据的两种方式：序列化（类似压缩）与直接文本存入 2.序列化的文件难以让人阅读，但易于让程序阅读（易恢复、安全） 3.Java的输入/输出API带有连接类型的串流，它代表来源与目的地之间的连接，连接串流将串流与其他串流连接起来 4.一般来说，串流要两两连接才能作出有意义的事情—-其中一个表示连接，另一个则是要被调用方法的 5.通过串流连接组合来达到最大的适应性 6.当对象被序列化时，被该对象引用的实例变量也会被序列化，且所有被引用的对象也会被序列化（操作自动进行） 7.如果要让类能够被序列化，就实现Serializable（标记用接口） 8.如果某类是可序列化的，则它的子类也自动地可以序列化 9.如果某实例变量不能或不应该被序列化，就把它标记为transient（瞬时）的 10.当对象被还原且它的父类不可序列化时，父类的构造函数会跟创建新的对象一样地执行，也就是说，从第一个不可序列化的父类开始，全部都会重新初始状态 11.序列化聪明得足以分辨两个对象是否相同 12.解序列化时，新的对象会被配置在堆上，但构造函数不会执行 13.静态变量不会被序列化 14.读取对象的顺序必须与写入的顺序相同 15.Buffered—-缓冲区输入输出flush()清空缓冲区 16.如果没有很小心的设计，nio可能会引发效能损失，非nio的输入输出适合九成以上的应用 17.File对象代表文件的路径而不是文件本身，可以用File对象来创建、浏览和删除目录 18.使用serialVersionUID防止对程序随意修改 十五、网络联机（网络与线程）1.Java的一项好处是传送与接收网络上的数据只不过是链接上使用不同链接串流的输入/输出而已 2.客户端通过socket连接服务器 3.Socket连接的建立代表两台机器之间存有对方的信息，包括网络地址和TCP的端口号（102465535可用，01023都已经被保留给已知的特殊服务） 4.服务器可以使用ServerSocket来等待用户对特定端口的请求 5.当ServerSocket接到请求时，它会做一个Socket连接来接受客户端的请求 6.线程是独立的线程，它代表独立的执行空间 7.Thread是Java中用来表示线程的类 8.要建立线程就得创建Thread 9.建立实现Runnable接口的类对象，用此对象建立Thread对象即可 10.线程状态：新建—可执行—执行—-可执行—（暂时不可执行（sleep()\\locked））—执行—结束（死亡） 11.调度不能保证任何的执行时间和顺序，所以你不能期待它会完全地平均分配执行，你最多也只能影响sleep的最小保证时间 12.并发性问题会引发竞争状态（出现非原子性的问题） 13.使用synchronized这个关键词来修饰方法使它每次只能被单一的线程存取 14.锁不是配在方法上的，而是配在对象上 15.锁住的不是数据而是存取数据的方法 16.可用synchronized来修饰一行或数行的指令而不必整个方法都同步化 17.死锁问题会出现是因为两个线程互相持有对方正在等待的东西 18.可以用setName()来帮助线程命名，通常是用来除错的","path":"2022/01/11/head-first-java-du-shu-bi-ji/","date":"01-11","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"https://jia_k3.gitee.io/blog/tags/Java/"}]},{"title":"Unity应用自带UGUI与EPPlus库制作自制Excel（.xlsx）操作程序","text":"实现步骤： 1.向Unity导入EPPlus相关文件，助力Unity操作Excel文件 2.应用Unity自带UGUI制作基础表格 3.基于前两步制作可存可改Excel信息的表格 一、向Unity中导入EPPlus相关文件 请参考我的另一篇博客：导入EPPlus步骤 二、应用Unity制作基础表格 在学习CSDN的各种博客后，笔者结合自身需求与现有Unity（2021.1.19f1c1）版本给出以下步骤： 首先在场景内新建Canvas，在Canvas内新建一个Panel，在Panel内新建一个Scroll View，在Scroll View-&gt;Viewport-&gt;Content内新建一个空物体，命名随便（下文以row代替），如下图 ​ 然后在Content物体上添加如下组件，设置如图（其中的Spacing可以在最后根据自身情况调整） ​ 然后在上文建立的row（上文中约定的别名，就是那个随便命名的东西）添加组件如下，设置如图（其中的Cell Size与Spacing可以在最后根据自身情况调整） ​ 在row物体下新建至少两个InputField（方便修改Excel内容），方便纠错：），如图（如果你新建的物体没有变成蓝色，请不要担心，灰色才是应有的颜色，下图仅代表结构） ​ 接下来建议将建立的InputField的背景改为透明，可以换上自己的背景，看起来更舒服（调整下图中的Source Image，UIMask为透明背景） ​ 下面用鼠标左键按住row物体拖动到Project视图的存放资源的文件夹中，生成预制体（变蓝），再将row下任一InputField生成预制体 三、新建2个C#脚本：TableCreate.cs myexcel.cs 代码如下： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using OfficeOpenXml; using System.IO; public class TableCreate : MonoBehaviour &amp;#123; public GameObject Row_Prefab; public GameObject Cell_Prefab; private string address; public int Row; public int Col; private myexcel myexcel; private FileInfo fileInfo; private ExcelPackage excelPackage; private void Start() &amp;#123; Row = 1; Col = 1; myexcel = this.GetComponent&lt;myexcel&gt;(); &amp;#125; private void Update() &amp;#123; if(myexcel.isok==true) &amp;#123; fileInfo = myexcel.fileInfo; excelPackage = new ExcelPackage(fileInfo); ExcelWorksheet worksheet = excelPackage.Workbook.Worksheets[1]; IEnumerator a = worksheet.Cells.GetEnumerator(); while (true) &amp;#123; address = (a.Current as ExcelRangeBase).Address; if (address[0] - 'A' + 1 &gt; Col) Col = address[0] - 'A' + 1; int r=0; for(int i = 1;i&lt;address.Length;i++) &amp;#123; r = r * 10 + address[i] - '0'; &amp;#125; if (r &gt; Row) Row = r; if (a.MoveNext()==false) &amp;#123; break; &amp;#125; &amp;#125; Debug.Log(address); Debug.Log(Row); Debug.Log(Col); for (int i = 1; i &lt;= Row; i++) &amp;#123; GameObject table = GameObject.Find(\"Canvas/look_Panel/Scroll View/Viewport/Content\"); GameObject row = GameObject.Instantiate(Row_Prefab, table.transform.position, table.transform.rotation) as GameObject; row.name = \"row\" + i; row.transform.SetParent(table.transform); row.transform.localScale = Vector3.one; if (worksheet.Cells[i , 1].Value != null) row.transform.Find(\"Cell1\").GetComponent&lt;InputField&gt;().text = worksheet.Cells[i , 1].Value.ToString(); if (worksheet.Cells[i , 2].Value != null) row.transform.Find(\"Cell2\").GetComponent&lt;InputField&gt;().text = worksheet.Cells[i , 2].Value.ToString(); if (worksheet.Cells[i , 3].Value != null) row.transform.Find(\"Cell3\").GetComponent&lt;InputField&gt;().text = worksheet.Cells[i , 3].Value.ToString(); for (int j = 4; j &lt;= Col; j++) &amp;#123; GameObject cell = GameObject.Instantiate(Cell_Prefab, row.transform.position, row.transform.rotation) as GameObject; cell.name = \"Cell\" + j; cell.transform.SetParent(row.transform); cell.transform.localScale = Vector3.one; if (worksheet.Cells[i , j ].Value != null) cell.GetComponent&lt;InputField&gt;().text = worksheet.Cells[i , j ].Value.ToString(); &amp;#125; &amp;#125; myexcel.isok = false; &amp;#125; &amp;#125; &amp;#125; using System.Collections; using System.Collections.Generic; using UnityEngine; using OfficeOpenXml; using System.IO; using UnityEngine.UI; public class myexcel : MonoBehaviour &amp;#123; private InputField Input_field; public Button Input_button; public Button Open_button; public InputField Filepath_field; public Text filename_text; public bool isok; public FileInfo fileInfo; private TableCreate tc; private ExcelPackage excelPackage; private string m_Path; private void Awake() &amp;#123; isok = false; tc = this.GetComponent&lt;TableCreate&gt;(); Input_button.interactable = false; Input_button.GetComponent&lt;Button&gt;().onClick.AddListener(Input_button_OnClickDown); Open_button.GetComponent&lt;Button&gt;().onClick.AddListener(Open_button_OnClickDown); &amp;#125; void Input_button_OnClickDown() &amp;#123; using (excelPackage = new ExcelPackage(fileInfo)) &amp;#123; ExcelWorksheet worksheet = excelPackage.Workbook.Worksheets[1]; for(int i=1;i&lt;=tc.Row;i++) &amp;#123; for(int j=1;j&lt;=tc.Col;j++) &amp;#123; Debug.Log(\"Canvas/look_Panel/Scroll View/Viewport/Content/row\" + i.ToString() + \"/Cell\" + j.ToString()); Input_field = GameObject.Find(\"Canvas/look_Panel/Scroll View/Viewport/Content/row\" + i.ToString()+\"/Cell\"+j.ToString()).GetComponent&lt;InputField&gt;(); if (Input_field.text.ToString() != null) worksheet.Cells[i, j].Value = Input_field.text.ToString(); &amp;#125; &amp;#125; excelPackage.Save(); &amp;#125; &amp;#125; void Open_button_OnClickDown() &amp;#123; m_Path = Filepath_field.text;//\"D:/JK/try.xlsx\"; fileInfo = new FileInfo(m_Path); filename_text.text = Filepath_field.text; Input_button.interactable = true; Open_button.interactable = false; isok = true; &amp;#125; &amp;#125; 在Hierarchy视图中最外层新建空物体，将上面两个脚本添加到此物体上，将此物体作为中控器 关于脚本所需外部录入值参考下图： ​ 效果图： ​ 操作先后：首先在输入框填入excel文件绝对路径，点击打开文件按钮，左下图表格出现文件内容，在格子里编辑文本后，点击按钮导入即可保存，最后退出 有可能出现的问题： 1.为啥自己的表没有表头？ 答：我在新建row之上建立了另一个row‘，里面放Text物体，按照row设置即可，并不用设置预制体，但这种表头无法修改，推荐在excel文件表格里输入表头 2.为啥读不到第二张表？ 答：设置的读第一张表，本文只为提供实现参考（技术参考），可以自己控制自己的软件读表，控制 ExcelWorksheet worksheet = excelPackage.Workbook.Worksheets[1]; 里的1为其他数字即可（也可采用名称检索方式） 3.为啥自己的表格颜色不对，字不好看？ 答：设置所有Canvas里的所有物体Source Image即可设置背景，在Text组件设置字体 4.为啥自己添加背景Canvas效果不好？ 答：将背景Canvas设置改为下图，主Canvas不变 ​ 5.为啥自己按上面的结构设置时，有的按钮无法被点击到？ 答：一个Canvas里添加多个Panel时，注意不要让Panel互相遮挡，点击Panel设置大小即可 最后，如若项目有任何问题，欢迎批评指正或讨论。 ​","path":"2022/01/11/unity-ying-yong-zi-dai-ugui-yu-epplus-ku-zhi-zuo-zi-zhi-excel-xlsx-cao-zuo-cheng-xu/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"},{"name":"EPPlus","slug":"EPPlus","permalink":"https://jia_k3.gitee.io/blog/tags/EPPlus/"}]},{"title":"Unity应用EPPlus操作Excel（.xlsx）文件（2021版）","text":"实现步骤： 1.Unity连接VS，参考初学者下载Unity3D以及连接脚本编程软件（VS）教程 2.获取EPPlus.dll并导入Unity 3.代码实现 一、本文实现主要基于VS，所以需要Unity连接VS，参考博客： 初学者下载Unity3D以及连接脚本编程软件（VS）教程 二、在Unity里新建C#文件，双击文件用VS打开（如未采用第一步连接VS，需要导入Epplus.dll文件，如Unity连接VS后在VS做如下步骤后不需要导入Epplus.dll文件） 在VS界面右侧， 右键解决方案，点击管理解决方案的NuGet程序包 ​ 进入以下界面，检索EPPlus（版本笔者这里安装4.*版本可以，最新版报错），如下图安装： ​ 在右侧界面解决方案里选择Assembly-CSharp/Assembly-CSharp.Player点击，进入以下界面，点击EPPlus ​ 打开属性板（一般在解决方案界面下方，也可右键EPPlus打开属性），找到路径 ​ 在文件管理器打开路径，找到EPPlus.dll ​ 在Unity的Project界面新建文件夹Plugins，将EPPlus.dll复制进去 三、在VS打开上面新建的C#文件，编写代码： 添加命名空间引用 using OfficeOpenXml; using System.IO; 打开文件，m_Path是Excel表格文件的路径，这里可以尝试使用using语句（强行释放无用空间），或是自己挨个释放 FileInfo fileInfo = new FileInfo(m_Path); ExcelPackage excelPackage = new ExcelPackage(fileInfo) 编辑文件内容 //获取文件内表，[]从1开始 ExcelWorksheet worksheet = excelPackage.Workbook.Worksheets[1]; //获取元素，第一行第一列元素 //string a11 = worksheet.Cells[1, 1].Value.ToString(); //输入元素，直接赋值 //worksheet.Cells[1, 1].Value = \"222\"; //建立新表操作：打开不存在的表 最后用Debug语句可以查看表内容读取情况：Debug.Log(元素）; 参考资料：【Unity教程】Excel文件的读取和写入 (使用EPPlus)_哔哩哔哩_bilibili 如若项目有任何问题，欢迎批评指正或讨论。 ​","path":"2022/01/11/unity-ying-yong-epplus-cao-zuo-excel-xlsx-wen-jian-2021-ban/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"},{"name":"EPPlus","slug":"EPPlus","permalink":"https://jia_k3.gitee.io/blog/tags/EPPlus/"}]},{"title":"Unity制作简单的精灵图动画","text":"使用精灵图制作动画步骤：1.精灵图准备 2.制作动画 一、精灵图导入与切割第一种情况：导入的是已经切割好的精灵图，请直接跳动到二 第二种情况：导入的是需要切割的精灵图，需要切割，切割步骤： 1按照下图设置导入的图片 ​ 2点击上图中右下角按钮（Sprite Editor)，进入精灵图切割界面，一般只需要自动切割即可 点击切割界面左上角Slice按钮，配置如上图，点击Slice，自动切割后点击切割界面右上角Apply 至此切割完成。 二、制作动画步骤1选择上面精灵图中合适的一张图，拖入Hierarchy界面 2选中1中图片的情况下调出动画编辑界面，如下图（按Ctrl+6同样可以） ​ 3进入动画编辑界面后新建第一个动画，选择储存位置后开始制作动画（或是按照下图新建动画） ​ 点击Create New Clip…即可新建动画 4在精灵图中选择合适的图拖入编辑界面（下图的右侧） ​ 按照合适顺序调整精灵图顺序，动画播放速度不用太考虑，调用动画时可以调整（如下图，下图为调用动画时状态机界面调整示意） 编辑完动画后退出动画编辑界面即可 。 如若项目有任何问题，欢迎批评指正或讨论。 ​","path":"2022/01/11/unity-zhi-zuo-jian-dan-de-jing-ling-tu-dong-hua/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"}]},{"title":"Unity实现多屏分屏效果","text":"Unity版本2021.1.13f1c1 效果： ​ 首先在Hierarchy里要操作的Scene里添加3个Camera，操作4个Camera的Inspector里Camera组件 Inspector.Camera.Viewport Rect属性调整：相机所对应的界面以及对应的（X,Y,W,H） 左下角界面（0，0，0.8，0.8）；左上角界面（0，0.8，0.8，0.2）；右上角界面（0.8，0.8，0.2，0.2）；右下角界面（0.8，0，0.2，0.8） 这里注意所有的Camera的Target Display是同一个，并且与Game界面显示的相同，默认Display1 ​ 效果图是在左上角、右上角、右下角界面放置了分别对应的Canvas 到这里多屏设置完成，要完成示例图的效果请继续…… 具体设置如下： ​ ​ 这里第一张图位于Hierarchy，第二张位于Inspector 其中Text即为信息，Image为背景图，注意顺序 Render Mode选Screen Space - Camera，Render Camera里拖入相对应的Camera Image里可以设置背景图 ​ 在将背景图拖入Source Image 注意事项以及常见问题： 1.关于图片引入，首先将图片复制到Unity项目文件夹Assets对应的文件夹里 2.关于图片无法拖入Source Image，在图片Inspector属性里设置Texture Type为Sprite(2D and UI) 3.关于多页面乱入，如果相机里设置层无效，可以尝试直接暴力托动 ​ 4.关于Canvas对象无法改变位置，设置Render Mode为Screen Space - Camera时Canvas对象无法改变位置，直接改变Camera位置 ​","path":"2022/01/11/unity-shi-xian-duo-ping-fen-ping-xiao-guo/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"}]},{"title":"Unity制作自适应透明背景（PC端）","text":"实现步骤：1.设置MainCamera 2.添加C#脚本 一、设置MainCamera里的Camera组件，以下图为例子​ 关键点在于 ： MainCamera-&gt;Camera-&gt;Clear Flags:Solid Color MainCamera-&gt;Camera-&gt;Background:black 二、新建C#脚本，编写代码如下（HyalineBackground.cs）using UnityEngine; using System; using System.Runtime.InteropServices; //MainCamera-&gt;Camera-&gt;Clear Flags:Solid Color //MainCamera-&gt;Camera-&gt;Background:black public class HyalineBackground : MonoBehaviour &amp;#123; public string strProduct;//项目名称 private int currentX; private int currentY; #region Win函数常量 private struct MARGINS &amp;#123; public int cxLeftWidth; public int cxRightWidth; public int cyTopHeight; public int cyBottomHeight; &amp;#125; [DllImport(\"user32.dll\")] private static extern IntPtr GetActiveWindow(); [DllImport(\"user32.dll\")] static extern IntPtr FindWindow(string lpClassName, string lpWindowName); [DllImport(\"user32.dll\")] static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong); [DllImport(\"user32.dll\")] static extern int GetWindowLong(IntPtr hWnd, int nIndex); [DllImport(\"user32.dll\")] static extern int SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags); [DllImport(\"user32.dll\")] static extern int SetLayeredWindowAttributes(IntPtr hwnd, int crKey, int bAlpha, int dwFlags); [DllImport(\"Dwmapi.dll\")] static extern uint DwmExtendFrameIntoClientArea(IntPtr hWnd, ref MARGINS margins); [DllImport(\"user32.dll\")] private static extern int SetWindowLong(IntPtr hWnd, int nIndex, uint dwNewLong); //private const int WS_POPUP = 0x800000; private const int GWL_EXSTYLE = -20; private const int GWL_STYLE = -16; private const int WS_EX_LAYERED = 0x00080000; private const int WS_BORDER = 0x00800000; private const int WS_CAPTION = 0x00C00000; private const int SWP_SHOWWINDOW = 0x0040; private const int LWA_COLORKEY = 0x00000001; private const int LWA_ALPHA = 0x00000002; private const int WS_EX_TRANSPARENT = 0x20; #endregion IntPtr hwnd; void Awake() &amp;#123; #if UNITY_EDITOR print(\"unity内运行程序\"); #else hwnd = FindWindow(null, strProduct); int intExTemp = GetWindowLong(hwnd, GWL_EXSTYLE); SetWindowLong(hwnd, GWL_EXSTYLE, intExTemp | WS_EX_TRANSPARENT | WS_EX_LAYERED); SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) &amp; ~WS_BORDER &amp; ~WS_CAPTION); currentX = 0; currentY = 0; SetWindowPos(hwnd, -1, currentX, currentY, Screen.currentResolution.width, Screen.currentResolution.height, SWP_SHOWWINDOW); var margins = new MARGINS() &amp;#123; cxLeftWidth = -1 &amp;#125;; DwmExtendFrameIntoClientArea(hwnd, ref margins); #endif &amp;#125; &amp;#125; 在Hierarchy视图新建空物体，添加上面建立的脚本组件即可 三、注意代码设置效果无法体现在编译器模式，将代码打包查看效果注意Player Setting-&gt;Resolution and Presentation-&gt;Standalone Player Options-&gt;Use DXGI Filp Model Swapchain for D3D1为false ​ 此文参考过多篇博客，可以说取其精华，实验过许多次 最后，如若项目有任何问题，欢迎批评指正或讨论。 ​","path":"2022/01/11/unity-zhi-zuo-zi-gua-ying-tou-ming-bei-jing-pc-duan/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"}]},{"title":"初学者下载Unity3D以及连接脚本编程软件（VS）教程","text":"本文可以解决除Unity下载的一个问题：新建C#脚本文件打开为杂项文件不可编译 首先下载Unity Hub安装包Unity Store - 下载 这是类似社区的软件，里面可以获取一些优秀资源，这里我们应用这个下载Unity。 ​ 在最后一栏“安装”的右边，可以找到安装按钮，选择版本以及附带组件即可安装，建议选择下载VS的选项，这样我们就可以直接将所有软件下载好，如果已经有VS了，可以不选VS选项，后面会提到VS配置。 安装好Unity后，在UnityHub新建项目打开Unity，在Unity最上面工具栏选择Edit中的Preferences选项，在External Tools中External Script Editor里选择VS，这里注意安装VS时要选上Unity对应组件，如果已经安装好VS，重新打开安装软件，选择已安装版本右上角“修改”，选择Unity开发组件添加即可，在Unity安装之前已经安装好VS的同此方法添加Unity组件即可。 现在在Unity里新建一个C#脚本（Project界面左上角+处），双击打开，若VS显示并不是杂项文件即成功。在这里，如果打开脚本文件显示为杂项文件要先检查上面提到的External Script Editor是否已经修改为VS，再检查是否VS已安装上面提到的Unity开发需要的插件，最后打开建立的Unity项目文件中.sln文件，找到新建的脚本文件，不是杂项文件，且可编译。 ​","path":"2022/01/11/chu-xue-zhe-xia-zai-unity3d-yi-ji-lian-jie-jiao-ben-bian-cheng-ruan-jian-vs-jiao-cheng/","date":"01-11","excerpt":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"VS","slug":"VS","permalink":"https://jia_k3.gitee.io/blog/tags/VS/"}]},{"title":"QT与MYSQL（64位）数据库的连接方法","text":"首先打开一个QT项目，在.pro里输入下图代码 ​ 然后在main.cpp文件就可以引用头文件如下图 ​ 在**.ui文件**中添加一个QLabel 在其对应**.h文件**中添加自定义函数void show1(void);这里注意.h文件并不是ui_**.h 在其对应**.cpp文件**添加如下代码 ​ 其中的test\\jk\\123456分别对应连接数据库名称、数据库user名称（初始为root)、user的密码 点击运行 如果界面上Label显示1，则恭喜你连接成功！！ 如果报错没有MYSQL驱动的话，在MYSQL文件夹里lib文件夹下找到下图文件 ​ 复制到QT的bin文件下，重启QT，打开项目，点击运行，主界面显示1，则恭喜你成功了！！ 如果还不成功，显示无MYSQL驱动，而在这行下一行又提示MYSQL驱动存在，请检查MYSQL的位数，应该是64位，而我们的QT一般是32位的，接下来我们要使QT可以与MYSQL 连接的话，有两个办法： 1.重新下载32位MYSQL 2.通过操作应用QT64位编译器（VS），也可以直接在VS编程，接下开讲解如何在QT采用64位编程 首先在VS上找到QT扩展，并下载，或者通过其他渠道下载 只需在QT新建文件时有如图选项 ​ 新建一个勾选上个选项的QT文件，然后开始下一步配置 ​ ​ ​ 有困难的可能在Debugger这里，要下载Windows Kits Windows 10 SDK - Windows 应用开发 (microsoft.com) 下载后安装时勾选Debugger选项 QT应该会自己感应到，可以重启QT尝试（要么就手动配置） 应用上图选项后点击运行，可能会报错 ‘nullptr’ is incompatible with C++98 按照下图配置 ​ 点击运行应该行了 最后提醒：新建项目选择VS编译器（64位），其他选项修改完成后单击OK，可以重新进入查看修改是否完成。 ​","path":"2022/01/11/qt-yu-mysql-64-wei-shu-ju-ku-de-lian-jie-fang-fa/","date":"01-11","excerpt":"","tags":[{"name":"QT","slug":"QT","permalink":"https://jia_k3.gitee.io/blog/tags/QT/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://jia_k3.gitee.io/blog/tags/MYSQL/"}]},{"title":"QT程序打包方法","text":"要想使自己的QT程序可以在其他电脑上运行，要学会打包 首先，打开要打包的项目，在右下角 ​ 选择release，点击运行 找到生成的对应的release文件夹，找到对应的.exe文件，复制到你一个新建的文件夹，用来储存打包后的文件，然后找到编译器对应的命令行程序 ​ 编译器可以在前面找文件时发现 ​ 进入命令行程序，cd到前面提到的存放.exe的文件夹目录 具体命令行代码： 1.cd到另一个盘，要先加上D：回车，然后如2 2.输入：cd (文件夹目录）回车 最后输入windeployqt name.exe name替换为自己的.exe文件名称即可，点击回车，等到下一个可输入行推出就行了 ​","path":"2022/01/11/qt-cheng-xu-da-bao-fang-fa/","date":"01-11","excerpt":"","tags":[{"name":"程序打包","slug":"程序打包","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"}]},{"title":"QT:Tab Widget的简单使用","text":"一、QT的UI设计界面中Tab Widget可进行的图形界面操作1.添加、删除Tab1.1添加Tab​ 1.2删除Tab 2.每个Tab的属性修改2.1名字等基本属性修改​ 2.2修改Tab标签大小2.2.0修改Tab标签名称，Tab标签大小自动适应 二、QT的程序编辑界面中Tab Widget可进行的代码操作1.通过QT自带帮助文档找到可进行的操作​ 2.常用属性2.1count2.1.0描述Tab页的数量 2.2currentIndex 2.2.0描述正在展示Tab页的序号 ​ 3.常用函数3.1addTab3.1.0添加Tab页（界面，Tab图标，Tab名字） ​ 3.2insertTab3.2.0向指定位置插入Tab页（插入位置，界面，Tab界面，Tab名字） ​ 3.3removeTab3.3.0删除指定Tab页（Tab页序号） ​ 3.4currentIndex3.4.0输出正在显示Tab页的序号 ​ 3.5setCurrentIndex3.5.0将指定序号的Tab页显示（Tab页序号） 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/01/11/qt-tab-widget-de-jian-dan-shi-yong/","date":"01-11","excerpt":"","tags":[{"name":"QT组件","slug":"QT组件","permalink":"https://jia_k3.gitee.io/blog/tags/QT%E7%BB%84%E4%BB%B6/"}]},{"title":"串的模式匹配KMP算法","text":"​ 1.起源：由于串的模式匹配的简单算法的时间复杂度不稳定，结合串匹配时指针的移动规律，出现KMP算法 2.与简单匹配的区别：匹配比较字符不同时，KMP算法的主串指针不回溯，模式串向后移动到最佳移动位置，KMP算法的时间复杂度稳定：O(m+n)（其中m、n分别为主串和模式串的长度） 3.KMP主要思想：相当于使模式串与主串在匹配的过程中对比较过程拥有类似记忆功能，使比较字符错误指针回溯时，不需要直接回到模式串第一个元素，而是根据模式串已经匹配正确字符的性质找到指针回溯最佳位置，从而减少不必要操作，节省匹配时间 4.get_next主要思想：每个字符对应的next值都可以表示该字符前 “同后缀字符串相同的前缀字符串最后一个字符所在的位置”，求next值时，通过前面字符的比较来确定后面字符对应的next值 5.get_next函数代码： void get_next(string a, int next[]) { next[0] = -1; for (int i = 0, j = -1; i &lt; a.length();) { if (j == -1||a[i]==a[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } } 6.KMP函数代码： void KMP(string a, string b,int next[],int result[])//next数组和需要其他处理的运算结果result数组 { result[0] = 0; result[2] = 0; for (int i = 0, j = 0; i &lt; a.length() &amp;&amp; (j &lt; b.length()||j==-1);)//-1与string的length()比较结果为-1&gt;b.length(),考虑补码比较，b.length()为无符号整数小于-1的补码 { if (j == -1 || a[i] == b[j]) { i++; j++; } else { if (j &gt; result[2]) { result[2] = j; result[1] = i - j; } j = next[j]; } if (j == b.length()) { result[0] = 1; result[1] = i - j; result[2] = j; } } } 7.优化get_next函数思想：若next指代相邻两个字符相同时，将模式串指针调到按照之前next值处将毫无意义（结合next值思想可知若按照前面的get_next函数，两个相邻字符相同将导致下一次比较必定错误（相同字符换位置比较都错误）） 8.优化版get_next函数代码： void get_next(string a, int next[]) { next[0] = -1; for (int i = 0, j = -1; i &lt; a.length();) { if (j == -1||a[i]==a[j]) { i++; j++; next[i] = j; if (a[i] != a[j]) { next[i] = j; } else { next[i] = next[j]; } } else { j = next[j]; } } } 9.实例代码：找到abedabcdabcee串里abcdabcf串匹配最多字符数以及最多匹配开始字符序号 #include using namespace std; void get_next(string a, int next[]) { next[0] = -1; for (int i = 0, j = -1; i &lt; a.length();) { if (j == -1||a[i]==a[j]) { i++; j++; next[i] = j; if (a[i] != a[j]) { next[i] = j; } else { next[i] = next[j]; } } else { j = next[j]; } } } void KMP(string a, string b,int next[],int result[]) { result[0] = 0; result[2] = 0; for (int i = 0, j = 0; i &lt; a.length() &amp;&amp; (j &lt; b.length()||j==-1);)//-1与string的length()比较结果为-1&gt;b.length(),考虑补码比较，b.length()为无符号整数小于-1的补码 { if (j == -1 || a[i] == b[j]) { i++; j++; } else { if (j &gt; result[2]) { result[2] = j; result[1] = i - j; } j = next[j]; } if (j == b.length()) { result[0] = 1; result[1] = i - j; result[2] = j; } } } int main() { string a = \"abedabcdabcee\"; string b = \"abcdabcf\"; int next[256]; int result[20]; get_next(b, next); KMP(a, b, next, result); cout &lt;&lt; result[1]&lt;","path":"2022/01/11/chuan-de-mo-shi-pi-pei-kmp-suan-fa/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"图的遍历---深度优先搜索+广度优先搜索","text":"一、深度优先搜索1.基本思想1.1首先访问图中某一个顶点A，并且以该顶点为出发点 1.2任选一个与顶点A邻接的未被访问的顶点B，访问B 1.3以B为新的出发点（新的A）继续进行深度优先搜索，直至图的所有顶点都被访问到 2.算法分析2.1对于非连通图也可遍历到，需要在深度优先搜索的执行函数用循环访问未被访问顶点 2.2（对于有n个顶点，e条边的图）邻接矩阵遍历时间O(n^2)，邻接表遍历时间O(n+e) 3.算法应用3.1求深度优先生成树 3.2判断图是否连通 3.3求图的连通分量 二、广度优先搜索1.算法思想1.0类似树的按层次遍历 1.1首先找到图中的一个顶点A 1.2然后依次访问顶点A的所有邻接点B\\C\\D\\\\\\（入队列） 1.3再依次以BCD为顶点，访问未访问邻接点，直至所有顶点都被访问到（循环条件—队列非空） 2.算法分析2.1可以应对非连通图（for循环内嵌套while循环，for循环保证所有顶点都被遍历，while循环保证邻接顶点都被遍历到） 2.2（对于n个顶点，e条边的图）邻接矩阵时间代价O(n^2)，邻接表时间代价O(n+e) 3.算法应用3.1求广度优先生成树 3.2判断图是否连续 3.3求图的连通分量 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/11/tu-de-bian-li-shen-du-you-xian-sou-suo-guang-du-you-xian-sou-suo/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最小生成树---Prim算法与Kruskal算法","text":"一、概念1.最小生成树：边带权图（网）的所有生成树中，各边权值总和最小的生成树称作最小生成树 2.普里姆（Prim）\\克鲁斯卡尔（Kruskal） 二、Prim算法0.G=(V,E)为连通网，用T来记录G上最小生成树边的集合 1.算法开始，U={G里的一个初始点}，T为空 2.找到两个端点分别在U和V-U内的最小权值边，将其加入T，同时将边的另一个点纳入U 3.循环执行2直至U=V 4.分析：时间复杂度O(n^2)，空间复杂度O(n) 三、Kruskal算法0.G=(V,E)为连通网，用T来记录G上最小生成树边的集合 1.从G中取最短边e，判断e的端点是否位于T的不同连通分量上，若是，则将e加入T，从G删除e 2.循环执行1.直至T中有n-1条边 四、Prim与Kruskal比较 算法 Prim Kruskal 时间复杂度 O(n^2) O(eloge) 适应范围 稠密图 稀疏图 Kruskal算法需要对边进行按权重排序，e条边排序最优时间复杂度为O(eloge) 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/11/zui-xiao-sheng-cheng-shu-prim-suan-fa-yu-kruskal-suan-fa/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"有向无环图的应用","text":"一、概念1.DAG图：无环的有向图称作有向无环图 2.AOV网（顶点活动网）：将顶点表示活动，边表示活动之间的关系的网称为顶点活动网 3.拓扑序列：把AOV网中所有顶点排成一个线性序列，且该序列满足如下条件：若AOV网中存在从A到B的路径，则此序列中A必须在B之前 4.拓扑排序：构造AOV网的拓扑序列的操作被称为拓扑排序 5.AOE网：带权有向图，顶点表示事件，边表示活动，权表示活动持续的时间 6.AOE网特点： 6.1表示实际工程计划的AOE网是无环的 6.2只有一个入度为0的顶点，用来表示整个活动开始：源点 6.3只有一个出度为0的顶点，用来表示整个活动结束：汇点 6.4整个工程所需要的时间是从源点到汇点的最长路径长度（最短时间保证工程必须做完） 6.5最长路径上的活动是影响工程进度的关键 7.关键路径：（长度最长的路径）在AOE网中，有些活动可以同时进行，完成一个工程所需的最短时间是从源点到汇点的最长路径长度 8.关键活动（边）：关键路径上的活动（延长必定影响活动，缩短不一定能缩短工期）（最早发生时间与最迟发生时间相等） 9.事件（点）的最早发生时间与最迟发生时间： 9.1事件A的最早发生时间是从源点到A的最长路径长度 9.2事件A的最迟发生时间是汇点的最早发生时间减去汇点到A的最长路径长度 10.活动（边）的最早开始时间与最迟开始时间 10.1活动&lt;A,B&gt;的最早开始时间是A的最早发生时间 10.2活动&lt;A,B&gt;的最迟开始时间为B的最迟发生时间减去&lt;A,B&gt;的持续时间 二、拓扑排序算法1.拓扑排序特点： 1.1一个有向图的拓扑序列不一定唯一 1.2有向无环图一定存在拓扑序列 1.3有向有环图不存在拓扑序列 1.4通过构造拓扑序列，可判定AOV网是否存在环 2.基本思想： 2.1在有向图中选出一个入度为0的顶点输出（入栈） 2.2从图中删除该顶点以及它所有的出边（出栈操作） 2.3重复执行2.1和2.2，直至全部顶点均已输出，或者图中剩余顶点的入度均不为0（有环） 3.算法分析：邻接表时间复杂度为O(n+e)，邻接矩阵时间复杂度为O(n^2) 三、关键路径算法1.求关键活动算法基本思想： 1.1求每个事件的最早发生时间与最晚发生时间 1.2根据每个事件的最早发生时间和最晚发生时间求得每个活动得最早开始时间与最迟开始时间 1.3找到最早开始时间与最迟开始时间相等的活动—关键活动 1.4关键路径算法分析：邻接表时间复杂度O(n+e)，邻接矩阵时间复杂度O(n^2) 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/11/you-xiang-wu-huan-tu-de-ying-yong/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"浅谈哈夫曼树与哈夫曼编码","text":"一、最优树的定义1.结点的路径长度：从根结点到该结点的路径上分支的数目 2.树的路径长度：树中每个结点的路径长度之和 3.树的带权路径长度：树中所有叶子结点的带权路径长度之和 4.最优树：在所有含有n个叶子节点、并带相同权值的m叉树中，必存在一棵其带权路径取最小值的树 二、如何构造最优树（赫夫曼算法-二叉树版）1.根据给定的n个权值，构造一个以每个关键字为根结点的集合G，并且它们的左右子树均为空树 2.在G中找到权值最小的两颗二叉树，分别作为左右子树构造一棵新的二叉树，并且使这颗二叉树根结点权值为左右子树之和 3.从G中删除前面用到的两颗树，同时加入刚生成的新树 4.重复2.3两步，直至G中只包含一棵树为止 三、前缀编码1.概念：（在有效字符前加的通用型代码）任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀 2.应用：利用赫夫曼树可以构造一种不等长的二进制编码，并且构造所得的赫夫曼编码是一种最优前缀编码，即使所传电文的总长度最短 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/11/qian-tan-ha-fu-man-shu-yu-ha-fu-man-bian-ma/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构---内部排序","text":"一、概述1.排序算法的稳定与不稳定1.1稳定：在排序前后，含相等关键字的记录的相对位置保持不变 1.2不稳定：相等关键字的记录的相对位置有可能改变 2.内部排序和外部排序2.1内部排序：在排序过程中，只使用计算机的内存存放待排序记录 2.2排序期间文件的全部记录不能同时存放在计算机内存中，要借助计算机的外存才能完成排序 2.3内外存之间的数据交换次数是影响外部排序速度的主要因素 3.排序方法的效率分析3.1时间复杂度：关键字的比较次数和记录移动次数 3.2空间复杂度：执行算法所需的附加储存空间 3.3稳定算法和不稳定算法 二、插入排序1.直接插入排序1.1直接插入排序从第二个记录开始（第一个记录为空、监视哨） 1.2直接插入排序第i趟后序列的前i+1个记录是有序的（每一趟都让后面的一个元素排序到前面构成新的有序序列） 1.3插入排序的思想： 1.3.1第一个记录是有序的 1.3.2从第二个记录开始，按关键字的大小将每个记录插入到已排好序的序列中 1.3.3一直进行到第n个记录 1.3.4整个排序过程需要进行比较、后移记录、插入适当位置。从第二个记录到第n个记录共需n-1趟 1.4直接插入排序原序列呈正序排列时，最省时间（相对的：原序列为反序时最费时间） 1.5直接插入排序是最稳定的排序方法 1.6时间复杂度：平均O(n^2)；空间复杂度：O(1) 1.6.0时间复杂度：最好情况:比较O(n),移动O(1);最坏情况:比较O(n2),移动O(n2);平均O(n2) 2.折半插入2.1在直接插入排序进行第i个元素时，利用折半查找找到插入的位置 2.2折半插入排序是稳定的排序方法 2.3时间复杂度：O(n^2)；空间复杂度：O(1) 2.3.0时间复杂度：最好情况:比较O(n),移动O(1);最坏情况:比较O(log2(n!)),移动O(n^2);平均O(n^2) 3.希尔排序3.1希尔排序的思想 3.1.1对待排记录序列先作“宏观”调整，再作“微观”调整 3.1.2“宏观”调整：“跳跃式”插入排序 3.2希尔排序概述 3.2.1将记录序列分成若干子序列，分别对每个子序列进行插入排序（将n个记录分为d个子序列） 3.2.2d为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为1 3.3在增量为d时，希尔排序从d+1个排序开始 3.4希尔排序的最终增量为1（直接插入排序） 3.5希尔排序是不稳定得排序方法 3.6希尔排序得时间复杂度：平均O(n^1.3)到平均O(n^1.5) 3.7希尔排序得空间复杂度：O(1) 三、快速排序1.冒泡排序1.1冒泡排序一趟后最大元素沉底，最大元素位于它最终的位置上，总共需要n-1趟 1.2基本思想：从第一个记录开始，两两比较交换，一趟比较结果后，关键字最大的记录放到最后一个位置，最小的则上浮一个位置（n个记录比较n-1遍）（如果某趟后序列没有变化，就表示已经排好了） 1.3.1冒泡排序的结束条件为：最后一趟没有进行“交换记录” 1.3.2一般情况下，每经过一趟“冒泡”，“i减1”，但并不是每趟都这样 1.4冒泡排序是稳定的排序方法 1.5时间复杂度：最好情况：比较O(n), 移动O(1)最坏情况：比较O(n2), 移动O(n2)平均情况：O(n2) 1.6空间复杂性O(1) 2.快速排序2.1基本思想：（分治算法）找一个记录，以它的关键字作为“枢轴”，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后，将序列划分：（小）枢轴（大） 2.2快排一趟后序列特征：存在一个元素，元素左边元素的关键字不大于它的关键字，它右边元素的关键字不小于它的关键字 2.3快速排序是不稳定的排序方法 2.4时间复杂度：最坏O(n^2);最好O(nlog2(n));平均O(nlog2(n)) 2.5快速排序是所有同量级O(nlogn)的排序方法中，平均性能最好的方法 2.6快速排序的改进：进行一次划分之前，将左端与有右端与中间的关键字相比，拿三者的中间值做枢轴 四、选择排序1.简单选择排序1.1基本思想： 1.1.1第一次从n个关键字中选择一个最小值，从而确定第一个元素 1.1.2第二次再从剩余元素中选择一个最小值，确定第二个元素 1.1.3共需n-1次选择 1.2每次简单选择排序后将有一个最小元素排到最前面 1.3关键字间的比较次数总计为n(n-1)/2 1.4移动记录的次数：最小值为0，最大值为3(n-1) 1.5简单选择排序方法是不稳定的 1.6时间复杂度：比较O(n^2)，移动最好O(1)，最差O(n) 1.7空间复杂度：O(1) 2.树形选择排序2.1又称锦标赛排序，是一种按照锦标赛的思想进行选择排序的方法 2.2首先对n个记录的关键字进行两两比较，然后递归比较前一步查找的[n/2](上取整)个关键字，如此重复直至选出最值关键字 2.3整个过程可以用n结点的完全二叉树表示 2.4排序算法时间复杂度：O(nlog(n)) 3.堆排序3.1堆排序属于选择排序：出发点是利用选择排序已经发生过的比较，记住比较的结果，减少重复比较的次数 3.2堆的定义：n个元素的关键字序列R[1].key,R[2].key,…,R[n].key，当且仅当满足下述关系时，称之为堆。 3.2.1R[i].key≤R[2*i].key且R[i].key≤R[2*i+1].key：小根堆 3.2.2R[i].key≥R[2*i].key且R[i].key≥R[2*i+1].key：大根堆（根结点的关键字最大） 3.3堆排序思想： 3.3.1由一个无序序列建成一个堆 3.3.2在输出堆顶元素后，调整剩余元素成为一个新的堆 3.4算法概要（大根堆）： 3.4.1按关键字建立大根堆 3.4.2输出堆顶元素，采用堆顶元素与最后一个元素交换，最大元素得到正确位置 3.4.3对此时的前n-1个元素重新建堆 3.4.4循环执行2.4.2与2.4.3，知到排序完成 3.5建堆算法： 3.5.1先根据下标建立完全二叉树 3.5.2从最后一个非叶子结点开始建堆（n个结点，最后一个非叶子结点的下标为[n/2]，将其与子结点比大小，不符合大小时，先横比，再纵比确定被取代结点的插入位置，逐渐向上一个非叶子结点转移比较[n/2]—&gt;[(n-1)/2]—&gt;……） 3.6堆排序是不稳定的排序 3.7时间复杂度为O(nlog(n))；最坏情况：O(nlog2(n)) 3.8空间复杂度为O(1) 五、归并排序1.归并的定义1.1归并又叫合并，是指把两个或两个以上的有序序列合并成一个有序序列 1.2（根据比较循环的循环条件判断循环最多循环m+n-1次i&lt;=m&amp;&amp;j&lt;=n）将两个长度分别为n、m的递增有序序列归并为一个有序顺序表，元素最多的比较次数为m+n-1 2.（2路）归并排序思想2.1将顺序表分n份分别进行递归排序（循环分割直到最后每个表仅剩一个元素） 2.2将n个记录进行2路归并排序的时间复杂度为O(nlog2(n)) 2.3每一趟归并的时间复杂度为O(n)，总共需进行[log2(n)]上取整 2.4归并排序是稳定的排序方法 2.5空间复杂度为O(n) 3.K-路归并3.1K路归并排序共需要logk(n)趟 3.2K路归并的时间复杂度为nlogk(n) 六、基数排序1.基数排序的起源1.1基数排序起源于箱（桶）排序，设置若干个箱子，依次扫描待排序的记录,A[1],A[2],…,A[n],把关键字为k的记录放在第k个箱子里,按序号将非空的箱子里的记录收集起来 1.2箱排序的缺点：如果关键字位数太大，这样做空间复杂度和时间复杂度都太大 2.链式基数排序2.1待排序记录以指针相链，构成一个链表 2.2“分配”时，按当前“关键字位”所取值，将记录分配到不同的“链队列”中，每个队列中记录的“关键字位”相同 2.3“收集”时，按当前关键字位取值从小到大将各队列首尾相链成一个链表 2.4对每个关键字位均重复2.2 和2.3 两步 2.5基数排序需要的分配与收集次数为最大关键字的位数 2.6排序概要：（先根据个位分开收集，位数逐渐上升，没有实质性的元素间的比较最终却可以排序完成） 2.6.1设待排记录A的关键字最大是figure位的正整数 2.6.2从最低位(个位)开始，扫描关键字的pass位,把等于0的插入Q[0],…,等于9的插入Q[9] 2.6.3将Q[0]~Q[9]中的数据依次收集到A[]中 2.6.4pass+1直到figure，重复执行1，2两步 3.算法分析3.1基数排序是稳定的 3.2空间复杂度与时间复杂度均为O(n) 七、内部排序方法的比较​ 本笔记除了自己的一些理解外，参考《数据结构》，图片出自网络与课程ppt，如有侵权，请联系笔者删除。 最后希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/01/11/shu-ju-jie-gou-nei-bu-pai-xu/","date":"01-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构---查找","text":"一、相关概念1.查找表：由同一类型的数据元素构成的集合 2.静态查找表：仅用于查询和检索操作的查找表 3.动态查找表：在查找时包含插入、删除或修改 4.主关键字：可以唯一的识别一个记录的数据项 5.次关键字：关联若干项记录的数据项 6.查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素 7.查找成功：查找表中存在满足条件的记录 8.查找失败：查找表中不存在满足条件的记录 二、静态查找表1.顺序表的查找1.1顺序查找的思想 1.1.1从查找表的第一个元素向后（或者从最后一个元素向前），比较当前位置数据元素的关键字与查找关键字（考虑主关键字和次关键字） 1.1.2若相等，输出当前位置，查找成功；若不相等，走向下一个位置 1.1.3循环执行以上两步，直到查找成功或超出范围（查找失败） 1.2顺序查找提供监视哨的作用：在顺序查找时省略了下标的越界检查，提高效率（其中监视哨位置在数组首位【0】） 1.3顺序表查找的平均查找长度为（n+1）/2 2.有序表的查找2.1折半查找的前提要求是顺序存储并且有序 2.2折半查找的思想： 2.2.1将要查找的关键字与查找表中间的元素的关键字进行比较。 2.2.2若相等，返回当前位置；若查找关键字比当前位置关键字小，向前递归，否则向后递归。 2.3复杂度：O(log2(n)) 2.3平均查找长度：(n=2^h-1) ​ 2.4n个节点的用于折半查找的判定树，表示查找失败的外部节点共有n+1个 2.4.1n0+n1+n2=n;2n0+n1=n+1 2.4.2外部节点：只有一个后继的节点和无后继节点缺少的后继节点：2n0+n1 3.索引顺序表的查找​ 3.1索引顺序表的储存要求： 3.1.1线性表要求：查找表分为n块，当i&gt;j时，第i块中的最小元素的关键字大于第j块中的最大元素的关键字 3.1.2索引表的要求：索引表是顺序储存；索引表里储存了各个块最大值和开始地址 3.2索引顺序表的查找思想： 3.2.1首先确定所要查找关键字在哪一块中 3.2.2在所确定的块中用顺序查找查找关键字 3.3如果索引表长度为b，每块平均长度为L，则索引查找的平均查找长度为(b+1)/2+(L+1)/2 3.4长度为n的线性表，分成（根号n）块平均查找次数最少 三、动态查找表1.二叉排序树和平衡二叉树1.1二叉排序数的定义：二叉排序树或者是一颗空树，或者是具有下列性质的二叉树： 1.1.1若根结点有左子树，则左子树上所有结点关键字的值均小于根结点关键字的值 1.1.2若根结点有右子树，则右子树上所有结点关键字的值均大于根结点关键字的值 1.1.3根结点的左、右子树也分别为二叉排序树 1.2二叉排序树的查找思想 1.2.1当二叉排序树不空时，先将给定值和根结点的关键字比较，若相等，则查找成功；否则： 1.2.2若给定值小于根结点的关键字，则在左子树上继续查找； 1.2.3若给定值大于根结点的关键字，则在右子树上继续查找； 1.2.4循环查找，直到查找成功或查找失败（遇到空结点） 1.3二叉排序树的平均查找长度仍然是O(log2(n)) 1.4二叉排序树的结点插入： 1.4.1若二叉树为空：插入结点作为根结点； 1.4.2若二叉树非空：将待插入结点关键字与根节点比较： 1.4.2.2若相等，则无需插入； 1.4.2.2若小于根节点，插入左子树； 1.4.2.3若大于根节点，插入右子树 1.4.3注意查找插入位置时： 1.4.3.1函数要实时记录查找路径上的最后一个结点（插入位置） 1.4.3.2函数要实时记录查找结点的父结点 1.4.3.3解释：查找位置确定的标志有两个（找到了相同的元素、没找到相同的元素（记录待插入结点的父结点）） 1.4.4查找插入位置函数有三种返回类型： 1.4.4.1返回真：找到元素，无需插入 1.4.4.2返回假：空树插入 1.4.4.2返回假：根据返回结点确定插入左右 1.4.5二叉排序树的插入算法的平均时间复杂度为O(log2(n)) 1.5二叉排序树的结点删除 1.5.1定义：删除一个结点，要求删除结点后，仍保持二叉排序树的结构特点不变 1.5.2若删除结点为叶结点：删除结点，改变父结点指针 1.5.3若删除结点只有左子树：删除结点，结点的左子树顶替原结点位置 1.5.4若删除结点只有右子树：删除结点，结点的右子树顶替原结点位置 1.5.5若删除结点左右子树都有： 1.5.5.1将左子树作为右子树中最小结点的左子树（或者将右子树作为左子树中最大结点的右子树），顶替原结点位置（缺点是增加了树的高度） 1.5.5.2用左子树最大元素顶替删除结点位置（或者用右子树最小元素顶替原结点位置） 1.5.6删除算法的平均时间复杂度为O(log2(n)) 1.6平衡二叉树（AVL树）的构建 1.6.1定义：（空树或者）所有结点的左子树和右子树的高度差的绝对值不超过1 1.6.2平衡因子（左子树高度-右子树高度）：-1、0、1 1.6.3因插入右子树的右子树导致不平衡而调整：RR旋转（实质上向左旋转） ​ 1.6.4因插入左子树的左子树导致不平衡而调整：LL旋转（实质上向右旋转） 1.6.5因插入左子树的右子树导致不平衡而调整：LR旋转（实质上先左旋再右旋） 1.6.6因插入右子树的左子树导致不平衡而调整：RL旋转（实质上先右旋再左旋） 1.6.7平衡二叉树的构造思想： 1.6.7.0最小不平衡子树：以离插入结点最近，且平衡因子绝对值大于1的结点作为根结点的子树 1.6.7.1每插入一个新结点，首先检查是否破坏树的平衡性 1.6.7.2若破坏了平衡性：找到最小不平衡子树，调整子树（保持二叉排序树特性的前提下） 2.B-树和B+树（索引作用）2.1B-树的定义（一种平衡的多路查找树）：空树或满足以下性质的m叉树： 2.1.1树中每个结点至多有m颗子树 2.1.2若根结点不是叶子结点，则至少有两颗子树 2.1.3除根结点外的所有非终端结点至少含有[m/2](上取整)棵子树 2.1.4所有的非终端结点中包含信息：（n,A,K,A1,K1,,,,,An,Kn） 2.1.4.1其中K为关键字，且从小到大排列 2.1.4.2A为指向子树的指针，每颗子树上的值都小于子树指针后面的K，大于指针前面的K 2.1.4.3n为关键字数量 2.1.4.4实际上还要有指向关键字的记录的指针（数据主要存在与记录里，B-树只是索引） 2.1.5所有的叶子结点都出现在同一层次上，并且不带信息（类似外部结点或者查找失败的结点，实际上这些结点不存在，指向它们的指针为空） 2.2B-树类似于索引顺序表与二叉排序树的结合 2.3B-树主要用作文件的索引 2.4在B-树中查找的主要思想： 2.4.1在指针所指结点的关键字序列中查找Ki&lt;=s&lt;K(i+1) 2.4.2若Ki!=s，去Ki后的指针所指树里找 2.4.3循环执行2.4.1与2.4.2直到找到或未找到（可以返回应插入点信息） 2.5B-树结点插入（m表示树阶数，即结点最多子树数）： 2.5.1结点关键字个数必须大于[m/2](上取整)-1，插入结点时先在最底层的某个非终结结点插入关键字 2.5.2若此次插入后结点关键字数目&lt;=m-1，插入成功 2.5.3若插入后结点关键字数目&gt;m-1，进行如下拆分 2.5.4拆分为两个结点：[m/2](上取整)-1与m-[m/2](上取整)个结点，将关键字K[m/2]和新建结点指针插入到父结点 2.6B-树结点删除：（[m/2]均为上取整） 2.6.1若删除关键字在非终端结点，使之与其后的子树中最小值交换，递归到删除子树最小值结点 2.6.2若删除关键字结点在终端结点，若删除后结点关键字数目不少于[m/2]，则删除完成。否则： 2.6.2.1若删后结点关键字数目为[m/2]-1，则将结点指针所在父结点的左（或右关键字）（转移关键字前需要判断兄弟结点关键字数目大于[m/2]-1）转移下来凑够[m/2]个关键字，将对应相邻兄弟结点的最大（或最小结点）（根据前面转移的关键字与刚凑够数的结点的相对位置确定）补到已经被转移位置的关键字位置 2.6.2.2若被删结点关键字数目与兄弟结点关键字数目均等于[m/2]-1，两个结点和结点之间的父结点关键字一起合并为一个新结点 2.7B+树的定义（m阶B-与m阶B+的区别）：（一种B-树的变型树） 2.7.1有n颗子树的结点中含有n个关键字 2.7.2所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依照关键字从大到小顺序排序 2.7.3所有非终端结点可以看成索引部分，结点中仅含有其子树（根结点）中的最大或最小关键字 2.8B+树的查找：类似B-树查找，但若查找到的结点不为终端结点，则继续向下直到叶子结点 2.9B+树的插入： 2.9.1插入仅在叶子结点上进行 2.9.2当结点中关键字数目大于m时，分裂的两个结点所含关键字数目为[(m+1)/2]、[(m+1)/2] 2.9.3拆分后的结点的双亲结点必须同时包含这两个结点的最大关键字 2.10B+树的删除： 2.10.1尽在叶子结点进行 2.10.2当叶子结点的最大关键字被删除时，其在非终端结点可以作为一个“分界关键字”存在 2.10.3若因删除而使结点中关键字数目少于[m/2]，和兄弟结点结合（同B-树） 三、哈希表1.哈希表定义1.1哈希表的思想：以结点的关键字K为自变量，通过一个确定的函数关系H，计算出对应的函数值H(K)，把这个函数值作为结点的储存地址（储存时和查找时直接到该地址—散列法） 1.2哈希表的定义：用散列法储存的线性表叫散列表（Hash table），又称杂凑表，哈希表，对应的函数称为散列函数、杂凑函数或哈希函数 1.3装填因子：设散列表空间大小为n，填入表中的结点数为m，则称a=m/n为散列表的装填因子 1.4散列函数的选取原则：运算简单、函数值域不能超过表长、尽可能使关键字不同时，散列函数值也不同 1.5冲突与同义词：若x!=y，但H(x)==H(y)称为冲突；x与y称为同义词（发生冲突的两个关键字） 2.哈希函数的构造方法2.1直接定址法 2.1.0取关键字或关键字的某个线性函数值为哈希地址 2.1.1优点：无冲突 2.1.2缺点：若关键字集合取值跨度很大，浪费储存空间严重 2.2质数取余法 2.2.1用质数取余，减少冲突 2.2.2采用的质数要小于表长 2.3平方取中法 2.3.0在不知道关键字的全部情况时，可通过求关键字的平方值扩大差别，然后取中间几位作为哈希地址 2.4折叠法 2.5数字分析法 2.6基数转换法 3.处理冲突的方法3.1开放定址法 3.1.0（开放地址法）开放地址指地址单元为空，对数组来说，是指还没存入数据的数据单元，在顺序储存结构中用一定方法进行散列存取的方法称为开放定址法 3.1.1开放定址法处理冲突的方法 3.1.1.1线性探测再散列（向后挪位置（一个一个挪）找到有空的位置） 3.1.1.2二次探测再散列法：向后挪（1、1、4、4、、、k^2、(-k)^2）（其中k&lt;n/2） 3.1.1.3伪随机序列：向后挪（伪随机序列） 3.1.1.4再哈希法（多个哈希函数一次不行多次迭代） 3.2拉链法（链地址法）（采用链接表方式储存信息（索引表）） 4.哈希表的查找及其分析4.0a：装载因子；m：表长；n：记录数 4.1算法分析 ​ 4.2散列法与其他方法的比较 4.2.1除散列法外，其他查找方法的共同特征为：均建立在比较关键字的基础上 4.2.2散列法是根据关键字直接求出地址的查找方法，其查找的期望时间为O(1) 本笔记除了自己的一些理解外，参考《数据结构》，图片出自网络和课程ppt，如有侵权，请联系笔者删除。 最后希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。 ​","path":"2022/01/10/shu-ju-jie-gou-cha-zhao/","date":"01-10","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最短路径算法","text":"一、概念1.路径长度：路径上边的权值之和 2.最短路径：两结点间权值和最小的路径 3.单源最短路径：给定有向图G和源点A，求A到图G中其余各顶点的最短路径 二、Dijkstra算法—单源最短路径算法1.基本思想： 1.1设置3个数组分别表示源点到其余各点的距离X（初始时与源点直接相连的点计入权值，其他点计无穷），源点到各点的最短路径Y（一开始都是无穷），已找到最短路径的点Z（一开始均为0） 1.2在X中找到距离最短的距离点（X中数的最小值），且该点还没有计入最短路径，将该最短路径计入Y，对应Z数组值置1，并且由该点找到与该点直接相连的点，将这些点连接的权值与已加入边（源点与“该点”）权值相加与X已有信息比较选择最小值计入X 1.3循环执行1.2直至所有点均找到最短路径 1.4也可以加入一个记录路径的数组 2.算法分析：时间复杂度O(n^2)，空间复杂度O(n) 3算法功能： 3.1求顶点到其余顶点的最短路 3.2判断两顶点之间是否有路 3.3判断有无包含两顶点的环路 4.求单源最短路径的Dijkstra算法不允许边权值为负值 三、各个结点间的最短路径—Floyd算法1.重复执行Dijkstra算法n次即可求得各结点间的最短路径，或者通过Floyd算法 2.Floyd算法的基本思想： 2.1顶点编号（1~n），邻接矩阵X表示有向网络 2.2依次向X中路径添加从1到n结点，判断最优路径存储，即可 2.3判断方法：X矩阵内数字代表AB路径，插入C，若AC+CB&lt;AB，则用AC+CB替代AB（类似Dijkstra算法） 3.Floyd算法分析：时间复杂度O(n^3)，空间复杂度O(n^2) 4.Floyd算法功能： 4.1求出任意两点间的最短路径 4.2判断任意两点间是否有路 4.3判断有向图经过任意两点是否有环路 5.对于Floyd算法来讲，权值可以为负值，但不能有长度为负值的环路 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/10/zui-duan-lu-jing-suan-fa/","date":"01-10","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"hexo框架下博客文章插入本地图片教程","text":"在建立个人博客时，出现博客文章中引用本地图片的需求。下面是步骤：首先，下载hexo-asset-image这个package，（这里结合网络上其他教程内容，得知直接下载官方现在版本有bug，笔者直接采取代替途径做修改）输入命令cnpm install https://github.com/CodeFalling/hexo-asset-image –save安装代替版本（开头命令cnpm与npm差别不大）。然后，在_config.yml中更改post_asset_folder选项为true。最后，应用方式为![标题](图片文件名+后缀)笔者采用Gitee搭载个人博客的方式。理论上图片加载成功，但是实际上笔者这里由于src的错误转换导致图片加载异常，需要更改hexo-asset-image的配置：进入文件夹node_modules，找到hexo-asset-image的配置文件夹，打开index.js，将文件中$(this).attr(‘src’, config.root + link + src)更改为$(this).attr(‘src’, ‘/‘ + link + src)，图片在Gitee中html文件里建立正确关联，图片加载成功。错误代码反映（Gitee中html文件）：img src=\"/blog/blog/2000/0/0/try/图片.jpg\" alt=\"图片\"即config.root重复。","path":"2022/01/08/hexo-kuang-jia-xia-bo-ke-wen-zhang-cha-ru-ben-di-tu-pian-jiao-cheng/","date":"01-08","excerpt":"","tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jia_k3.gitee.io/blog/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"Git+Gitee关联教程","text":"1.下载Git：Git - Downloads (git-scm.com) 2.配置Gitee的SSH公钥 2.1右键打开Git Bash或者win+r（cmd）打开命令行 2.2输入指令： ssh-keygen (指定公钥类型(可有可无，无则默认rsa)：-t rsa) (区别注释(可有可无，添加后更有识别性): -C \"ooooooo@ooooo.com\")（注释不必要是邮箱） 完整版： ssh-keygen -t rsa -C \"123456@qwq.com\" 2.3回车 2.4提示输入密码，可以直接回车，默认回车无密码 2.5确认密码，2.4输入什么这里就输入什么 2.6显示公钥文件存储位置，找到文件****.pub，打开文件复制ssh公钥 2.7进入Gitee网站登录，找到ssh公钥设置 2.8设置好标题，将2.6复制的公钥复制到公钥框，确定即可 3.Git常用命令 3.0初始化文件路径：git init 3.1复制库：git clone git链接 3.2关联远程库：git remote add 关联名称 git链接 3.2.1查看已链接远程库库：git remote -v 3.2.2删除已有远程库：git remote rm 关联名称 3.3向远程库提交文件： 3.3.1添加文件、文件夹：git add -A(文件夹或者文件名+后缀，-A表示全部) 3.3.2添加文件，提交前需要提供本次提交的注释：git commit -m “注释” 3.3.3提交文件：git push -u 关联名称 master 3.3.4后面提交文件：git push 关联名称（如果Git Bash关闭前面用3.3.3提交过一次，因已用-u确定默认分支，可以使用更为简化版的git push） 3.3.5向远程库提交文件报错error: failed to push some refs to，原因：两端都有内容且内容不一致，使用命令统一两端文件即可：git pull –rebase 关联名称 master 希望大家一起学习，共同进步，如果有疑问或错误欢迎联系笔者。","path":"2022/01/07/git-gitee-guan-lian-jiao-cheng/","date":"01-07","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"https://jia_k3.gitee.io/blog/tags/Git/"}]}],"categories":[],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://jia_k3.gitee.io/blog/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"Linux","slug":"Linux","permalink":"https://jia_k3.gitee.io/blog/tags/Linux/"},{"name":"LLM","slug":"LLM","permalink":"https://jia_k3.gitee.io/blog/tags/LLM/"},{"name":"Android","slug":"Android","permalink":"https://jia_k3.gitee.io/blog/tags/Android/"},{"name":"Unity","slug":"Unity","permalink":"https://jia_k3.gitee.io/blog/tags/Unity/"},{"name":"考研","slug":"考研","permalink":"https://jia_k3.gitee.io/blog/tags/%E8%80%83%E7%A0%94/"},{"name":"生活","slug":"生活","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%94%9F%E6%B4%BB/"},{"name":"游戏设计","slug":"游戏设计","permalink":"https://jia_k3.gitee.io/blog/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Java","slug":"Java","permalink":"https://jia_k3.gitee.io/blog/tags/Java/"},{"name":"理论","slug":"理论","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%90%86%E8%AE%BA/"},{"name":"Python","slug":"Python","permalink":"https://jia_k3.gitee.io/blog/tags/Python/"},{"name":"网络通信","slug":"网络通信","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"Csharp","slug":"Csharp","permalink":"https://jia_k3.gitee.io/blog/tags/Csharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://jia_k3.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"starUML","slug":"starUML","permalink":"https://jia_k3.gitee.io/blog/tags/starUML/"},{"name":"时序图","slug":"时序图","permalink":"https://jia_k3.gitee.io/blog/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"},{"name":"CSS","slug":"CSS","permalink":"https://jia_k3.gitee.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://jia_k3.gitee.io/blog/tags/HTML/"},{"name":"反编译","slug":"反编译","permalink":"https://jia_k3.gitee.io/blog/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"EPPlus","slug":"EPPlus","permalink":"https://jia_k3.gitee.io/blog/tags/EPPlus/"},{"name":"VS","slug":"VS","permalink":"https://jia_k3.gitee.io/blog/tags/VS/"},{"name":"QT","slug":"QT","permalink":"https://jia_k3.gitee.io/blog/tags/QT/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://jia_k3.gitee.io/blog/tags/MYSQL/"},{"name":"程序打包","slug":"程序打包","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"},{"name":"QT组件","slug":"QT组件","permalink":"https://jia_k3.gitee.io/blog/tags/QT%E7%BB%84%E4%BB%B6/"},{"name":"算法","slug":"算法","permalink":"https://jia_k3.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jia_k3.gitee.io/blog/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"Git","slug":"Git","permalink":"https://jia_k3.gitee.io/blog/tags/Git/"}]}