<!DOCTYPE HTML><html lang="zh-CH"><head><meta charset="utf-8"><meta name="keywords" content="《数据库系统》课程笔记, 布执刀"><meta name="description" content="​
一、绪论1.数据1.1数据是描述现实世界中各种具体事物或抽象概念的可存储编码，是信息的载体
1.2数据的类型：数字、字符串、日期、逻辑值、文本、图像、声音、图型结构、树型结构
2.数据库2.1数据库：是长期储存在计算机内、有组织的、可共"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>《数据库系统》课程笔记 | 布执刀</title><link rel="icon" type="image/png" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/libs/awesome/css/all.min.css"><link rel="stylesheet" href="/blog/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/blog/libs/aos/aos.css"><link rel="stylesheet" href="/blog/libs/animate/animate.min.css"><link rel="stylesheet" href="/blog/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/blog/css/matery.css"><link rel="stylesheet" href="/blog/css/my.css"><script src="/blog/libs/jquery/jquery-3.6.0.min.js"></script><meta name="generator" content="Hexo 6.0.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/blog/atom.xml" title="布执刀" type="application/atom+xml"><link rel="stylesheet" href="/blog/css/prism.css"><link rel="stylesheet" href="/blog/css/prism-line-numbers.css"></head><style lang="css">#loading-container{position:fixed;top:0;left:0;min-height:100vh;width:100vw;z-index:9999;display:flex;flex-direction:column;justify-content:center;align-items:center;background:#fff;text-align:center;-webkit-transition:opacity 1s ease;-moz-transition:opacity 1s ease;-o-transition:opacity 1s ease;transition:opacity 1s ease}.loading-image{width:120px;height:50px;transform:translate(-50%)}.loading-image div:nth-child(2){-webkit-animation:pacman-balls 1s linear 0s infinite;animation:pacman-balls 1s linear 0s infinite}.loading-image div:nth-child(3){-webkit-animation:pacman-balls 1s linear .33s infinite;animation:pacman-balls 1s linear .33s infinite}.loading-image div:nth-child(4){-webkit-animation:pacman-balls 1s linear .66s infinite;animation:pacman-balls 1s linear .66s infinite}.loading-image div:nth-child(5){-webkit-animation:pacman-balls 1s linear .99s infinite;animation:pacman-balls 1s linear .99s infinite}.loading-image div:first-of-type{width:0;height:0;border:25px solid #49b1f5;border-right-color:transparent;border-radius:25px;-webkit-animation:rotate_pacman_half_up .5s 0s infinite;animation:rotate_pacman_half_up .5s 0s infinite}.loading-image div:nth-child(2){width:0;height:0;border:25px solid #49b1f5;border-right-color:transparent;border-radius:25px;-webkit-animation:rotate_pacman_half_down .5s 0s infinite;animation:rotate_pacman_half_down .5s 0s infinite;margin-top:-50px}@-webkit-keyframes rotate_pacman_half_up{0%{transform:rotate(270deg)}50%{transform:rotate(1turn)}to{transform:rotate(270deg)}}@keyframes rotate_pacman_half_up{0%{transform:rotate(270deg)}50%{transform:rotate(1turn)}to{transform:rotate(270deg)}}@-webkit-keyframes rotate_pacman_half_down{0%{transform:rotate(90deg)}50%{transform:rotate(0)}to{transform:rotate(90deg)}}@keyframes rotate_pacman_half_down{0%{transform:rotate(90deg)}50%{transform:rotate(0)}to{transform:rotate(90deg)}}@-webkit-keyframes pacman-balls{75%{opacity:.7}to{transform:translate(-100px,-6.25px)}}@keyframes pacman-balls{75%{opacity:.7}to{transform:translate(-100px,-6.25px)}}.loading-image div:nth-child(3),.loading-image div:nth-child(4),.loading-image div:nth-child(5),.loading-image div:nth-child(6){background-color:#49b1f5;width:15px;height:15px;border-radius:100%;margin:2px;width:10px;height:10px;position:absolute;transform:translateY(-6.25px);top:25px;left:100px}.loading-text{margin-bottom:20vh;text-align:center;color:#2c3e50;font-size:2rem;box-sizing:border-box;padding:0 10px;text-shadow:0 2px 10px rgba(0,0,0,.2)}@media only screen and (max-width:500px){.loading-text{font-size:1.5rem}}.fadeout{opacity:0}@-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}@keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0)}}</style><script>(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },2500); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()</script><body><div id="loading-container"><p class="loading-text">嘘~ 正在从服务器偷取页面 . . .</p><div class="loading-image"><div></div><div></div><div></div><div></div><div></div></div></div><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/blog/" class="waves-effect waves-light"><img src="/blog/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">布执刀</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/blog/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>Index</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/blog/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>Tags</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/blog/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>Categories</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/blog/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>Archives</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/blog/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>About</span></a></li><li class="hide-on-med-and-down nav-item"><a target="_blank" rel="noopener" href="https://jkspectator.github.io/game/" class="waves-effect waves-light"><i class="fas fa-gamepad" style="zoom:.6"></i> <span>Game</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="Search" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/blog/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">布执刀</div><div class="logo-desc">欢迎大家与我一起交流学习</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/blog/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> Index</a></li><li class="m-nav-item"><a href="/blog/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> Tags</a></li><li class="m-nav-item"><a href="/blog/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> Categories</a></li><li class="m-nav-item"><a href="/blog/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> Archives</a></li><li class="m-nav-item"><a href="/blog/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> About</a></li><li class="m-nav-item"><a target="_blank" rel="noopener" href="https://jkspectator.github.io/game/" class="waves-effect waves-light"><i class="fa-fw fas fa-gamepad"></i> Game</a></li></ul></div></div></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/blog/medias/featureimages/3.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">《数据库系统》课程笔记</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/blog/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px;background-color:rgb(255,255,255,.7);border-radius:10px;box-shadow:0 10px 35px 2px rgba(0,0,0,.15),0 5px 15px rgba(0,0,0,.07),0 2px 5px -5px rgba(0,0,0,.1)!important}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/blog/tags/%E7%90%86%E8%AE%BA/"><span class="chip bg-color">理论</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" class="post-category">笔记</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> Publish Date:&nbsp;&nbsp; 2022-06-01</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><p>​</p><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>1.1数据是描述现实世界中各种具体事物或抽象概念的可存储编码，是信息的载体</p><p>1.2数据的类型：数字、字符串、日期、逻辑值、文本、图像、声音、图型结构、树型结构</p><h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2.数据库"></a>2.数据库</h3><p>2.1数据库：是长期储存在计算机内、有组织的、可共享的数据集合</p><p>2.2数据库的特征：不是临时存储，数据按一定的数据形式组织、描述和储存，可为各种用户共享</p><p>2.3数据库的类型：</p><p>2.3.1按照数据的类型：简单结构数据库（关系数据库，时、空数据库），复杂结构数据库（图数据库），半结构化数据库（XML数据库），非结构化数据（文本、音视频、图像等多媒体数据库）</p><p>2.3.2数据存储的方式：单机数据库，分布式数据库，并行数据库</p><p>2.3.3数据存储的介质、时长：内存数据库、流数据库</p><p>2.4数据库目的：把现实世界映射到计算机世界，支持各种实际应用</p><p>2.5数据库模式：数据集合的结构定义</p><p>2.6数据库实例：数据集合的具体内容</p><h3 id="3-数据库管理系统及其结构"><a href="#3-数据库管理系统及其结构" class="headerlink" title="3.数据库管理系统及其结构"></a>3.数据库管理系统及其结构</h3><p>3.1数据库管理系统(DBMS)：管理数据库，支持应用的软件系统</p><p>3.1.1定义、组织、存储、管理数据</p><p>3.1.2数据操纵</p><p>3.1.3确保数据正确、安全、完整</p><p>3.1.4并发控制与事务处理</p><p>3.2数据字典是数据库管理系统的信息中心</p><p>3.3数据库管理系统的功能与特点：</p><p>3.3.1有效地支持数据抽象与数据定义（具有坚实的数据模型基础、支持数据的不同视图）</p><p>3.3.2有效地组织存储数据（提供丰富的数据存储方法、提供有效的数据存取方法）</p><p>3.3.3有效地处理数据查询与更新（提供有效的数据操纵语言、提供高效的数据操作算法、优化地处理数据查询）</p><p>3.3.4支持数据独立性</p><p>3.3.5控制数据冗余（综合考虑所有用户的数据库视图，把它们集成为一个逻辑模式，数据项只存储1次或少数几次）</p><p>3.3.6支持数据共享/并发控制（允许多个用户或多个应用程序同时访问数据库中的相同数据，即允许数据共享；为了支持数据共享，数据库管理系统具有并发控制机制）</p><p>3.3.7限制非授权的存取（为了保证数据库的安全，防止对数据库的非法存取，DBMS具有一个安全与授权子系统）</p><p>3.3.8提供多种用户界面（图形界面，查询语言界面，程序设计语言界面）</p><p>3.3.9表示数据之间的复杂联系（数据间联系的定义机制，通过数据间联系查询数据的机制）</p><p>3.3.10支持完整性约束（数据库应用对数据语义一般都有一定的限制，称为完整性约束）</p><p>3.3.11有效的数据恢复与事务处理（在系统硬件或软件发生故障时，能够保证数据库的正确性）</p><h3 id="4-数据库系统"><a href="#4-数据库系统" class="headerlink" title="4.数据库系统"></a>4.数据库系统</h3><p>4.1数据库系统有多种看法，但一般都包括数据库和数据库管理系统</p><p>4.2文件系统：不同部门拥有各自独立的数据文件。由于一下因素而使用数据库系统：数据冗余和不一致、数据访问异常、数据孤立、完整性问题、原子性问题、并发访问异常、安全性问题</p><p>4.3数据库系统：按照某种数据模型，将全部门的各种数据组织到一个统一的结构化的数据库中，整个部门的数据不是一盘散沙，可表示出数据之间的有机关联</p><p>4.4数据统一存储在关系数据库中</p><p>4.5查询：只需提交查询要求，由系统完成查询过程</p><h3 id="5-数据抽象与数据模型"><a href="#5-数据抽象与数据模型" class="headerlink" title="5.数据抽象与数据模型"></a>5.数据抽象与数据模型</h3><p>5.1数据抽象的作用：对于用户系统地隐藏关于数据存储和维护的某些细节；屏蔽复杂性，简化用户与系统的交互</p><p>5.2视图抽象：把现实世界信息按不同用户观点抽象为多个逻辑数据结构，每个逻辑结构称为一个视图，描述了每个用户所关心的数据；所有视图的集合形成了多个数据库用户的若干外模式（一个数据库可以有多个外模式）</p><p>5.3逻辑抽象：综合外模式中所有视图，把所有用户关心的现实世界抽象为逻辑模式，形成数据库整体逻辑（一个数据库有唯一的概念模式）</p><p>5.4物理模式：对逻辑模式进行抽象成为数据库的内模式，确定如何在物理存储设备上存储数据库（一个数据库有唯一的物理模式）</p><p>5.5物理数据独立性：由内模式/逻辑模式映射实现，数据库内模式发生改变时仅需修改内模式/逻辑模式映射，数据的逻辑结构不变，应用程序可以不变</p><p>5.6逻辑数据独立性：由逻辑模式/外模式映射实现，当逻辑模式发生改变时仅需要修改逻辑模式/外模式映射，数据库的外模式不变，应用程序可以不变</p><p>5.7数据抽象：视图抽象为外模式，概念抽象为逻辑模式，物理模式抽象为内模式</p><p>5.8数据独立：物理独立性（内模式发生改变时，概念模式可以不变），逻辑独立性（概念模式发生改变时，外模式可以不变）</p><p>5.9数据模型是实现数据抽象的工具，是数据库系统关键、决定，数据模型的必要条件</p><p>5.10数据模型的基本要素：数据结构、数据操作、数据的完整性约束</p><p>5.11常用的数据模型：实体关系(E-R)数据模型，面向对象(O-O)数据模型，关系数据模型，对象关系(O-R)数据模型，层次和网络数据模型</p><p>5.12层次数据模型</p><p>5.12.1满足下列两个条件的基本层次联系的集合为层次模型：有且只有一个结点没有双亲结点，这个结点称为根节点；根以外的其他结点有且只有一个双亲结点</p><p>5.12.2层次模型的数据结构是满足下列条件的树：每个结点：现实世界的对象的一个抽象（一类对象），又称实体；边表示对象之间的联系</p><p>5.12.3特点：结点的双亲是唯一的；只能直接处理一对多的实体联系；任何记录值只有按其路径查看时，才能显示它的全部意义；没有一个子女记录值能够脱离双亲记录值而独立存在</p><p>5.12.4完整性约束：无相应的双亲结点值就不能插入子女结点值；如果删除双亲结点值，则相应的子女结点值也被同时删除</p><p>5.12.5优点：简单、直观、自然、容易理解；性能优于关系模型，不低于网状模型；层次数据模型提供了良好的完整性支持</p><p>5.12.6缺点：多对多联系表示不自然；对插入和删除操作的限制多；查询子女结点必须通过双亲结点；面向过程</p><p>5.13网状数据模型</p><p>5.13.1数据结构是满足下列条件的图：每个结点是一个对象记录；边表示对象之间的联系；允许多个结点无双亲结点；允许结点有多个双亲结点；允许两个结点之间有多种联系</p><p>5.13.2层次结构是网状结构特例</p><p>5.13.3完整性约束条件不严格：允许插入尚未确定双亲结点值得子女结点值；允许只删除双亲结点值；一些具体系统提供了一些完整性约束</p><p>5.13.4优点：能够更为直接地描述现实世界；具有良好得性能，存取效率较高</p><p>5.13.5缺点：结构比较复杂，不利于最终用户掌控；DDL\DML语言复杂，用户不容易使用；面向过程</p><h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><h3 id="1-关系模型"><a href="#1-关系模型" class="headerlink" title="1.关系模型"></a>1.关系模型</h3><p>1.1数据结构</p><p>1.1.1关系模型建立在集合代数的基础上，单一的数据结构（关系，现实世界的实体以及实体间的各种联系均用关系来表示），数据的逻辑结构是二维表</p><p>1.1.2元组表示一个实体；关系是元组的集合</p><p>1.1.3属性：用来指代关系表的列，n元关系有n个属性，属性的顺序无关紧要</p><p>1.1.4域：属性的所有可能取值的集合（原子域：域中值不可再分；空值：一个特殊的值，表示值未知或不存在）</p><p>1.1.5笛卡尔积：给定一组域D1,D2,…,Dn，这些域中可以有相同的。D1,D2,…,Dn的笛卡尔积为D1*D2*…Dn={(d1,d2,…,dn)|di属于Di,i=1,2,…,n}（所有域的所有取值的一个组合，不能重复）</p><p>1.1.6元组：笛卡尔积中每一个元素(d1,d2,…,dn)叫做一个n元组或简称元组</p><p>1.1.7关系的数学定义：D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，称为n元关系</p><p>1.1.8关系的性质：列是同质的，每一列中的分量来自同一个域；关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性；列的次序可以任意交换，即满足交换律；任意两个元组不能完全相同；行的顺序无所谓，可以任意交换；属性值必须取原子值</p><p>1.1.9关系模式：关系的型，具有形式R(U,D,I,F)，其中：R是关系名，U是R的属性集合，D是U中属性的域集合，I是完整性约束集合，F是属性间的函数依赖关系（简单记作R(U)，把属性集合为U={A1,A2,…,An}的关系模式R记作R(A1,A2,…,An)）</p><p>1.1.10关系、关系模式与关系实例：关系是一个数据集合；关系模式描述关系的数据结构和语义描述，非集合；关系模式是相对稳定的；关系是随时间而变化的；关系实例是某一时刻的关系，是某一时刻现实世界状态的真实反映</p><p>1.1.11数据库中常见的关系类型：基本关系（基本表、基表）由用户定义，在数据库中实际存储的关系，可以查询与更新；中间结果关系：对关系进行查询，产生的中间结果，在数据库中临时/永久存储，只可查询，不可更新；视图关系：用户根据需要定义的关系，定义在基本关系或视图上，只有模式，没有实例，没有对应的实际存储的数据，可查询，更新受限</p><p>1.1.12关系数据库模式：一组关系模式的集合DB={R1,R2,…,Rn}，其中，Ri是第i个关系模式</p><p>1.2完整性约束</p><p>1.2.1超码(superkey)：关系模式R(U)的属性集K是超码，如果K的值可以在R中唯一地标识一个元组</p><p>1.2.2候选码(候选键)：关系模式R(U)的属性集合k包含于U是候选码，如果k是超码（唯一性）且k的任何真子集都不满足条件（最小性）（一个关系模式可能具有多个候选键）</p><p>1.2.3主键：被数据库设计者选中的，用来在同一关系中区分不同元组的候选键（选择原则：值从不或很少变化）（一个关系模式只能具有一个主键，主键中的属性称为关系的主属性）</p><p>1.2.4外键：设有关系模式S(U’)和R(U)，及属性集合X，X包含于U’且X属于U，若X是S(U’)的主键，则称X是R(U)关于S(U’)的外键（不一定与对应的主键同名，外键取值对应主键的某个值或者空值）</p><p>1.2.5实体完整性约束：如果A是关系模式R(U)的主键属性，则A不能取空值</p><p>1.2.6关联完整性约束：定义了主键与外键之间的规则（外键只能取空值或与之关联的主键值）</p><p>1.3关系代数运算：</p><p><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/1.png"><br>选择：选择行（元组）<br>投影：选择列（属性）<br>并：合并元组，删除重复（约束条件：属性相容（相同））<br>差：从前者元组中删除后者包含的元组（约束条件：属性相容）<br>笛卡尔积：将任意两个关系的信息组合在一起<br>重命名：重命名关系，属性依次重命名<br>交：找到同时包含于两个关系的元组（约束条件：属性相容）<br>连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组<br>自然连接：特殊的等值连接，比较两个关系的同名属性，最后将同名属性列去冗余<br>除：根据除关系的属性B找到被除关系的同名属性B的相同元组(A,B)得到A为最终结果<br>左（右）外连接：左右关系做自然连接，取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把所产生的元组加到自然连接的结果中<br>广义投影：将算术运算作为投影的一部分比如2020-age可以作为投影属性出现<br>分组聚集：依据属性的值分组，分别对每组数据进行运算（sum\count\max\min\avg）</p><p>1.4当我们书写关系代数表达式时，我们提供了产生查询结果的过程序列，与之相反，元组关系演算是非过程化的查询语言，它只描述所需信息，不给出获得该信息的具体过程</p><p>1.5元组关系演算：</p><p><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/2.png"></p><p>1.6域关系演算：</p><p><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/3.png"></p><p>1.7安全关系运算系统：如果一个关系运算系统不产生无限关系和无穷验证，则这个运算是安全的</p><p>1.7.1关系代数系统安全（有限关系上的关系代数操作结果都不会导致无限关系和无穷验证）</p><p>1.7.2元组关系演算和域关系演算系统不安全（若定义域无穷，判断需要无穷验证）（需要加以限制来保证其安全性）</p><p>1.8关系代数、元组和域演算的等价性：</p><p>1.8.1如果两个表达式所表达的关系相同，我们称这两个表达式为等价表达式</p><p>1.8.2设E是任意关系代数表达式，则存在一个与E等价的安全元组演算表达式</p><p>1.8.3每个安全的元组演算表达式都有一个等价的安全域演算表达式</p><p>1.8.4每个安全域演算表达式都有一个等价的关系代数表达式与之对应</p><h3 id="2-SQL查询语言"><a href="#2-SQL查询语言" class="headerlink" title="2.SQL查询语言"></a>2.SQL查询语言</h3><p>2.0关系运算是关系数据库查询语言的基础<br>关系代数语言：ISBL：纯关系代数查询语言<br>元组关系演算语言：QUEL：元组关系演算的查询语言<br>域关系演算语言：QBE<br>关系代数+关系演算语言：SQL：目前使用最广泛</p><p>2.1数据库语言的两种使用方式：</p><p>2.1.1交互式：通过计算机终端设备直接操作数据库</p><p>2.1.2嵌入式：在宿主语言(如C、C++)程序中使用数据库语言语句</p><p>2.2SQL的特点：综合统一，高度非过程化，面向集合的操作方式，语言简捷，易学易用<br>2.3SQL的九条语句：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/4.png"></p><p>2.4​SQL的数据定义语句：<br>| | | | |<br>| :-: | :-: | :-: | :-: |<br>| |创建 | 删除 | 修改 |<br>| 表 | CREATE TABLE |DROP TABLE | ALTER TABLE |<br>| 视图 | CREATE VIEW | DROP VIEW | 无 |<br>| 索引 | CREATE INDEX | DROP INDEX |无 |<br>视图和索引无修改语句<br>2.5一般语法格式：</p><pre class="line-numbers language-SQL"><code class="language-SQL">SELECT [DISTINCT/ALL] &lt;列表达式&gt;[别名] [,&lt;列表达式&gt;[别名]]...
FROM &lt;表名&gt;[&lt;别名&gt;][,&lt;表名&gt;[&lt;别名&gt;]]1~n
[WHERE &lt;条件表达式&gt;]
[GROUP BY &lt;分组属性表&gt; [HAVING &lt;条件表达式&gt;]]
[ORDER BY &lt;列名&gt;[ORDER],...,&lt;列名&gt;[ORDER]]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、数据库的安全性与完整性"><a href="#三、数据库的安全性与完整性" class="headerlink" title="三、数据库的安全性与完整性"></a>三、数据库的安全性与完整性</h2><h3 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h3><p>0.1为了保证数据库数据的安全可靠和正确有效，DBMS必须提供统一的数据保护功能<br>0.2数据库的安全性：数据库的任何部分都不允许受到恶意侵害或未经授权的存取和修改<br>0.3数据库的完整性：一般指语义完整性与事务完整性，本章主要讨论数据库的语义完整性<br>0.4用户操作权限和完整性约束都存储在数据库管理系统的数据字典中<br>0.5数据库的安全性和完整性都由数据库管理系统来确保</p><h3 id="1-数据库安全性"><a href="#1-数据库安全性" class="headerlink" title="1.数据库安全性"></a>1.数据库安全性</h3><p><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/5.png"><br>1.1数据库的一大特点是数据可以共享，但数据共享必然带来数据库的安全性问题<br>1.2数据库安全性控制的常用方法：用户标识和鉴定，存取控制，视图，审计，加密存储<br>1.3用户标识与鉴别：<br>1.3.1系统提供的最外层安全保护措施<br>1.3.2用户身份鉴别的方法有：静态口令，动态口令，生物特征鉴别，智能卡鉴别<br>1.4存取控制机制：<br>1.4.1存取控制机制的组成：定义存取权限（权限通过编译后存储在数据字典中）；检查存取权限（用户向数据库发出存取请求后，DBMS查找数据字典，检查权限可否执行）<br>用户权限定义和合法权检查机制一起组成了DBMS的安全子系统<br>1.4.2存取控制机制（常用存取控制方法）：<br>自主存取控制(DAC)；SQL对自主存取控制提供的支持（Grant授予权限；Revoke收回权限）<br>强制存取控制(MAC)：用户不能直接感知或进行控制，适用于对数据有严格而固定秘密分级的部门<br>1.4.2’强制存取控制（续）：<br>主体：系统中的活动实体，包括用户、代表用户的各个进程<br>客体：系统中的被动实体，包括文件、基本表、索引、视图等<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/6.png"><br>审计：审计功能启用一个专用的审计日志，系统自动将用户对数据库的所有操作记录在上面，DBA可以利用审计日志中的跟踪信息，重现导致数据库现有状况的一系列事件，以找出非法存取数据的人<br>数据加密：防止数据库中数据在存储和传输中失密的有效手段<br>加密的基本思想：<br>根据一定的算法将原始数据（明文）变换为不可直接识别的格式（密文）<br>1.4.3用户权限的两个要素：数据库对象，操作类型<br>1.4.4数据库角色：被命名的一组与数据库操作相关的权限，可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程</p><h3 id="2-数据库完整性"><a href="#2-数据库完整性" class="headerlink" title="2.数据库完整性"></a>2.数据库完整性</h3><p>2.1数据库完整性：为保证数据库中数据的正确性和相容性，对比关系模型提出的某种约束条件或规则<br>2.2完整性约束通常包括：域完整性，实体完整性，关联完整性（参照完整性），用户定义完整性（前三者是关系模型必须满足的完整性约束条件）<br>2.3为维护数据库完整性，DBMS必须提供如下功能：定义完整性约束条件的机制，完整性检查方法，违反约束的处理方法<br>2.4域完整性：保证关系表属性取值的合理性<br>2.4.1域完整性检查：包括检查、默认值、不为空、列值唯一等<br>2.5实体完整性：关系的主码不能重复也不能取空值<br>2.6关联完整性（参照完整性）：在建立关系的时候用FOREIGN KEY短语定义外码，用REFERENCES短语指明这些外码参照哪些表的主码<br>2.6.1对被参照关系和参照关系进行增、删、改操作时可能破坏关联完整性，必须进行检查以保证两个关系中数据的相容性<br>2.6.2一个操作破坏关联完整性时，系统可以采取的策略：拒绝执行，级联操作（将不一致元组删除），设置为空值（将不一致元组设置为空值）<br>2.7用户定义的完整性：<br>2.7.1属性上的约束条件：NOT NULL|UNIQUE|CHECK子句<br>2.7.2元组上的约束条件：CHECK子句可以设置不同属性之间的取值的相互约束条件<br>2.8完整性约束命名子句语法结构：<br>2.8.1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;<br>2.8.2&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK子句等<br>2.9断言Assertion<br>2.9.1通过声明断言，可以定义更具一般性的约束，例如涉及多个表或聚集操作的比较复杂的完整性约束<br>2.9.2对断言所涉及关系的操作将触发RDBMS对断言的检查<br>2.9.3任何使断言不为真的操作都会被拒绝<br>2.9.4语法结构：<br><code>CREATE ASSERTION &lt;断言名&gt; &lt;Check子句&gt; DROP ASSERTION &lt;断言名&gt;</code><br>2.10触发器Trigger<br>2.10.1触发器是用户定义在关系表上的一类由事件驱动的特殊过程<br>2.10.2定义之后的触发器存储在数据库服务器中<br>2.10.3任何用户对表的增、删、改操作均由服务器自动激活相应的触发器<br>2.10.4不同RDBMS实现的触发器语法各不行同，互不兼容<br>2.10.5语法结构：<br>定义触发器<br><code>CREATE TRIGGER &lt;触发器名&gt; {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW|TABLE AS &lt;变量&gt; FOR EACH {ROW | STATEMENT} [WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;</code><br>删除触发器<br><code>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</code><br>2.10.6只有表的拥有者（创建者）可以在表上定义触发器；触发器名中可以包含模式名，同一模式下触发器不能重名，而且触发器名和表名必须在统一模式下；触发器只能定义在基本表上，不能定义在视图上<br>2.10.7触发器激活顺序：执行该表上的BEFORE触发器-激活触发器的SQL语句-执行该表上的AFTER触发器-多个BEFORE（AFTER）触发器时, 先执行先创建的, 或按名字排序</p><h2 id="四、数据库设计"><a href="#四、数据库设计" class="headerlink" title="四、数据库设计"></a>四、数据库设计</h2><h3 id="1-数据库设计概念与需求分析"><a href="#1-数据库设计概念与需求分析" class="headerlink" title="1.数据库设计概念与需求分析"></a>1.数据库设计概念与需求分析</h3><p>1.1数据库设计：对于一个给定的应用领域，设计优化的数据库逻辑和物理结构，使之满足用户的信息管理要求和数据操作要求，有效地支持各种应用系统的开发和运行<br>1.2数据库设计目标：为用户和各种应用系统提供一个信息基础设施和高效率的运行环境，高存取效率，高存储空间利用率，高运行管理效率<br>1.3数据库设计特点：结构（数据）设计和行为（处理/查询）设计二者结合<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/7.png"><br>1.4数据库的各级模式<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/8.png"><br>1.4.1需求分析阶段：综合各个用户的应用需求<br>1.4.2概念设计阶段：形成独立于机器特点，独立于各个数据库管理系统产品的概念模式(E-R图)<br>1.4.3逻辑设计阶段：首先将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，<br>形成数据库逻辑模式；然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立<br>必要的视图（View），形成数据的外模式<br>1.4.4物理设计阶段：根据数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式<br>1.5需求分析：是分析用户的要求，是设计数据库的起点，结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用<br>1.6需求分析的任务：详细调查现实世界要处理的对象（组织、部门、企业等）；充分了解原系统（手工系统或计算机系统）工作概况；明确用户的各种需求；在此基础上确定新系统的功能；新系统必须充分考虑今后可能的扩充和改变<br>1.7需求分析的重点：“数据”和“处理”，获得用户对数据库要求<br>1.7.1信息要求：用户需要从数据库中获得信息的内容与性质；由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据<br>1.7.2处理要求：用户要完成什么处理功能；对处理的响应时间的要求；对处理方式的要求(批处理 / 联机处理)<br>1.8需求分析的步骤：应用领域的调查分析（协助用户明确要求）；定义数据库支持的信息与应用；定义数据库操作任务；定义数据项字典<br>1.8.1常用调查方法：跟班作业，开调查会，专人介绍，询问，调查问卷，查询记录<br>1.8.2数据项字典的组成：<br>数据项：不可再分的数据单位；描述：数据项名、数据项含义说明、别名、数据类型、长度、取值范围、取值含义、与其他数据项的逻辑关系、数据项之间的联系<br>数据结构：反映数据之间的组合关系，由数据项和其他数据结构组成；数据结构描述：数据结构名、含义说明、组成<br>数据流：数据结构在系统内传输的路径；数据流描述：数据流名、说明、数据流来源、数据流去向、组成（包括哪些数据结构）、平均流量、高峰期流量<br>数据存储：数据结构停留或保存的地方，数据流的来源和去向之一，可以是手工文档、凭单或计算机文档；数据存储描述：数据存储名、说明、编号、输入的数据流、输出的数据流、组成、数据量、存取频度、存取方式<br>处理过程：具体处理逻辑一般用判定表或判定树来描述，数据项字典中只描述其说明性信息；处理过程描述：处理过程名、说明、输入（数据流）、输出（数据流）、处理（简要说明，包括功能和要求）</p><h3 id="2-概念数据库设计"><a href="#2-概念数据库设计" class="headerlink" title="2.概念数据库设计"></a>2.概念数据库设计</h3><p>2.1概念数据库设计的任务包括概念数据库模式分析和事务设计<br>2.1.1概念数据库模式设计：以需求分析阶段所识别的数据项和应用领域的未来改变信息为基础，使用高级数据模型建立概念数据库模式<br>2.1.2事务设计：考察需求分析阶段提出的数据库操作任务，形成数据库事务的高级说明<br>2.2概念数据库模式设计的目标：准确描述应用领域的信息模式，支持用户的各种应用；既易于转换为逻辑数据库模式，又容易为用户理解<br>2.3概念模型：用于将需求分析阶段所得到的应用需求抽象为信息世界的结构，是各种数据模型的共同基础，更加独立于DBMS和机器 （更高级）<br>2.4概念模型的特点：<br>2.4.1能真实、充分地反映现实世界，包括事物和事物之间的联系<br>2.4.2易于理解，可用于和不熟悉计算机的用户交换意见<br>2.4.3易于改变，应用环境和应用要求改变时容易对概念模型进行修改<br>2.4.4易于向关系、网状、层次模型转换<br>2.5实体联系模型(ER模型)：用于概念数据库设计的高级数据模型（概念数据库模式独立于任何数据库管理系统，不能直接用于数据库的实现）<br>2.5.1表示为“实体-联系”图<br>2.5.2三个主要元素：实体、属性、联系<br>2.5.3实体是ER模型的基本对象；实体是现实世界中各<br>种事物的抽象<br>2.5.4每个实体都有一组特征或性质，称为实体的属性。实体属性的一组特定值确定了一个特定的实体。实体的属性值是数据库中存储的主要数据<br>2.5.5实体集：相同类型(即具有相同性质或属性) 的实体集合（实体集不必互不相交）<br>2.5.6实体属性：多数实体属性都是单值属性，即对于同一个实体只能取一个值，但是，在某些情况下，实体的一些属性可能取多个值，这样的属性称为多值属性；可以划分为多个具有独立意义的子属性。我们称这类属性为复合属性，复合属性具有层次结构；导出属性不仅可以从另外的属性导出，也可以从有关的实体导出；在某些情况下，实体的有些属性可能没有适当值可设置，这些属性通常被设置一个称为空值的特殊值<br>2.5.7码：在ER模型中每个实体集具有一个由一个或多个属性组成的码，用来区别不同的实体<br>2.5.8联系：不同实体集之间可能具有某种关联，我们称这种关联为实体间的联系<br>2.5.9联系集：同类联系的集合。称一个联系集所关联的实体集的数量为这个联系集的阶。阶为n的联系集称为n元联系集<br>2.5.10实体之间的联系既可以使用联系集定义，也可以通过实体属性来表示<br>2.5.11实体之间的联系（3类映射基数，映射基数：一个实体通过一个联系能关联的实体的个数）：一对一，一对多，多对多<br>注意：同一实体内部个体间可以有二元联系<br>2.5.12联系集的属性：描述性属性<br>2.5.13弱实体：现实世界中存在这样的一些实体集，它们没有足够的属性形成自己的主码。为了区分各个实体，它们必须与其它实体集相关联。这样的实体集称为弱实体集合<br>与弱实体集相关联的实体集: 识别实体集(主实体集)<br>主实体集与它的弱实体集之间的联系称为识别联系<br>主实体与弱实体的关系都为一对多的关系，弱实体为多方<br>一个主实体对应的多个弱实体之间可以相互区别<br>弱实体集必须具有一个或多个属性，使得这些属性可以与主实体集的主码相结合，形成相应弱实体集的主码。这样的弱实体属性称为弱实体集的部分码<br>2.6实体联系图：是表示ER模型的图形工具，简称ER图，ER图用来表示实体集和实体联系集。<br>矩形：实体集<br>椭圆：属性<br>菱形：联系集<br>线段：将属性连接到实体集或将实体集连接到联系集<br>2.7ISA联系：继承联系<br>分类属性：根据分类属性的值把父实体集的实体分派到子实体集中<br>不相交约束（父实体集中的一个实体不能同时属于多个子实体集）、可重叠约束（允许父实体集中的一个实体能同时属于多个子实体集）、完备性约束（完全特化：父实体集中的一个实体必须是属于某一个子实体集中的实体；部分特化：父实体集中的存在实体不属于任何子实体集）、基数约束（对一对一、一对多和多对多的细化，参与联系的每个实体集用基数约束说明其中任何一个实体可以在联系中出现的最小次数和最大次数）<br>2.8E-R模型设计中的一些讨论：<br>2.8.1实体集和联系集的定义方式并不精确<br>2.8.2为了简化E-R模型，现实世界中的事物能用作属性对待的尽量用作属性<br>2.8.3独立的二元联系表达父母与孩子的联系更为自然<br>2.8.4当单纯地描述实体间的行为时，采用联系集<br>2.9概念数据库设计的基本步骤：确定实体集、实体集的属性、主码；确定实体集之间的联系及其相关的约束；形成概念数据库的E-R图<br>2.10概念数据库的设计方法：集中式设计方法（合并在需求分析阶段得到的各种应用需求；在上述基础上设计一个概念数据库模式，满足所有应用的需求），视图综合设计法（不要求应用需求合并，分为视图设计阶段和视图合并阶段）<br>2.11概念数据库设计策略：自顶向下的策略（首先定义全局概念结构框架，然后逐步细化），自底向上的策略（首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构）<br>2.12局部概念模式设计：抽取各局部应用涉及的数据，标定各局部应用中的实体、实体的属性、标识实体的码，确定实体之间的联系及其类型，并形成局部E-R图<br>2.13全局概念模式的合成：各个局部概念模式即局部E-R图建立好后，还需要对它们进行合并，集成为一个整体的数据概念结构即总E-R图<br>集成局部E-R图的步骤：识别局部概念模式间的冲突-修改局部模式-局部模式合并-消除不必要的冗余<br>2.14各局部E-R图存在冲突：各个局部应用所面向的问题不同，由不同的设计人员进行设计，各个局部E-R图之间必定会存在许多不一致的地方，合并分E-R图的主要工作与关键所在：合理消除各局部E-R图的冲突<br>2.15冲突的种类：<br>命名冲突：异名同义，同名异义<br>值域冲突：属性值的类型、取值范围、计量单位等不同<br>模式结构冲突：相同概念在不同的局部模式中使用不同的概念模式表示<br>2.16不必要的冗余：<br>冗余的数据：可由其他基本数据导出的数据<br>冗余的联系：可由其他的联系导出的联系<br>冗余的潜在危险：破坏数据库的完整性，给数据库维护增加负担<br>2.17事务的设计：<br>事务：一个或多个数据操作构成的集合，这组操作满足原子性<br>事务设计任务 ：定义事务功能（说明事务的输入与输出）</p><h3 id="3-逻辑数据库设计"><a href="#3-逻辑数据库设计" class="headerlink" title="3.逻辑数据库设计"></a>3.逻辑数据库设计</h3><p>3.1逻辑数据库设计的任务：把概念数据库设计阶段产生的概念数据库模式变换为逻辑数据库模式<br>3.2逻辑数据库设计的目标：<br>满足用户的完整性和安全性要求<br>动态关系至少具有第三规范形式，静态关系至少具有第一规范形式<br>能够在逻辑级上高效率地支持各种数据库事务的运行<br>存储空间利用率高<br>3.3逻辑数据库设计的步骤：<br>3.3.1形成初始关系数据库模式<br>初始关系数据库模式：指直接由概念数据库模式生成的关系数据库模式<br>初始关系数据库模式生成的目的：把概念数据库模式的实体、实体间联系等模型结构变换为关系模式<br>由概念数据库模式生成初始关系数据库模式的方法：<br>1普通实体集的变换<br>为概念数据库模式中的每个普通实体集E建立一个关系S；S包含E的所有简单属性和E的复合属性的简单<br>子属性；E的主码是S的主码<br>2弱实体的变换<br>设W是概念数据库模式中以实体集E为识别实体集的弱实体，建立一个与W对应的关系R，W的所有简单属性和复合属性的简单子属性映射为R的属性，E的主键为R的属性，R的主键由E的主键和W的部分键组合而成，E对应的关系的主键是R的外部键<br>3多值属性的变换<br>设实体集E具有多值属性，S是E对应的关系，为E的每个多值属性A建立一个关系T，用T表示A ，如果A是简单属性，T的属性为A与S的主键K，A和K形成T的主键，如果A是复合属性， T包含A的简单子属性和S的键K ，A的简单子属性和K形成T的键，S关系中忽略属性A 。对联系R的多值属性类似处理<br>4实体间联系的变换<br>1：1联系的变换：通过在关系中增加有关信息来表示联系；建立一个单独的关系表示联系<br>1：n联系的变换不需建立新关系，在关系中添加外键和关联相关信息；建立一个单独的关系表示联系<br>n：m联系的变换建立新关系表示联系，添加其他关系的主键作为外键<br>n元联系类似n：m联系<br>ISA联系的变换：保留所有关系，建立类似1：n联系；保留子关系，父关系属性加入<br>5确定函数依赖集<br>与用户协商，确定每个初始关系的函数依赖集，并且要使用关系数据库设计理论，对关系模式进行规范化处理<br>3.3.2函数依赖与关系模式规范化<br>1.初始关系模式不是逻辑设计的最终结果，其中某些关系模式可能存在由属性间的函数依赖引起的问题：冗余问题，插入问题，更新问题，删除问题<br>2.相关概念：<br>函数依赖：(只能根据数据的语义来确定函数依赖)<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/9.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/10.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/11.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/12.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/13.png"><br>如果X-&gt;Y而且Y不是X的子集，则称X-&gt;Y是非平凡函数依赖，若不特殊声明，我们总是讨论非平凡函数依赖；如果X-&gt;Y，我们称X为这个函数依赖的决定属性集<br>函数依赖的公理系统：在关系模式的规范化处理过程中，只知道一个给定的函数依赖集合是不够的。还需要知道由给定的函数依赖集合所蕴涵的所有函数依赖的集合。为了能够从给定的函数依赖集合推导出这个集合蕴涵的所有函数依赖，我们需要一个有效而完备的公理系统。Armstrong公理系统就是这样一个系统<br>3.Armstrong公理系统：一套推理规则，是模式分解算法的理论基础<br>用途：求给定关系模式的候选键，从一组函数依赖求得蕴含的函数依赖<br>三条推理规则：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/14.png"><br>由自反律所得到的函数依赖均是平凡的函数依赖<br>导出规则：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/15.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/16.png"><br>4.闭包：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/17.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/18.png"><br>若X的关于F闭包为U，则X为该关系的候选键<br>闭包算法只生成由F根据Armstrong公理能够导出的依赖于X的属性集合<br>5.快速求解候选键的方法：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/19.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/20.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/21.png"><br>6.极小函数依赖集：（不唯一）<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/22.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/23.png"><br>7.关系模式的规范形式<br>范式是符合某一种级别要求的关系模式的集合，关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/24.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/25.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/26.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/27.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/28.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/29.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/30.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/31.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/32.png"><br>8.关系模式<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/33.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/34.png"><br>不能说规范化程度越高的关系模式就越好，上面的规范化步骤可以在其中任何一步终止<br>9.关系模式的分解<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/35.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/36.png"><br>关系模式分解必须满足：分解的无损连接性和函数的依赖保持性<br>判断对关系模式的一个分解是否于原关系模式等价的标准：具有无损连接性以及保持函数依赖<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/37.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/38.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/39.png"><br>10.当关系模式R被分解为两个子模式时，下述定理给出了一个判别无损连接性的简单方法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/44.png"><br>保持函数依赖的模式分解<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/45.png"><br>11.关系模式分解算法<br>分解具有无损连接性和分解保持函数依赖是两个互相独立的标准<br>具有无损连接性的分解不一定能够保持函数依赖，保持函数依赖的分解也不一定具有无损连接性<br>11.1分解算法1<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/46.png"><br>如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/47.png"><br>该算法的正确性分析：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/48.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/49.png"><br>11.2分解算法2<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/50.png"><br>正确性分析<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/51.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/52.png"><br>11.3分解算法3<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/53.png"><br>正确性分析<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/54.png"><br>3.3.3关系模式优化<br>1.关系模式的优化是根据需求分析和概念设计中定义的事务的特点，对关系进行分解，提高数据操作的效率和存储空间的利用率<br>2.关系数据模型的优化通常以规范化理论为指导：确定数据依赖；极小化模式之间的数据依赖、消除冗余的联系；逐一分析各个模式中是否存在部分函数依赖、传递函数依赖、多值依赖等，确定范式等级；根据需求分析阶段得到的处理要求确定是否要合并或分解某些模式；对某些模式进行必要的分解，提高操作效率和存储空间的利用率（水平分解和垂直分解）<br>3.常用的关系分解方法：<br>3.1水平分解<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/55.png"><br>3.2垂直分解<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/56.png"><br>3.3.4定义关系上的完整性和安全性约束<br>1.每个关系模式上的完整性约束分为三类：属性上的完整性约束、多个属性间的完整性约束、不同关系模式的属性间的完整性约束<br>2.安全性约束分两类：属性上的安全性约束、关系模式上的安全性约束<br>3.3.5子模式定义<br>利用视图定义外模式：使用更符合用户习惯的列名（属性重命名）、为不同级别的用户定义不同的视图、简化用户对系统的使用<br>3.3.6性能估计：性能估计是对已经设计完成的逻辑数据库的时间复杂性和空间复杂性进行估算，其结果可以用来检验现有的计算机软硬件环境是否满足要求，以便调整软硬件环境或数据库的设计<br>三个测度：逻辑记录存取数、信息传输量、存储空间占用量<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/57.png"></p><h3 id="4-物理数据库设计"><a href="#4-物理数据库设计" class="headerlink" title="4.物理数据库设计"></a>4.物理数据库设计</h3><p>4.1设计任务：在逻辑数据库设计基础上，为每个关系模式选择合适的存储结构和存取方法，使得数据库上的事务能够高效率的运行<br>4.2设计步骤：<br>分析影响物理数据库设计的因素<br>为关系模式选择存取方法<br>设计关系、索引等数据库文件的物理存储结构<br>4.3影响物理数据库设计的因素<br>1.对于数据库查询事务，需得到如下信息：查询的关系；查询条件所涉及的属性；连接条件所涉及的属性；查询的投影属性<br>2.对于数据更新事务，需得到如下信息：被更新的关系；每个关系上的更新操作的类型；删除和修改操作条件所涉及的属性；修改操作要改变的属性值<br>3.了解每个事务在各关系上运行的频率<br>4.了解每个事务的时间约束<br>4.4常用的存取方法可以分为三类：索引方法、HASH方法、聚簇方法<br>4.5索引存取方法的选择<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/58.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/59.png"><br>4.6物理存储结构设计<br>确定如何在磁盘存储器上存储关系、索引和聚簇，使得空间利用率最大化，数据操作引起的系统开销最小化<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/60.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/61.png"></p><h2 id="五、数据库实现"><a href="#五、数据库实现" class="headerlink" title="五、数据库实现"></a>五、数据库实现</h2><h3 id="1-物理存储结构"><a href="#1-物理存储结构" class="headerlink" title="1.物理存储结构"></a>1.物理存储结构</h3><p>1.物理存储结构的设计主要考虑数据库的操作效率、响应时间和空间利用率<br>2.数据库存储设备<br>层次由高到低（层次越高、成本越高、速度越快）：<br>基本存储（易失性存储）cache\main memory-&gt;辅助存储/联机存储（非易失性存储）flash memory\magnetic disk-&gt;三级存储/脱机存储（非易失性存储）optical disk\magnetic tapes<br>3.磁盘存储器<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/62.png"><br>4.磁盘存储器的读写方式<br>4.1磁盘存储器是一种随机存储器<br>4.2磁盘存储器的读写单位是扇区<br>4.3主存储器与磁盘存储器交换信息必须以磁盘块为单位，磁盘块由一个或多个扇区组成<br>4.4磁盘块地址的形式：柱面号+面号+扇区号<br>4.5进行磁盘读写时，主存储器中必须具有与磁盘块容量匹配的缓冲区，用来存储磁盘块的数据。可以一次读写一个磁盘块的数据，也可以一次读写多个邻接磁盘块中的数据<br>5.磁盘读写的代价<br>5.1寻找时间：磁头定位到指定磁道的时间<br>5.2旋转延迟：指定磁盘块转到磁头下的时间<br>5.3传输时间：主存和磁盘间传输数据的时间<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/63.png"><br>6.磁盘读写策略<br>6.1先来先服务策略：按照读写请求先后次序处理各请求，效率很低<br>6.2近者优先策略：优先处理离磁头当前位置最近的请求，读写请求多时，效率较高<br>6.3全程移动扫描策略：磁臂在0号至最大号磁道之间往返移动，边移动边处理请求<br>6.4移动扫描策略：磁臂视情况改变其移动方向，前进方向上无请求时，反方向移动<br>6.5分组扫描策略：所有读写请求分组，逐次使用移动扫描策略处理各组请求<br>6.6间歇式全程扫描策略：磁臂反复从0号柱面扫描到最大号柱面，在每个柱面停留一段时间，等待磁盘旋转n次，使各扇面被存取概率相等<br>7.一次磁盘读写需要毫秒级的时间<br>7.1寻找时间和旋转延迟一般在10毫秒级别<br>7.2数据传输时间大约在1到2毫秒时间之内<br>7.3与CPU在主存储器处理数据的时间相比，磁盘读写时间是相当高的<br>7.4磁盘读写是数据库应用的瓶颈，数据库的物理存储结构、数据库操作算法和查询优化的研究都把最小化磁盘读写次数作为重要目标之一<br>8.磁盘缓冲处理技术<br>8.1当在主存储器和磁盘之间传输多个数据块时，可以在主存储器中设置多个数据缓冲区<br>8.2磁盘系统和CPU可以并行工作。当磁盘驱动器与一个缓冲器区交换数据时，我们可以令CPU同时处理另一个缓冲区中的数据<br>9.缓冲区管理<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/64.png"><br>10.缓冲区内容替换<br>10.1最近最少使用(LRU)策略：把最长时间没有都或者写过的数据释放<br>10.2先进先出(FIFO)策略：把占用缓冲区时间最长的数据释放<br>10.3立即丢弃策略：一旦缓冲器中的数据被使用结束，立即释放<br><code>注意：释放缓冲区时，需要考虑该缓冲区数据是否需要写回磁盘存储器</code><br>11.磁盘容错技术<br>11.1磁盘故障将导致数据丢失<br>11.2解决方法<br>用一或多磁盘（数据磁盘）保存数据，用附加磁盘（冗余磁盘）保存故障恢复信息；当数据磁盘发生故障时，冗余磁盘的信息可以用来实现故障磁盘的恢复；当冗余磁盘发生故障时，数据磁盘或其他冗余磁盘用来实现故障磁盘的恢复<br>12.基于磁盘冗余技术的策略通常称为RAID(Redundant Array of Independent Disk)<br>12.1RAID1策略：每个数据盘附加一个冗盘（也称镜像盘）<br>RAID1使用的冗余磁盘和数据磁盘一样多<br>正常运行时，两盘数据保持一致<br>12.2RAID4策略：<br>仅使用一个冗余盘完成n个数据盘的奇偶校验；冗余盘的第i块存储所有n个数据盘第i块数据的奇偶校验位；如果所有n个数据磁盘的第i块的第j位上1的个数是偶数，则冗余磁盘的第i块第j位为0，否则为1<br>12.3RAID5策略：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/65.png"><br>13.磁盘文件<br>文件和关系<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/66.png"><br>13.1数据项：表示关系数据库中元组的属性值<br>13.2文件记录<br>1.文件记录定义：数据项的集合，对应于一个关系元组<br>2.文件记录的种类：定长记录，非定长记录<br>3.文件记录的存储方法：跨块存储（一个记录存储在多个文件块）、非跨块存储（一个记录只存储在一个文件块）<br>4.定长记录<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/67.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/68.png"><br>5.变长记录<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/69.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/70.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/71.png"><br>6.文件块：记录集合，一个磁盘块<br>7.文件：<br>7.1定义：文件块的集合，对应于一个关系<br>7.2种类：无序文件、有序文件、索引文件、Hash文件<br>无序文件<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/72.png"><br>无序文件的查找操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/73.png"><br>无序文件的插入操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/74.png"><br>无序文件的删除操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/75.png"><br>无序文件的修改操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/76.png"><br>有序文件<br>记录按照某个（或某些）域的值的大小顺序排序，用于排序的域称为排序域<br>有序文件的查找操作<br>若查找操作的条件定义在排序域上，可以使用二分查找，平均时间复杂性为O(logN)；若查找操作的条件定义在非排序域上，排序文件没有提供任何优越性，需要对文件进行顺序搜索，查找时间与无序文件相同<br>有序文件的插入操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/77.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/78.png"><br>有序文件的删除操作<br>可以使用删除标志位和周期整理存储空间的方法实现删除操作<br>有序文件的修改操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/79.png"><br>7.3文件的存储方法：连续存储方法、链接存储方法、索引存储方法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/80.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/81.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/82.png"><br>14.Hash文件<br>1.概述<br>用Hash函数来存储和存取关系记录，对文件中每个记录的同一属性或属性集需要计算一个散列函数，散列函数的结果确定了记录应该存储到文件的哪个物理块中<br>2.Hash桶<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/83.png"><br>3.如果文件的记录在Hash属性上分布不均匀，可能产生桶溢出问题<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/84.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/85.png"><br>4.简单Hash方法<br>4.1查找<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/86.png"><br>4.2插入<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/87.png"><br>4.3删除<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/88.png"><br>4.4缺点<br>只能有效地支持在Hash码上具有相等比较的数据操作；由于Hash桶的数量一成不变，当文件记录较少时，将浪费大量存储空间；当文件记录超过一定数量以后，磁盘块链将会很长，影响记录的存取效率<br>5.动态Hash方法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/89.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/90.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/91.png"><br>6.可扩展Hash方法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/92.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/93.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/94.png"><br>7.线性Hash方法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/95.png"><br>15.索引文件<br>15.1为了方便实现查询，通常一个关系建立一个或多个索引。索引是一种数据结构，通常是有序文件<br>15.2按结构对索引进行分类<br>1.稀疏索引<br>把所有记录按索引域的值分组，每组一个索引项，这种索引的索引项少，管理方便，但更新代价较高<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/96.png"><br>2.稠密索引<br>每个索引域的值对应一个索引项，索引文件有序，查找、更新方便，但索引项多，空间复杂性大<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/97.png"><br>15.3多级索引<br>索引文件可以再加索引，乃至建立多级索引<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/98.png"><br>15.4按索引域特点分类索引<br>主索引<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/99.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/100.png"><br>聚集索引<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/101.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/102.png"><br>辅助索引<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/103.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/104.png"><br>16.B+树文件索引<br>16.1索引树结构<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/105.png"><br>16.2索引树的缺点<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/106.png"><br>16.3B+树<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/107.png"><br>16.4相关算法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/108.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/109.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/110.png"><br>17.多维索引<br>17.1问题<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/111.png"><br>17.2分类<br>1.类散列表方法<br>网格文件<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/112.png"><br>分段散列<br>2.类树方法<br>多键索引<br>kd树<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/113.png"><br>四叉树<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/114.png"><br>R树<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/115.png"></p><h3 id="2-查询处理与优化"><a href="#2-查询处理与优化" class="headerlink" title="2.查询处理与优化"></a>2.查询处理与优化</h3><p>2.0关系代数操作算法<br>算法运行环境：M+1个缓冲区（输入和输出）+外存中存放的数据<br>算法运行代价：磁盘块存取数<br>算法处理能力：能够处理输入关系大小的最大值<br>外存中的MergeSort（归并）<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/116.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/117.png"><br>建立在外存中的哈希文件<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/118.png"><br>2.1选择操作算法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/119.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/120.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/121.png"><br>2.2投影操作算法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/122.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/123.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/124.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/125.png"><br>2.3连接操作算法<br>0-连接操作算法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/126.png"><br>等值连接操作算法<br>等值连接和自然连接是应用最多的连接操作，两者的操作算法无本质区别<br>自然连接<br>循环嵌套连接(Nest-Loop-Join)算法、排序合并连接(Sort-Merge-Join)算法、Hash-连接算法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/127.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/128.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/129.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/130.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/131.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/132.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/133.png"><br>三种连接算法的小结：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/134.png"><br>2.4集合操作算法<br>输入关系的约束：具有相同的属性集合，并且属性的排序顺序必须也相同<br>实现这些操作的常用算法：首先利用排序算法在相同的键属性上排序两个操作关系；然后扫描这两个排序后的关系，完成并、交或差操作<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/135.png"><br>2.5查询优化<br>1.下推选择<br>当查询中涉及视图时，某些情况下：首先将选择操作尽可能往树的上部移动是很重要的，然后再把选择下推到所有可能的分支<br>2.涉及投影的定律<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/136.png"><br>3.有关连接与笛卡尔积的定律<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/137.png"><br>4.启发式优化的原则<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/138.png"><br>5.操作代价的估计<br>逻辑计划可以派生出多个不同物理计划，对每个物理计划进行评价，或估计实现这个转换的代价（称为基于代价的枚举），从中选择具有最小估计代价的物理查询计划。<br>中间结果关系大小的估计<br>用于处理中间关系的磁盘I/O数是描述查询计划代价大小的一个函数<br>由于未经计算，一般难以准确地获得中间关系的元组数。因此，只能通过一些原则，对中间结果关系的大小进行尽可能准确地估计<br>符号：V(R,Y):表示关系R在属性Y上的值域大小<br>6.选择操作结果大小的估计<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/139.png"><br>7.并、交、差操作结果大小的估计<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/140.png"><br>8.消除重复、分组聚集结果大小的估计<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/141.png"><br>9.连接大小的估计<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/142.png"><br>10.连接顺序的选择<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/143.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/144.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/145.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/146.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/147.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/148.png"><br>11.选择连接顺序的贪心算法<br>初始化：从最小的关系开始<br>启发式策略：在所有还没有包含在当前树中的关系里，寻找与当前树进行连接能生成估计代价最小的关系. 当前树作为连接的左参数，选中的关系作为右参数来形成新的当前树</p><h3 id="3-事务处理与恢复"><a href="#3-事务处理与恢复" class="headerlink" title="3.事务处理与恢复"></a>3.事务处理与恢复</h3><p>3.1事务概念<br>1.事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位<br>2.事务与程序不同<br>在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句或整个程序<br>一个程序通常包含多个事务<br>3.事务是并发控制和恢复的基本单位<br>4.事务定义<br>4.1显式定义<br>BEGIN TRANSACTION<br>SQL 语句1<br>SQL 语句2<br>….<br>COMMIT<br>事务正常结束，提交事务的所有操作，事务中所有对数据库的更新写回到硬盘<br>BEGIN TRANSACTION<br>SQL 语句1<br>SQL 语句2<br>……<br>ROLLBACK<br>事务异常终止；事务运行的过程中发生了故障，不能继续执行；系统将事务中对数据库的所有已完成的操作全部撤销；事务回滚到开始的状态<br>4.2隐式方式：当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务<br>5.事务的特性(ACID)<br>5.1原子性(Atomicity)：即事务完全执行或完全不执行<br>5.2一致性(Consistency)：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态<br>一致性状态：数据库中只包含成功事务提交的结果<br>不一致性状态：数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态<br>5.3隔离性(Isolation)：表面看起来，每个事务都是在没有其他事务同时执行的情况下执行的<br>一个事务内部的操作及使用的数据对其他并发事务是隔离的<br>并发执行的各个事务之间不能互相干扰<br>5.4持久性(Durability)：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的<br>接下来的其他操作或故障不应该对其执行结果有任何影响<br>6.保证事务ACID特性是事务处理的任务<br>7.破坏事务ACID特性的因素<br>7.1多个事务并行运行时，不同事务的操作交叉运行<br>数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性<br>7.2事务在运行过程中被强行停止<br>数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响<br>8.事务调用以下两个操作访问数据<br>8.1Read(X)：从数据库把数据项X传送到事务的局部缓冲区<br>8.2Write(X)：从事务的局部缓冲区把数据项X传回数据库<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/149.png"><br>3.2事务的并发执行和调度<br>1.多用户数据库系统：允许多个用户同时使用的数据库系统<br>特点：在同一时刻并发运行的事务数可达数千或万个<br>2.事务执行的方式<br>2.1串行执行<br>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行<br>不能充分利用系统资源，发挥数据库共享资源的特点<br>2.2交叉并发方式<br>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行<br>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率<br>2.3同时并发方式<br>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行<br>最理想的并发方式，但受制于硬件环境<br>3.事务并发执行带来的问题：<br>3.1会产生多个事务同时存取同一个数据的情况<br>3.2可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性<br>4.DBMS必须提供并发控制机制，并发控制机制是衡量一个DBMS性能的重要标志之一<br>5.并发操作带来的数据不一致性问题<br>5.1丢失修改(Lost Update)<br>5.2不可重复读(Non-repeatable Read)：指事务1读取数据后，事务2执行更新操作，使1无法再现前一次读取结果<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/150.png"><br>5.3读“脏”数据(Dirty Read)<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/151.png"><br>6.事务的调度<br>6.1一个或多个事务的重要操作按时间排序的一个序列<br>6.2READ/WRITE序列<br>7.串行调度<br>如果一个调度S的动作组成首先是一个事务的所有动作，然后是另一个事务的所有动作，依次类推、没有动作的混合，那么我们称S是串行的<br>更精确地讲，如果有任意两个事务T和T’，若T的某个动作在T’的某个动作前，则T的所有动作在T’的所有动作前，那么调度S是串行的<br>串行调度是正确的，然而串行调度使系统资源的利用率不高<br>8.可串行化调度<br>如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则我们称这个调度是可串行化的<br>9.可串行性(Serializability)<br>是并发事务正确调度的准则<br>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度<br>10.事务和调度的一种记法<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/152.png"><br>11.冲突<br>调度中一对连续的动作<br>它们满足：如果它们的顺序交换，那么涉及的事务中至少有一个行为会改变<br>不同事务的任何两个动作在顺序上可以交换，除非：它们涉及同一数据库元素，并且至少有一个动作是写<br>12.冲突等价<br>我们说两个调度是冲突等价的，如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另一个<br>13.冲突可串行化<br>如果一个调度冲突等价于一个串行调度，那么我们说该调度是冲突可串行化的<br>一个调度若是冲突可串行化的，则一定是可串行化的调度<br>14.优先图<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/153.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/154.png"><br>15.冲突可串行判断<br>构造调度S的优先图，判断其中是否有环<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/155.png"><br>冲突可串行化调度是可串行化调度的充分条件，不是必要条件<br>存在不满足冲突可串行化条件的可串行化调度<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/156.png"><br>3.3并发控制协议<br>1.锁的概念<br>锁是数据库元素上的并发控制标志<br>锁的类型有很多，考虑两种：<br>1)共享锁(S)：如果事务T得到了数据库元素Q上的共享锁S，则T可以读Q，但不能写Q<br>2)排他锁(X)（也称互斥锁）：如果事务T得到了数据库元素Q上的排他锁X，则T既可以读Q，也可以写Q<br>多粒度的锁：上锁的数据库元素可以是关系表、磁盘块、元组<br>每个事务在存取一个数据库元素之前必须获得这个数据库元素上的锁<br>一个事务需要获得的锁的类型依赖于它将在数据库元素上执行什么样的操作<br>给定一个各种类型锁的集合，如下定义这个锁集合上的相容关系<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/157.png"><br>事务通过执行<code>LOCK-S(Q)</code>操作申请数据库元素Q上的共享锁<br>事务通过执行<code>LOCK-X(Q)</code>操作申请数据库元素Q上的排他锁<br><code>UNLOCK(Q)</code>操作用来释放Q上的锁<br>若事务T要存取数据库元素Q，T必须申请在Q上加锁。若Q已经被其他的事务加以非共享锁，则事务T必须等待，直到所有其他事务的非共享锁全部被释放<br>事务T可以释放它在任何数据库元素上所加的任何类型的锁<br>一个事务只要存取一个数据库元素，它就必须持有该数据库元素上的一个锁<br>如果一个事务完成了对一个数据库元素的最后一次存取之后就立即放弃它的锁，则不能确保调度的可串行性<br>2.两阶段锁协议<br>两阶段锁协议要求每个事务分两个阶段进行数据元素的加锁和解锁<br>1)加锁阶段：在这个阶段，事务可以申请获得任何数据库元素上的任何类型的锁，但是不能释放任何锁<br>2)解锁阶段：在这个阶段，事务可以释放任何数据库元素上的任何类型的锁，但是不能再申请任何锁<br>每个事务开始运行后即进入加锁阶段，申请获得所需要的锁<br>当一个事务第一次释放锁时，该事务进入解锁阶段。进入解锁阶段的事务不能再申请任何锁<br>任何一个满足两阶段锁协议的合理调度都是冲突可串行的<br>3.数据库图协议<br>另一种基于锁的并发控制协议<br>数据库图<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/158.png"><br>一个简单的数据库图协议：树协议<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/159.png"><br>树协议不但可以保证调度是冲突可行的，而且保证无死锁<br>4.基于时间戳的协议<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/160.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/161.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/162.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/163.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/164.png"><br>时间戳协议不但可以保证调度是冲突可串行的，而且保证无死锁<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/165.png"><br>5.对比时间戳和锁的协议<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/166.png"><br>6.死锁处理<br>在数据库系统运行期间，如果存在一组事务{T0,T1,…Tn}，使得T0等待T1持有的数据库元素锁，T1等待T2持有的锁，，，Tn等待T0持有的锁，则称系统处于死锁状态<br>解决死锁：预防死锁，使用预防死锁协议，如数据库图协议、时间戳协议等；死锁的检测于恢复<br>7.死锁检测<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/167.png"><br>8.死锁恢复<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/168.png"><br>3.4日志与故障恢复<br>1.数据库恢复<br>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策<br>2.恢复子系统是数据库管理系统的一个重要组成部分<br>3.恢复技术是衡量系统优劣的重要指标<br>4.故障种类<br>4.1介质故障（硬故障）<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/169.png"><br>4.2系统故障（软故障）<br>故障表现：整个系统的正常运行突然被破坏，所有正在运行的事务都非正常终止，不破坏数据库，内存中数据库缓冲区的信息全部丢失<br>常见原因：特定类型的硬件错误（如CPU故障），操作系统故障，DBMS代码错误，系统断电<br>系统故障恢复：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/170.png"><br>4.3事务故障<br>事务故障分类：<br>1)可预期的事务故障：可以通过事务程序本身发现<br>2)更多的是非预期的，不能由应用程序处理：运算溢出，并发事务发生死锁而被选中撤销该事务，违反了某些完整性限制等（如输入某一位数是错的）<br>后面的事务故障仅指这类非预期的故障<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/171.png"><br>4.4计算机病毒：不仅涉及数据库技术<br>5.数据库恢复的关键问题：<br>如何建立冗余数据：数据转存(backup)、日志文件(logging)<br>如何利用这些冗余数据实施数据库恢复<br>6.基于日志的恢复<br>6.1日志文件：是日志记录的一个序列，用于记载数据库事务对数据库的更新操作情况<br>6.2日志记录的格式<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/172.png"><br>6.3日志用途：进行事务故障恢复，进行系统故障恢复，协助后备副本进行介质故障恢复<br>6.4为保证数据库是可恢复，日志文件必须遵循两条原则：次序严格按并行事务执行的时间次序；必须先写日志文件，后写数据库<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/173.png"><br>7.日志缓冲技术<br>通常一个日志记录远远小于永久性存储器的读写单位<br>经常向永久存储器写单个日志记录将导致很大的系统开销<br>对日志记录的读写操作使用缓冲技术：<br>1)主存中设立缓冲区，其大小等于永久性存储器的读写单位<br>2)被写的日志记录先存储到缓冲区，缓冲区满之后再一起写入永久性存储器<br>缓冲区中的日志记录在系统发生故障时会丢失<br>为了保证事务的原子性，数据库恢复协议需遵循如下规则：<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/174.png"><br>8.数据库缓冲区技术<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/175.png"><br>9.基于日志的数据库恢复技术<br>9.1推迟更新技术<br>推迟更新协议：每个事务在提交之前不能更新数据库；在一个事务所有更新操作对应的日志记录写入永久性存储器之前，该事务不能提交<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/176.png"><br>每个事务在到达提交点之前不能更新数据库<br>在一个事务的所有更新操作对应的日志记录写入永久性存储器之前，该事务不能到达提交点<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/177.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/178.png"><br>9.2即时更新技术<br>即使更新：允许事务直接更新数据库<br>处于活动状态的事务直接在数据库上实施的更新称为非提交更新<br>即使更新协议：在一个事务的所有更新操作对应的日志记录写入永久存储器之前，事务不能更新数据库；在一个事务的所有更新操作对应的日志记录写入永久存储器之前，事务不允许提交<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/179.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/180.png"><br>10.具有检查点的恢复<br>当系统故障发生后，数据库恢复机制必须搜索日志，确定那些日志需要redo，那些事务需要undo<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/181.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/182.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/183.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/184.png"><br>11.数据库镜像<br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/185.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/186.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/187.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/188.png"><br><img src="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/189.png"></p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">Author:</i></span> <span class="reprint-info"><a href="/blog/about" rel="external nofollow noreferrer">Jia_KHC</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">Link:</i></span> <span class="reprint-info"><a href="/blog/2022/06/01/shu-ju-ku-xi-tong-ke-cheng-bi-ji/">《数据库系统》课程笔记</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">Reprint policy:</i></span> <span class="reprint-info">All articles in this blog are used except for special statements <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> reprint policy. If reproduced, please indicate source <a href="/blog/about" target="_blank">Jia_KHC</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/blog/tags/%E7%90%86%E8%AE%BA/"><span class="chip bg-color">理论</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/blog/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/blog/libs/share/js/social-share.min.js"></script></div></div></div></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;Previous</div><div class="card"><a href="/blog/2022/08/27/unity-an-zhuo-da-bao-bao-cuo-jie-jue-fang-fa/"><div class="card-image"><img src="/blog/medias/featureimages/1.jpg" class="responsive-img" alt="Unity安卓打包报错解决方法"> <span class="card-title">Unity安卓打包报错解决方法</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-08-27</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/blog/categories/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6-Unity/" class="post-category">应用软件-Unity</a></span></div></div><div class="card-action article-tags"><a href="/blog/tags/Unity/"><span class="chip bg-color">Unity</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">Next&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/blog/2022/05/22/suan-fa-she-ji-yu-fen-xi-ke-cheng-bi-ji/"><div class="card-image"><img src="/blog/medias/featureimages/1.jpg" class="responsive-img" alt="《算法设计与分析》课程笔记"> <span class="card-title">《算法设计与分析》课程笔记</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-05-22</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" class="post-category">笔记</a></span></div></div><div class="card-action article-tags"><a href="/blog/tags/%E7%90%86%E8%AE%BA/"><span class="chip bg-color">理论</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />From: 布执刀<br />Author: Jia_KHC<br />Link: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="/blog/libs/codeBlock/codeBlockFuction.js"></script><script src="/blog/libs/codeBlock/codeLang.js"></script><script src="/blog/libs/codeBlock/codeCopy.js"></script><script src="/blog/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="max-height:600px;height:auto!important;overflow-y:auto"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/blog/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/blog/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{display:none;font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{display:none;font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/blog/libs/aplayer/APlayer.min.js"></script><script src="/blog/libs/aplayer/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2022-2024</span> <a href="/blog/about" target="_blank">Jia_KHC</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="busuanzi_container_site_pv">&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv">&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span></span><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=new Date,t="2022",n=e.getFullYear(),i=e.getMonth()+1,a=e.getDate(),r=e.getHours(),s=e.getMinutes(),o=e.getSeconds(),g=Date.UTC(t,"1","9","16","11","0"),d=Date.UTC(n,i,a,r,s,o)-g,m=Math.floor(d/31536e6),l=Math.floor(d/864e5-365*m);if(t===String(n)){document.getElementById("year").innerHTML=n;var c="This site has been running for "+l+" days";0,document.getElementById("sitetime").innerHTML=c}else{document.getElementById("year").innerHTML=t+" - "+n;var u="This site has been running for "+m+" years and "+l+" days";0,document.getElementById("sitetime").innerHTML=u}};calcSiteTime()</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="mailto:1073475535@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1073475535" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1073475535" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/blog/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;Search</span> <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,a,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),r=document.getElementById(a),n=document.getElementById(s);r.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var r=!0,n=t.title.trim().toLowerCase(),a=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),e=t.url;e=0===e.indexOf("/")?t.url:"/"+e;var s=-1,i=-1,l=-1;if(""!==n&&""!==a&&m.forEach(function(t,e){s=n.indexOf(t),i=a.indexOf(t),s<0&&i<0?r=!1:(i<0&&(i=0),0===e&&(l=i))}),r){f+="<li><a href='"+e+"' class='search-result-title'>"+n+"</a>";var c=t.content.trim().replace(/<[^>]+>/g,"");if(0<=l){var u=l-20,o=l+80;u<0&&(u=0),0===u&&(o=100),o>c.length&&(o=c.length);var h=c.substr(u,o);m.forEach(function(t){var e=new RegExp(t,"gi");h=h.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+h+"...</p>"}f+="</li>"}}),f+="</ul>",n.innerHTML=f)})}})}("/blog/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/blog/libs/materialize/materialize.min.js"></script><script src="/blog/libs/masonry/masonry.pkgd.min.js"></script><script src="/blog/libs/aos/aos.js"></script><script src="/blog/libs/scrollprogress/scrollProgress.min.js"></script><script src="/blog/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/blog/js/matery.js"></script><script>var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="/blog/libs/others/snow.js"><\/script>')</script><script src="https://ssl.captcha.qq.com/TCaptcha.js"></script><script src="/blog/libs/others/TencentCaptcha.js"></script><button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/blog/libs/others/clicklove.js" async></script><script async src="/blog/libs/others/busuanzi.pure.mini.js"></script><script src="/blog/libs/instantpage/instantpage.js" type="module"></script></body></html>